<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>VEHICLELAB - Vehicle Diagnostic Lab</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
<script>
/* =================== UniPlot-like Plotly Template (Robust Setup) ======================== */
(function(){
 // Defer template setup until Plotly is fully loaded
 function setupPlotlyTemplate() {
   if (typeof Plotly === 'undefined') {
     console.warn('Plotly not loaded yet, deferring template setup');
     setTimeout(setupPlotlyTemplate, 100);
     return;
   }
   const baseFont = "Inter, Segoe UI, system-ui, Arial, sans-serif";
   const axisCommon = {
     showline:true, linecolor:"#111", linewidth:1.4, mirror:"allticks",
     ticks:"outside", tickcolor:"#111", ticklen:6, tickwidth:1.2,
     showgrid:true, gridcolor:"#e5e7eb", gridwidth:1,
     minor:{ showgrid:true, gridcolor:"#f1f5f9" },
     zeroline:false, automargin:true, title:{ standoff:12 }
   };
   const layout = {
     font:{ family:baseFont, size:13, color:"#0b1220" },
     paper_bgcolor:"white", plot_bgcolor:"white",
     margin:{ l:70, r:26, t:60, b:60 },
     legend:{ orientation:"h", x:0, y:1.12, xanchor:"left", yanchor:"bottom" },
     xaxis:{ ...axisCommon }, yaxis:{ ...axisCommon },
     colorway:["#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"],
     hovermode:"x unified", 
     dragmode:"zoom" // Set default drag mode to zoom
   };
   const traceDefaults = {
     scatter:{ mode:"lines", line:{ width:2 }, marker:{ size:6, line:{ width:0 } } },
     bar:{ marker:{ line:{ width:0 } } },
     box:{ line:{ width:1.4 } },
     violin:{ line:{ width:1.4 } },
     histogram:{ marker:{ line:{ width:0 } } },
     contour:{ line:{ smoothing:0.6 } },
     histogram2d:{},
     densityheatmap:{},
     scatter3d:{ marker:{ size:3 } },
     surface:{ contours:{ z:{ show:true, usecolormap:true, highlight:false } } },
     candlestick:{ increasing:{ line:{ width:1.4 } }, decreasing:{ line:{ width:1.4 } } }
   };
   
   // Safely check for and initialize Plotly.templates
    if (typeof Plotly.templates === 'undefined') {
        Plotly.templates = {};
    }
    Plotly.templates["uniplot"] = { data: traceDefaults, layout };
    console.log('UniPlot template registered successfully');
    
   // Safely set plot config
   if (Plotly.setPlotConfig) {
     Plotly.setPlotConfig({
       displaylogo:false,
       responsive:true,
       scrollZoom:true,
       modeBarButtonsToRemove: ['lasso2d', 'select2d', 'toggleSpikelines']
     });
   }
 }
 // Start the setup process
 if (document.readyState === 'loading') {
   document.addEventListener('DOMContentLoaded', setupPlotlyTemplate);
 } else {
   setupPlotlyTemplate();
 }
})();
</script>
<!-- BEGIN: Robust playground select helpers & fetch wrapper -->
<script>
/**
 * safeFetch - wrapper around fetch that returns parsed JSON or throws a wrapped error
 * This surfaces server errors and network failures more clearly to the console/UI.
 */
async function safeFetch(url, opts = {}) {
  try {
    const res = await fetch(url, opts);
    const ct = res.headers.get('content-type') || '';
    let body = null;
    if (ct.includes('application/json')) {
      body = await res.json();
    } else {
      body = await res.text();
    }
    if (!res.ok) {
      const e = new Error(`Request failed ${res.status} ${res.statusText}`);
      e.status = res.status;
      e.body = body;
      throw e;
    }
    return body;
  } catch (err) {
    // Wrap network errors to make console logs consistent
    if (err.name === 'AbortError') {
      console.debug('safeFetch aborted for', url);
      // Return a predictable structure for aborted requests
      return { aborted: true, error: 'Request canceled' };
    }
    const wrapped = new Error('safeFetch error: ' + (err && err.message ? err.message : err));
    wrapped.original = err;
    wrapped.url = url;
    console.error(wrapped);
    throw wrapped;
  }
}
</script>
<!-- safe Plotly helpers -->
<script>
function isDisplayed(el) {
  if (!el) return false;
  if (el.offsetParent === null) return false;
  const r = el.getBoundingClientRect();
  return r.width > 0 && r.height > 0;
}
async function safePlotlyResize(plotEl) {
  try {
    if (!plotEl || !isDisplayed(plotEl)) return;
    if (window.Plotly && window.Plotly.Plots && typeof window.Plotly.Plots.resize === 'function') {
      window.Plotly.Plots.resize(plotEl);
    } else if (window.Plotly && typeof window.Plotly.resize === 'function') {
      window.Plotly.resize(plotEl);
    }
  } catch (err) {
    console.warn('safePlotlyResize failed', err);
    window.plotErrorHandler?.(err, 'safePlotlyResize');
  }
}
function safeResizeAllPlots() {
  const plotDivs = document.querySelectorAll('.plotly-graph-div, .plotly');
  plotDivs.forEach(d => safePlotlyResize(d));
}
function debounce(fn, wait=150){ let t=null; return function(...a){ clearTimeout(t); t=setTimeout(()=>fn.apply(this,a), wait); }; }
window.addEventListener('resize', debounce(()=>safeResizeAllPlots(), 120));

// Handle browser zoom changes (Chrome 80-125%)
let lastZoomLevel = window.devicePixelRatio;
function handleZoomChange() {
  const currentZoom = window.devicePixelRatio;
  if (Math.abs(currentZoom - lastZoomLevel) > 0.1) {
    lastZoomLevel = currentZoom;
    setTimeout(() => {
      safeResizeAllPlots();
      // Force reflow for table wrappers
      document.querySelectorAll('.table-wrapper').forEach(wrapper => {
        wrapper.style.display = 'none';
        wrapper.offsetHeight; // Force reflow
        wrapper.style.display = '';
      });
    }, 100);
  }
}
window.addEventListener('resize', debounce(handleZoomChange, 150));

// Playground-specific resize handler
function initPlaygroundResize() {
  const playgroundContainer = document.querySelector('.playground-container');
  if (!playgroundContainer) return;

  const resizeObserver = new ResizeObserver(debounce(() => {
    const plotDiv = document.getElementById('pg-canvas');
    if (plotDiv) {
      safePlotlyResize(plotDiv);
    }
  }, 200));

  resizeObserver.observe(playgroundContainer);
}
</script>
<script>

/**
 * safeFillSelect - fill a <select> element safely from items
 * items: array of { value, label } or strings
 * multiple: boolean (true for multi-select)
 * placeholder: text for empty selection (single-select only)
 */
function safeFillSelect(selectId, items = [], multiple = false, placeholder = '-- None --') {
  const sel = document.getElementById(selectId);
  if (!sel) {
    console.warn(`safeFillSelect: element not found: ${selectId}`);
    return;
  }

  // remove all existing options
  while (sel.firstChild) sel.removeChild(sel.firstChild);

  // set multiple attribute
  if (multiple) sel.setAttribute('multiple', '');
  else sel.removeAttribute('multiple');

  // Normalize items into {value,label}
  const normalized = (items || []).map(it => {
    if (typeof it === 'string') return { value: it, label: it };
    if (it && typeof it === 'object') {
      return {
        value: it.value ?? it.id ?? it.name ?? it.clean ?? JSON.stringify(it),
        label: it.label ?? it.name ?? it.clean ?? it.id ?? String(it.value ?? '')
      };
    }
    return { value: String(it), label: String(it) };
  });

  // add placeholder for single-select
  if (!multiple) {
    const ph = document.createElement('option');
    ph.value = '';
    ph.textContent = placeholder;
    ph.disabled = true;
    ph.selected = true;
    sel.appendChild(ph);
  }

  normalized.forEach(opt => {
    // skip totally empty items
    if ((opt.value === undefined || opt.value === null) && !opt.label) return;
    const o = document.createElement('option');
    o.value = opt.value ?? opt.label;
    o.textContent = opt.label ?? opt.value;
    sel.appendChild(o);
  });

  sel.disabled = false;

  // Emit event so preview UI updates
  sel.dispatchEvent(new Event('optionsUpdated', { bubbles: true }));
}

/**
 * fillAxisSelects - populate the common playground selects (pg-x, pg-y, pg-z, pg-color, pg-size, pg-group)
 * It reads defensively from window.state.channels if available.
 */
// Extract clean display name from full signal path (matching backend logic exactly)
function extractDisplayName(signalName) {
    if (!signalName) return signalName;
    
    const name = String(signalName).trim();
    
    // Rule 1: Check for dot separator
    if (name.includes('.')) {
        const parts = name.split('.');
        // Take the last non-empty part
        for (let i = parts.length - 1; i >= 0; i--) {
            const part = parts[i].trim();
            if (part && part.length > 2) {
                return part;
            }
        }
    }
    
    // Rule 2: Remove known OEM/module prefixes
    // Patterns: '96D7124080_8128328U_FM77_nc_', 'MG1CS051_H440_2F_', etc.
    // Module prefixes are: alphanumeric sequences (often with numbers), short segments (nc, SG)
    // Actual signals start with: meaningful words (CAN, EngM, etc.)
    const parts = name.split('_');
    
    // Look for the first segment that looks like an actual signal name
    // Signal indicators:
    // - All uppercase word (3+ chars) like CAN, VITESSE, PENTE
    // - Starts with uppercase letter followed by lowercase (like EngM, TqSys)
    // - Not part of module identifier pattern (alphanumeric codes)
    let meaningfulStart = -1;
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (!part) continue;
        
        // Check if part looks like module identifier (skip these):
        // - Starts with number
        // - Short (1-2 chars) like 'nc', 'SG'
        // - Mixed case with numbers at start (like '96D7124080', 'MG1CS051')
        const isModuleId = (
            part[0].match(/\d/) ||  // Starts with number
            part.length <= 2 ||     // Short segments
            (part.match(/^[a-zA-Z0-9]+$/) && part[0].match(/[A-Z]/) && part.substring(0, 3).match(/\d/))  // Mixed alphanumeric at start
        );
        
        if (!isModuleId) {
            // This could be the signal start
            // Check: is it a meaningful signal name?
            const isUpperCase = part === part.toUpperCase() && part.length >= 3;
            const isCamelCase = part[0] && part[0] === part[0].toUpperCase() && part.substring(1) === part.substring(1).toLowerCase();
            
            if (isUpperCase || isCamelCase) {
                // Looks like actual signal - check if previous parts were all module identifiers
                if (i === 0 || parts.slice(0, i).every(p => {
                    if (!p) return true;
                    return p[0].match(/\d/) || 
                           p.length <= 2 || 
                           (p.match(/^[a-zA-Z0-9]+$/) && p[0].match(/[A-Z]/) && p.substring(0, 3).match(/\d/));
                })) {
                    meaningfulStart = i;
                    break;
                }
            }
        }
    }
    
    if (meaningfulStart >= 0 && meaningfulStart < parts.length) {
        // Return from the meaningful part onwards
        const result = parts.slice(meaningfulStart).join('_');
        if (result) return result;
    }
    
    // Rule 3: Fallback - try regex pattern matching for module prefixes
    // Pattern: One or more sequences of uppercase+digits separated by underscores, ending with underscore
    const match = name.match(/^([A-Z0-9]+_[A-Z0-9]+(_[A-Z0-9]+)*_)/);
    if (match) {
        const remaining = name.substring(match[0].length);
        if (remaining && remaining.length > 3) {
            return remaining;
        }
    }
    
    // Final fallback: return as-is if no pattern matched
    return name;
}

function fillAxisSelects() {
  const channels = (window.state && Array.isArray(window.state.channels)) ? window.state.channels : [];
  const items = channels.map(ch => {
    const rawValue = (typeof ch === 'string') ? ch : (ch.clean ?? ch.id ?? ch.name ?? ch.value ?? JSON.stringify(ch));
    const rawLabel = (typeof ch === 'string') ? ch : (ch.name ?? ch.clean ?? ch.id ?? String(ch.value ?? ''));
    // Use extracted display name for labels
    return {
      value: rawValue,
      label: extractDisplayName(rawLabel)
    };
  });

  safeFillSelect('pg-x', items, false, 'Select X signal');
  safeFillSelect('pg-y', items, false, 'Select Y signal');
  safeFillSelect('pg-z', items, false, 'Select Z signal');
  safeFillSelect('pg-color', items, false, '-- None --');
  safeFillSelect('pg-size', items, false, '-- None --');
  safeFillSelect('pg-group', items, false, '-- None --');

  console.debug(`fillAxisSelects: filled pg-x/pg-y/pg-z/pg-color/pg-size/pg-group from window.state.channels (count=${items.length})`);
}

/**
 * enhanceSelectPreview - Creates a custom preview for a native <select> element.
 * @param {string} selectId - The ID of the <select> element.
 * @param {string} previewId - The ID of the preview <div> element.
 * @param {object} opts - Options { placeholder, sub }.
 */
function enhanceSelectPreview(selectId, previewId, opts = {}) {
  const sel = document.getElementById(selectId);
  const previewDiv = document.getElementById(previewId);
  const previewLabel = previewDiv ? previewDiv.querySelector('.label') || document.getElementById(previewId + '-label') : null;
  const previewSub = previewDiv ? previewDiv.querySelector('.muted') || document.getElementById(previewId + '-sub') : null;

  if (!sel || !previewDiv || !previewLabel) return;

  function updatePreview() {
    try {
      if (sel.multiple) {
        const items = Array.from(sel.selectedOptions || []).map(o => o.textContent).filter(Boolean);
        if (items.length === 0) {
          previewLabel.textContent = opts.placeholder || 'Select items';
          if (previewSub) previewSub.textContent = opts.sub || 'Multiple';
        } else if (items.length === 1) {
          previewLabel.textContent = items[0];
          if (previewSub) previewSub.textContent = opts.sub || '1 selected';
        } else {
          previewLabel.textContent = items[0];
          if (previewSub) previewSub.textContent = `${items.length} selected`;
        }
      } else {
        const val = sel.selectedOptions && sel.selectedOptions[0];
        if (!val || !val.textContent || val.value === '') {
          previewLabel.textContent = opts.placeholder || 'Select signal';
          if (previewSub) previewSub.textContent = opts.sub || '';
        } else {
          previewLabel.textContent = val.textContent;
          if (previewSub) previewSub.textContent = opts.sub || '';
        }
      }
    } catch (err) {
      // defensive fallback
      previewLabel.textContent = opts.placeholder || 'Select';
      if (previewSub) previewSub.textContent = opts.sub || '';
    }
  }

  sel.addEventListener('change', updatePreview);
  sel.addEventListener('optionsUpdated', updatePreview);

  // clicking preview opens the native select (keeps accessibility)
  previewDiv.addEventListener('click', () => {
    sel.focus();
    // try to open native dropdown (works on many browsers)
    const ev = new MouseEvent('mousedown', { bubbles: true, cancelable: true });
    sel.dispatchEvent(ev);
  });

  previewDiv.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      sel.focus();
      const ev = new MouseEvent('mousedown', { bubbles: true, cancelable: true });
      sel.dispatchEvent(ev);
    }
  });

  // initial render
  setTimeout(updatePreview, 0);
}


/* Auto-fill playground selects when channel list becomes available.
   This will poll briefly and fill when window.state.channels appears.
*/
(function () {
  function doFill() {
    const channels = (window.state && Array.isArray(window.state.channels)) ? window.state.channels : null;
    if (!channels || channels.length === 0) return false;
    
    // Use the robust, globally-defined fill function
    if (typeof fillAxisSelects === 'function') {
      fillAxisSelects();
    } else {
      console.warn('Auto-fill: fillAxisSelects() not found.');
      return false; // Don't proceed if the main function is missing
    }
    
    console.debug('Auto-filled playground selects from window.state.channels (count=' + channels.length + ')');
    return true;
  }

  if (doFill()) return;

  let attempts = 0;
  const maxAttempts = 50;
  const h = setInterval(() => {
    attempts++;
    if (doFill() || attempts > maxAttempts) {
      clearInterval(h);
      if (attempts > maxAttempts) console.warn('Auto-fill: no channels found after polling.');
    }
  }, 100);
})();
</script>
<!-- END: Robust playground select helpers & fetch wrapper -->

<script>
// Add this error handling utility
window.plotErrorHandler = function(error, context) {
 console.error(`Plot error in ${context}:`, error);
 const statusEl = document.getElementById('pg-status') || document.getElementById('analytics-status');
 if (statusEl) {
   statusEl.textContent = `Error: ${error.message || 'Unknown plotting error'}`;
   statusEl.style.display = 'block';
   statusEl.classList.add('error');
   setTimeout(() => {
     statusEl.style.display = 'none';
     statusEl.classList.remove('error');
   }, 5000);
 }
};

/* ===== Render-lock + spinner + timer + server error logging ===== */
// small sliding window of recent durations (ms)
window.__renderDurationsMs = window.__renderDurationsMs || [];

// send error to server using safeFetch if available, otherwise fallback to fetch
async function sendErrorToServer(errObj = {}, context = '') {
  try {
    const payload = {
      level: 'error',
      context: context || (errObj && errObj.context) || 'general',
      message: (errObj && (errObj.message || errObj.toString())) || String(errObj),
      stack: (errObj && errObj.stack) || null,
      ts: new Date().toISOString(), // FIXED: Use dynamic timestamp
      client_meta: {
        userAgent: navigator.userAgent,
        url: window.location.href,
        user: "Bonged"
      }
    };

    // Use safeFetch for robust sending
    const send = async (url, body) => {
      if (typeof safeFetch === 'function') {
        return safeFetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      } else {
        return fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      }
    };

    await send('/api/log_error', payload);
    console.debug('Sent error to /api/log_error:', payload);
  } catch (e) {
    // don't crash the UI for a logging failure - print to console
    console.warn('Failed to send error to server', e);
  }
}

/* withButtonLock: disable button + show spinner and status while fn runs. */
async function withButtonLock(buttonEl, fn, contextLabel = 'render') {
  if (!buttonEl) return await fn();

  if (buttonEl.dataset.locked === '1') return;
  buttonEl.dataset.locked = '1';
  buttonEl.classList.add('loading');
  buttonEl.disabled = true;

  const statusEl = document.getElementById('pg-status');
  if (statusEl) { statusEl.classList.remove('hidden'); statusEl.textContent = 'Starting...'; }

  const start = performance.now();
  let elapsedInterval = null;
  try {
    elapsedInterval = setInterval(() => {
      const now = performance.now();
      const elapsedMs = Math.round(now - start);
      const durations = window.__renderDurationsMs || [];
      const mean = durations.length ? Math.round(durations.reduce((a,b)=>a+b,0)/durations.length) : null;
      const estRemaining = mean ? Math.max(0, Math.round((mean - elapsedMs)/1000)) : null;
      if (statusEl) {
        statusEl.textContent = estRemaining !== null ? `Rendering — elapsed ${(elapsedMs/1000).toFixed(1)}s, est ${estRemaining}s` :
                                                     `Rendering — elapsed ${(elapsedMs/1000).toFixed(1)}s`;
      }
    }, 400);

    const result = await fn();

    const duration = Math.round(performance.now() - start);
    window.__renderDurationsMs = (window.__renderDurationsMs || []).concat([duration]).slice(-8);

    if (statusEl) {
      statusEl.textContent = `Done — ${(duration/1000).toFixed(1)}s`;
      setTimeout(()=> { if (statusEl) statusEl.classList.add('hidden'); }, 1400);
    }

    return result;
  } catch (err) {
    console.error('withButtonLock: caught error in', contextLabel, err);
    sendErrorToServer(err, contextLabel).catch(()=>{/*no-op*/});
    if (statusEl) {
      statusEl.textContent = 'Error — check logs';
      setTimeout(()=> { if (statusEl) statusEl.classList.add('hidden'); }, 3000);
    }
    throw err;
  } finally {
    if (elapsedInterval) clearInterval(elapsedInterval);
    delete buttonEl.dataset.locked;
    buttonEl.classList.remove('loading');
    buttonEl.disabled = false;
  }
}

/* Enhance global plotErrorHandler to also forward to server. */
(function enhancePlotErrorHandler() {
  try {
    const original = window.plotErrorHandler;
    window.plotErrorHandler = function(err, ctx) {
      // Call original handler first if it exists and is not a self-reference
      if (typeof original === 'function' && original !== window.plotErrorHandler) {
        try { original(err, ctx); } catch (e) { console.warn('original plotErrorHandler threw', e); }
      }
      // Then, send the error to the server
      try {
        sendErrorToServer(err, ctx).catch(()=>{/*no-op*/});
      } catch(e) {
        console.warn('enhancedPlotErrorHandler: send failed', e);
      }
    };
  } catch(e) {
    console.warn('enhancePlotErrorHandler failed', e);
  }
})();

// =================================================================================
// ==================== REPAIRED & UNIFIED PLAYGROUND LOGIC ========================
// =================================================================================
(function(){
  // Helper to get element by ID
  function el(id){ return document.getElementById(id); }

  // AbortController to cancel in-flight requests
  let __lastSeriesController = null;
  
  // Plot state (exposed globally so other modules can call redraw/render)
  window.plotState = {
    traces: [],
    layout: { template:'uniplot', title:'', paper_bgcolor:'white', plot_bgcolor:'white', legend:{orientation:'h'} },
    stackedRows: 1,
    lastFigure: null
  };
  
  // Professional PLOTLY_BASE_CONFIG - world-class configuration like Plotly website
  const PLOTLY_BASE_CONFIG = {
    responsive: true,
    displaylogo: false,
    scrollZoom: true,
    doubleClick: 'reset',
    modeBarButtonsToRemove: ['sendDataToCloud', 'lasso2d', 'select2d'],
    modeBarButtonsToAdd: [
      'zoom2d', 
      'pan2d',
      'zoomIn2d', 
      'zoomOut2d', 
      'autoScale2d', 
      'resetScale2d',
      'toggleSpikelines',
      'hoverClosestCartesian',
      'hoverCompareCartesian'
    ],
    toImageButtonOptions: { 
      format: 'png', 
      filename: 'plot', 
      height: 900, 
      width: 1600,
      scale: 2  // High DPI for professional output
    },
    displayModeBar: true,
    displayModeBarButtons: true,
    showTips: true,
    showLink: false,
    plotGlPixelRatio: 2,  // High quality rendering
    queueLength: 0  // Immediate rendering
  };

  // Make populatePlaygroundFromState resilient
  window.populatePlaygroundFromState = function() {
    const chans = window.state?.channels;
    if (!chans || chans.length === 0) {
        console.warn("Playground: no channels in state");
        // Channels are selected in Analyse tab, no status message needed
        return;
    }

    fillAxisSelects();
    
    // Update file info display
    updatePlaygroundFileInfo();
  };
  
  // Update playground file information display
  async function updatePlaygroundFileInfo() {
    try {
      const filesRes = await safeFetch('/api/files');
      if (filesRes && filesRes.files && Array.isArray(filesRes.files)) {
        const fileCount = filesRes.files.length;
        const filesInfoEl = el('pg-files-info');
        const filesCountEl = el('pg-files-count');
        
        if (filesInfoEl && filesCountEl) {
          const fileNames = filesRes.files.map(f => f.name || f.path?.split(/[\\/]/).pop() || 'unknown').slice(0, 3);
          filesCountEl.textContent = `Using ${fileCount} file${fileCount !== 1 ? 's' : ''}${fileCount > 3 ? ' (showing first 3)' : ''}: ${fileNames.join(', ')}${fileCount > 3 ? '...' : ''}`;
          filesInfoEl.style.display = 'block';
          console.debug('[Playground] File info updated:', { count: fileCount, files: fileNames });
        }
      }
    } catch (err) {
      // Silently handle connection errors - server may not be running or endpoint may not exist
      // Only log in debug mode
      if (err.original && err.original.message && !err.original.message.includes('ERR_CONNECTION_REFUSED')) {
        console.debug('[Playground] Could not fetch file info:', err);
      }
      const filesInfoEl = el('pg-files-info');
      if (filesInfoEl) filesInfoEl.style.display = 'none';
    }
  }

  // Fetch series for selected ids
  async function fetchSeriesForSignals(signalIds, tmin=null, tmax=null, maxPoints=20000){
      // Define generateAliases helper at function scope
      const generateAliases = (name) => {
        const aliases = new Set();
        if (!name) return aliases;
        const str = String(name);
        aliases.add(str);
        const clean = str.replace(/[^a-zA-Z0-9_]/g, '_');
        aliases.add(clean);
        aliases.add(str.toLowerCase());
        aliases.add(clean.toLowerCase());
        aliases.add(str.replace(/_/g, '.'));
        aliases.add(str.replace(/\./g, '_'));
        if (str.includes('.')) {
          const compact = str.split('.').pop();
          if (compact) aliases.add(compact);
        }
        return Array.from(aliases);
      };
      
      if (__lastSeriesController) {
        try { __lastSeriesController.abort(); } catch(e){/*ignore*/ }
      }
      __lastSeriesController = new AbortController();
      const signal = __lastSeriesController.signal;
    
      console.debug('[Playground] Requesting series for ids:', signalIds);
      try {
        const res = await safeFetch('/analytics', {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({ fn:'series', ids:signalIds, tmin, tmax, downsample:maxPoints }),
          signal
        });
        
        if (res.aborted) {
          console.debug('[Playground] Request aborted');
          return {}; // Safely handle aborted request
        }
        
        // Enhanced error checking
        if (!res) {
          console.error('[Playground] No response received from /analytics');
          return {};
        }
        
        // Check backend ok field
        if (res.ok === false) {
          console.error('[Playground] Backend returned ok:false', res);
          return {};
        }
        
        if (res.error) {
          console.error('[Playground] Server error:', res.error, res);
          return {};
        }
        
        if (!res.series) {
          console.warn('[Playground] Response missing "series" key. Full response:', res);
          console.warn('[Playground] Response keys:', Object.keys(res));
          return {};
        }
        
        const seriesData = res.series || {};
        const allKeys = Object.keys(seriesData);
        
        // Log file usage info from meta if available
        const fileInfo = res.meta || {};
        console.debug('[Playground] Series response received:', {
          keys: allKeys.slice(0, 30),
          allKeys: allKeys,
          count: allKeys.length,
          requested: signalIds.length,
          requestedIds: signalIds,
          unresolved: res.unresolved || [],
          meta: {
            requested: fileInfo.requested,
            resolved: fileInfo.resolved,
            unresolvedCount: fileInfo.unresolved,
            debug: fileInfo.debug
          }
        });
        
        // Log file count if available in response
        if (res.active_files || (fileInfo.debug && fileInfo.debug.files_used)) {
          const filesUsed = res.active_files || fileInfo.debug?.files_used || [];
          console.info('[Playground] Files being used:', {
            count: Array.isArray(filesUsed) ? filesUsed.length : 'unknown',
            files: Array.isArray(filesUsed) ? filesUsed.map(f => {
              const path = String(f);
              return path.split(/[\\/]/).pop(); // Just filename
            }) : []
          });
        }
        
        // Log any unresolved signals and suggest matches, then try to auto-match
        if (res.unresolved && res.unresolved.length > 0) {
          console.warn('[Playground] Unresolved signals:', res.unresolved);
          res.unresolved.forEach(unresolvedId => {
            const suggestions = allKeys.filter(k => {
              const parts = unresolvedId.toLowerCase().split(/[_\.\-]/).filter(p => p.length > 3);
              const kLower = k.toLowerCase();
              // Try multiple matching strategies - match key parts, endings, or contains
              return parts.some(p => kLower.includes(p) || p.includes(kLower)) || 
                     kLower.includes(unresolvedId.toLowerCase().slice(-15)) ||
                     kLower.endsWith(unresolvedId.toLowerCase().split(/[_\.\-]/).pop()) ||
                     unresolvedId.toLowerCase().slice(-10) === kLower.slice(-10);
            }).slice(0, 5);
            if (suggestions.length > 0) {
              console.warn(`[Playground] Suggestions for "${unresolvedId}":`, suggestions);
              // Auto-use the first suggestion if it's a strong match
              const bestMatch = suggestions[0];
              if (bestMatch && seriesData[bestMatch] && !seriesData[unresolvedId]) {
                console.info(`[Playground] Auto-matching "${unresolvedId}" -> "${bestMatch}"`);
                seriesData[unresolvedId] = seriesData[bestMatch];
              }
            }
          });
        }
        
        // Enhanced matching: try to find signals using partial/fuzzy matching for ALL missing signals
        signalIds.forEach(id => {
          if (!seriesData[id] && !generateAliases(id).some(alias => seriesData[alias])) {
            // Try finding by key parts with multiple strategies
            const idLower = id.toLowerCase();
            const idParts = idLower.split(/[_\.\-]/).filter(p => p.length > 3);
            const matches = allKeys.filter(k => {
              const kLower = k.toLowerCase();
              // Strategy 1: Match by key parts
              if (idParts.some(part => kLower.includes(part) || part.includes(kLower))) return true;
              // Strategy 2: Match by ending (last N chars)
              if (kLower.includes(idLower.slice(-15)) || idLower.slice(-10) === kLower.slice(-10)) return true;
              // Strategy 3: Match last segment after delimiter
              const idLast = idLower.split(/[_\.\-]/).pop();
              const kLast = kLower.split(/[_\.\-:]/).pop();
              if (idLast && kLast && (idLast.includes(kLast) || kLast.includes(idLast))) return true;
              // Strategy 4: Extract meaningful parts (e.g., "C2000" from "96D7124080_8128328U_FM77_nc_C2000_raw")
              const meaningfulParts = idLower.match(/[a-z]{2,}[0-9]+|[0-9]+[a-z]{2,}/gi) || [];
              if (meaningfulParts.some(mp => kLower.includes(mp) && mp.length > 4)) return true;
              return false;
            }).sort((a, b) => {
              // Prefer shorter matches (more specific)
              if (a.length !== b.length) return a.length - b.length;
              // Prefer exact segment matches
              const aLast = a.toLowerCase().split(/[_\.\-:]/).pop();
              const bLast = b.toLowerCase().split(/[_\.\-:]/).pop();
              const idLast = idLower.split(/[_\.\-]/).pop();
              const aMatch = aLast && idLast && (aLast === idLast || aLast.includes(idLast) || idLast.includes(aLast));
              const bMatch = bLast && idLast && (bLast === idLast || bLast.includes(idLast) || idLast.includes(bLast));
              if (aMatch && !bMatch) return -1;
              if (!aMatch && bMatch) return 1;
              return 0;
            });
            
            if (matches.length > 0) {
              const bestMatch = matches[0];
              console.info(`[Playground] Auto-matching "${id}" -> "${bestMatch}" (fuzzy match)`);
              seriesData[id] = seriesData[bestMatch];
            }
          }
        });
        
        // Check if any requested signals are still missing after auto-matching
        const missing = signalIds.filter(id => !seriesData[id] && !generateAliases(id).some(alias => seriesData[alias]));
        if (missing.length > 0) {
          console.warn('[Playground] Some requested signals not found even with aliases and auto-matching:', missing);
        }
        
        return seriesData;
      } catch (err) {
        if (err.name === 'AbortError') {
          console.debug('[Playground] fetchSeriesForSignals aborted');
          return {}; // safely treat aborted as empty result
        }
        console.error('[Playground] fetchSeriesForSignals error:', err);
        // Don't throw - return empty object to prevent UI crash
        return {};
      } finally {
        if (__lastSeriesController && __lastSeriesController.signal === signal) __lastSeriesController = null;
      }
  }

  function ensureTheme(){
     const themeEl = el('pg-theme');
     if (!themeEl) return;
     const theme = themeEl.value;
     const isLight = document.body.classList.contains('light-theme');
     
     if(theme === 'uniplot'){
       window.plotState.layout.template = 'uniplot';
       window.plotState.layout.paper_bgcolor = isLight ? 'white' : 'black';
       window.plotState.layout.plot_bgcolor = isLight ? 'white' : 'black';
       window.plotState.layout.font = { color: isLight ? '#0b1220' : '#dce1e6' };
       window.plotState.layout.xaxis = { ...(window.plotState.layout.xaxis || {}), gridcolor: isLight ? '#e5e7eb' : '#2d353a' };
       window.plotState.layout.yaxis = { ...(window.plotState.layout.yaxis || {}), gridcolor: isLight ? '#e5e7eb' : '#2d353a' };
     } else if(theme === 'dark'){
       window.plotState.layout.template = null;
       window.plotState.layout.paper_bgcolor = 'black';  // Always dark for dark theme option
       window.plotState.layout.plot_bgcolor = 'black';  // Always dark for dark theme option
       window.plotState.layout.font = { color: '#dce1e6' };
       window.plotState.layout.xaxis = { ...(window.plotState.layout.xaxis || {}), gridcolor: '#2d353a' };
       window.plotState.layout.yaxis = { ...(window.plotState.layout.yaxis || {}), gridcolor: '#2d353a' };
     } else {
       // Portal theme - respect global theme (white in light mode, dark in dark mode)
       window.plotState.layout.template = null;
       window.plotState.layout.paper_bgcolor = isLight ? '#ffffff' : 'black';
       window.plotState.layout.plot_bgcolor = isLight ? '#ffffff' : 'black';
       window.plotState.layout.font = { color: isLight ? '#2d3748' : '#dce1e6' };
       window.plotState.layout.xaxis = { ...(window.plotState.layout.xaxis || {}), gridcolor: isLight ? '#e2e8f0' : '#2d353a' };
       window.plotState.layout.yaxis = { ...(window.plotState.layout.yaxis || {}), gridcolor: isLight ? '#e2e8f0' : '#2d353a' };
     }
  }

  function applyLegend(){
    const legendEl = el('pg-legend');
    if (!legendEl) return;
    const v = legendEl.value;
    if(v==='h'){ window.plotState.layout.legend = { orientation:'h', x:0, y:1.02, xanchor:'left', yanchor:'bottom' }; }
    else if(v==='v'){ window.plotState.layout.legend = { orientation:'v', x:1.02, y:1, xanchor:'left', yanchor:'top' }; }
    else { window.plotState.layout.showlegend = false; }
  }

  function currentSelection(){
    const t = id => el(id)?.value || '';
    const numOr = v => (v===''||v===null||isNaN(Number(v))) ? null : Number(v);
    return {
      type:  t('pg-plot-type'),
      x:     t('pg-x'),
      y:     [t('pg-y')].filter(Boolean),
      z:     t('pg-z') || null,
      color: t('pg-color') || null,
      size:  t('pg-size')  || null,
      group: t('pg-group') || null,
      tmin:  el('pg-tmin')?.value || null,
      tmax:  el('pg-tmax')?.value || null,
      bins:  numOr(el('pg-bins')?.value),
      maxPoints: Number(el('pg-downsample')?.value || 20000),
      title: el('pg-title')?.value || '',
      xmin: numOr(el('pg-xmin')?.value),
      xmax: numOr(el('pg-xmax')?.value),
      xdt:  numOr(el('pg-xdt')?.value),
      ymin: numOr(el('pg-ymin')?.value),
      ymax: numOr(el('pg-ymax')?.value),
      ydt:  numOr(el('pg-ydt')?.value),
      square: el('pg-square')?.checked || false,
      print:  el('pg-print')?.checked || false,
      stacked: Math.max(1, Number(el('pg-stacked')?.value || 1)),
      colorscale: t('pg-colorscale') || 'Viridis',
      histnorm: t('pg-histnorm') || 'count',
      lineWidth: numOr(el('pg-line-width')?.value) || 2,
      markerSize: numOr(el('pg-marker-size')?.value) || 6,
      opacity: numOr(el('pg-opacity')?.value) || 1
    };
  }

  // Safe version of reshapeToSurface
  function reshapeToSurfaceSafe(arr){
    // coerce to numbers or nulls
    const nums = (arr || []).map(v => {
      if (v === null || v === undefined || v === '') return null;
      const s = (typeof v === 'string') ? v.replace(/[, ]+/g,'').replace(/[^0-9eE.\-+]/g,'') : String(v);
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    });

    const N = nums.length;
    if (N === 0) return [[null]];

    // Choose rows/cols to make roughly square rectangular grid
    let rows = Math.floor(Math.sqrt(N));
    if (rows === 0) rows = 1; // Avoid division by zero
    let cols = Math.ceil(N / rows);

    const out = [];
    for (let r = 0; r < rows; r++){
      const row = [];
      for (let c = 0; c < cols; c++){
        const idx = r*cols + c;
        let v = (idx < N) ? nums[idx] : null;
        row.push(v);
      }
      out.push(row);
    }

    // Ensure rectangular: pad shorter rows with nulls
    const maxCols = Math.max(...out.map(r => r.length));
    out.forEach(r => { while (r.length < maxCols) r.push(null); });

    return out;
  }
  
  // Robust version of buildTraces
  function buildTraces(sel, S){
    const traces = [];

    // Generate all possible alias keys for a signal name (matching backend _aliases_for_channel exactly)
    const generateAliases = (name) => {
      const aliases = new Set();
      if (!name) return aliases;
      
      const str = String(name);
      
      // Helper to clean name (replace non-alnum with underscore)
      const cleanName = (n) => n.replace(/[^a-zA-Z0-9_]/g, '_');
      
      // Helper to normalize text (trim, collapse whitespace)
      const normalizeText = (n) => {
        let t = String(n).trim();
        t = t.replace(/\s+/g, ' ');
        return t;
      };
      
      // Original
      aliases.add(str);
      
      // Clean name
      const clean = cleanName(str);
      aliases.add(clean);
      
      // Lowercase variants
      aliases.add(str.toLowerCase());
      aliases.add(clean.toLowerCase());
      
      // Normalized text variants
      const nname = normalizeText(str);
      aliases.add(nname);
      aliases.add(nname.toLowerCase());
      const nclean = normalizeText(clean);
      aliases.add(nclean);
      aliases.add(nclean.toLowerCase());
      
      // Underscore/dot/space variants
      aliases.add(str.replace(/_/g, '.'));
      aliases.add(str.replace(/\./g, '_'));
      aliases.add(str.replace(/\./g, ' '));
      aliases.add(str.replace(/\s/g, '.'));
      aliases.add(str.replace(/\s/g, '_'));
      
      // Clean variants with replacements
      aliases.add(clean.replace(/_/g, '.'));
      aliases.add(clean.replace(/\./g, '_'));
      
      // Compact forms (last token after delimiter)
      const delimiters = ['.', '/', '#'];
      delimiters.forEach(d => {
        if (str.includes(d)) {
          const compact = str.split(d).pop();
          if (compact) {
            aliases.add(compact);
            aliases.add(normalizeText(compact));
            aliases.add(cleanName(compact));
            aliases.add(compact.toLowerCase());
            aliases.add(cleanName(compact).toLowerCase());
          }
        }
      });
      
      // Array index support: "SignalName[0]" -> "SignalName"
      if (str.includes('[') && str.includes(']')) {
        const base = str.split('[')[0];
        const baseNorm = normalizeText(base);
        aliases.add(base);
        aliases.add(baseNorm);
        aliases.add(cleanName(base));
        aliases.add(base.toLowerCase());
        aliases.add(baseNorm.toLowerCase());
        aliases.add(cleanName(base).toLowerCase());
      }
      
      // Strip quotes/punctuation
      aliases.add(str.trim().replace(/^['"]+|['"]+$/g, ''));
      
      return Array.from(aliases).filter(a => a && a.length > 0);
    };

    // tolerant arr() that supports S as object or array and dot/underscore variants
    const arr = id => {
      if (!id || !S) {
        console.debug('[Playground] arr() called with invalid id or S:', { id, hasS: !!S });
        return { x: [], y: [], timestamps: [], values: [], name: id };
      }

      // If S is an object keyed by id
      if (!Array.isArray(S)) {
        // Try exact match first
        let found = S[id];
        
        // If not found, try all aliases
        if (!found) {
          const aliases = generateAliases(id);
          for (const alias of aliases) {
            found = S[alias];
            if (found) {
              console.debug('[Playground] Found signal using alias:', alias, 'for original:', id);
              break;
            }
          }
        }
        
        // If still not found, try normalized match (strip non-alnum)
        if (!found) {
        const norm = s => String(s).replace(/[^0-9a-z]/gi, '').toLowerCase();
        const target = norm(id);
        for (const k of Object.keys(S || {})) {
            if (norm(k) === target) {
              found = S[k];
              console.debug('[Playground] Found signal using normalized match:', k, 'for original:', id);
              break;
            }
          }
        }
        
        if (found) {
          // Normalize to x/y format (backend may return x/y or timestamps/values)
          const normalized = {
            x: found.timestamps || found.x || [],
            y: found.values || found.y || [],
            timestamps: found.timestamps || found.x || [],
            values: found.values || found.y || [],
            name: found.name || id,
            unit: found.unit || ''
          };
          
          // Debug logging for missing data
          if ((!normalized.x || normalized.x.length === 0) && (!normalized.y || normalized.y.length === 0)) {
            console.warn('[Playground] arr() found series but it has no data:', { 
              id, 
              foundKey: Object.keys(S).find(k => S[k] === found),
              found: found, 
              normalized: normalized 
            });
          } else {
            console.debug('[Playground] arr() successfully found data for', id, {
              xLen: normalized.x.length,
              yLen: normalized.y.length,
              sampleX: normalized.x.slice(0, 3),
              sampleY: normalized.y.slice(0, 3)
            });
          }
          
          return normalized;
        }
        
        // Log ALL available keys when signal not found, then try fuzzy matching
        const allKeys = Object.keys(S || {});
        const idLower = id.toLowerCase();
        const idParts = idLower.split(/[_\.\-]/).filter(p => p.length > 3);
        const partialMatches = allKeys.filter(k => {
          const kLower = k.toLowerCase();
          // Multiple matching strategies
          if (idParts.some(p => kLower.includes(p) || p.includes(kLower))) return true;
          if (kLower.includes(idLower.slice(-20)) || idLower.slice(-10) === kLower.slice(-10)) return true;
          // Match last segment after delimiter (e.g., "C2000" from "96D7124080_8128328U_FM77_nc_C2000_raw")
          const idLast = idLower.split(/[_\.\-]/).pop();
          const kLast = kLower.split(/[_\.\-:]/).pop();
          if (idLast && kLast && (idLast.includes(kLast) || kLast.includes(idLast))) return true;
          // Extract meaningful parts (e.g., "C2000" or numbers+letters combinations)
          const meaningfulParts = idLower.match(/[a-z]{2,}[0-9]+|[0-9]+[a-z]{2,}/gi) || [];
          if (meaningfulParts.some(mp => kLower.includes(mp) && mp.length > 4)) return true;
          return false;
        }).sort((a, b) => {
          // Prefer shorter, more specific matches
          if (a.length !== b.length) return a.length - b.length;
          return 0;
        });
        
        // Try to auto-use the best match if we found one
        if (partialMatches.length > 0) {
          const bestMatch = partialMatches[0];
          found = S[bestMatch];
          if (found) {
            console.info(`[Playground] arr() auto-matched "${id}" -> "${bestMatch}" (fuzzy match)`);
            const normalized = {
              x: found.timestamps || found.x || [],
              y: found.values || found.y || [],
              timestamps: found.timestamps || found.x || [],
              values: found.values || found.y || [],
              name: found.name || id,
              unit: found.unit || ''
            };
            return normalized;
          }
        }
        
        console.warn('[Playground] arr() signal NOT FOUND:', { 
          id: id, 
          totalKeys: allKeys.length,
          sampleKeys: allKeys.slice(0, 50),
          // Check if any key contains parts of the requested id
          partialMatches: partialMatches.slice(0, 20),
          suggestedKeys: partialMatches.length > 0 ? partialMatches : 
                        allKeys.filter(k => {
                          // Find keys with similar ending
                          const idEnd = id.toLowerCase().slice(-15);
                          return k.toLowerCase().endsWith(idEnd) || idEnd.endsWith(k.toLowerCase().slice(-15));
                        }).slice(0, 10),
          aliasesTried: generateAliases(id).slice(0, 20)
        });
        
        return { x: [], y: [], timestamps: [], values: [], name: id };
      }

      // If S is an array of series objects
      const norm = s => String(s).replace(/[^0-9a-z]/gi, '').toLowerCase();
      const target = norm(id);
      const fields = ['id','name','key','label'];
      
      // Helper to normalize array item format
      const normalizeItem = (item) => ({
        x: item.timestamps || item.x || [],
        y: item.values || item.y || [],
        timestamps: item.timestamps || item.x || [],
        values: item.values || item.y || [],
        name: item.name || id,
        unit: item.unit || ''
      });
      
      // direct exact match
      for (const item of S) {
        for (const f of fields) {
          if (item && item[f] && String(item[f]) === id) {
            return normalizeItem(item);
          }
        }
      }
      // normalized match
      for (const item of S) {
        for (const f of fields) {
          if (item && item[f] && norm(item[f]) === target) {
            return normalizeItem(item);
          }
        }
      }
      // fallback: first valid series with x/y or timestamps/values arrays
      const found = S.find(it => it && (
        (Array.isArray(it.x) && it.x.length) || 
        (Array.isArray(it.timestamps) && it.timestamps.length) ||
        (Array.isArray(it.y) && it.y.length) ||
        (Array.isArray(it.values) && it.values.length)
      ));
      if (found) {
        return normalizeItem(found);
      }
      return { x: [], y: [], timestamps: [], values: [], name: id };
    };

    // helpers
    const toNumberOrNull = v => {
      if (v === null || v === undefined || v === '') return null;
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    // Enhanced marker encoding that aligns with filtered data
    const markerEnc = (acol, asize, filterIndices = null, colorscale = 'Viridis') => {
      const m = {};
      
      // Helper to extract aligned array (respects filter indices if provided)
      const getAlignedArray = (sourceArr, length, indices) => {
        if (!sourceArr || !Array.isArray(sourceArr) || sourceArr.length === 0) return null;
        if (indices && Array.isArray(indices) && indices.length > 0) {
          // Use filter indices to align arrays
          return indices.map(idx => {
            if (idx >= 0 && idx < sourceArr.length) {
              return sourceArr[idx];
            }
            return null;
          });
        }
        // If no indices provided, use the array as-is (but limit to length)
        if (length && sourceArr.length >= length) return sourceArr.slice(0, length);
        // Pad if shorter (or return as-is if length not provided)
        if (length && length > 0) {
          return [...sourceArr, ...Array(length - sourceArr.length).fill(null)];
        }
        return sourceArr;
      };
      
      if (acol && Array.isArray(acol.y) && acol.y.length) {
        // Determine target length for alignment
        const targetLength = filterIndices ? filterIndices.length : acol.y.length;
        
        // Get aligned color array
        const colorArr = getAlignedArray(acol.y, targetLength, filterIndices);
        if (!colorArr || colorArr.length === 0) {
          m.color = 'rgba(31, 119, 180, 0.8)';
        } else {
        // Check if values are categorical (strings or integers with limited unique values)
          const uniqueValues = [...new Set(colorArr)].filter(v => v !== null && v !== undefined && v !== '');
          const isCategorical = uniqueValues.length > 0 && uniqueValues.length <= 20 && uniqueValues.every(v => 
          typeof v === 'string' || (typeof v === 'number' && Number.isInteger(v))
        );
        
          if (isCategorical && uniqueValues.length > 1) {
            // Use discrete colors for categorical data - MULTIPLE COLORS
          const colorPalette = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
            '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
              '#c49c94', '#f7b6d3', '#c7c7c7', '#dbdb8d', '#9edae5',
              '#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939',
              '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39'
          ];
          
          const valueToColor = {};
          uniqueValues.forEach((val, idx) => {
            valueToColor[val] = colorPalette[idx % colorPalette.length];
          });
          
            // Return array of colors for each data point - MULTIPLE COLORS
            m.color = colorArr.map(v => {
              if (v === null || v === undefined || v === '') return '#cccccc';
              return valueToColor[v] || '#cccccc';
            });
          m.showscale = false;
            console.debug('[Playground] Color encoding: categorical with', uniqueValues.length, 'unique values,', m.color.length, 'colors assigned');
        } else {
          // Use continuous color scale for numerical data
            const numericColors = colorArr.map(v => {
              if (v === null || v === undefined || v === '') return null;
            const n = Number(v);
            return Number.isFinite(n) ? n : null;
          });
            
            // Only use color scale if we have valid numeric values
            const validNumeric = numericColors.filter(v => v !== null);
            if (validNumeric.length > 0) {
              m.color = numericColors;
          m.showscale = true;
              m.colorscale = colorscale || 'Viridis';
          m.colorbar = {
            title: acol.name || 'Color Scale',
            titleside: 'right'
          };
              console.debug('[Playground] Color encoding: continuous numeric scale with', validNumeric.length, 'valid values, range:', Math.min(...validNumeric).toFixed(2), 'to', Math.max(...validNumeric).toFixed(2));
            } else {
              m.color = 'rgba(31, 119, 180, 0.8)';
            }
          }
        }
      } else {
        // Default color when no color encoding
        m.color = 'rgba(31, 119, 180, 0.8)';
      }
      
      if (asize && Array.isArray(asize.y) && asize.y.length) {
        const targetLength = filterIndices ? filterIndices.length : undefined;
        const sizeArr = getAlignedArray(asize.y, targetLength, filterIndices);
        if (sizeArr && sizeArr.length > 0) {
          const raw = sizeArr.map(v => {
            if (v === null || v === undefined || v === '') return null;
            return Number(v);
          });
        const nums = raw.filter(Number.isFinite);
          if (nums.length > 0) {
          const minv = Math.min(...nums), maxv = Math.max(...nums);
          const MIN_SIZE = 5, MAX_SIZE = 25;
          m.size = raw.map(v => {
            if (!Number.isFinite(v)) return MIN_SIZE;
            if (maxv === minv) return (MIN_SIZE + MAX_SIZE) / 2;
            return MIN_SIZE + (v - minv) / (maxv - minv) * (MAX_SIZE - MIN_SIZE);
          });
          m.sizemode = 'diameter';
          m.sizeref = 1;
          }
        }
      }
      return m;
    };

    const makeIndexX = len => Array.from({length: len}, (_,i)=>i);
    const filterFinitePaired = (xArr, yArr) => {
      const L = Math.min((xArr||[]).length, (yArr||[]).length);
      const xf = [], yf = [], indices = [];
      for (let i=0;i<L;i++){
        const xn = toNumberOrNull(xArr[i]);
        const yn = toNumberOrNull(yArr[i]);
        if (Number.isFinite(xn) && Number.isFinite(yn)) { 
          xf.push(xn); 
          yf.push(yn);
          indices.push(i); // Track original indices for alignment
      }
      }
      return { x: xf, y: yf, indices: indices };
    };

    // extract helper series for x, z, color, size
    const ax = arr(sel.x);
    const az = arr(sel.z);
    const acol = arr(sel.color);
    const asize = arr(sel.size);
    

    // prefer ax.x else ax.y (for time-based X axis)
    const rawX = (Array.isArray(ax.x) && ax.x.length) ? ax.x : ((Array.isArray(ax.y) && ax.y.length) ? ax.y : null);
    
    // Debug: Log X axis data
    console.debug('[Playground] X axis data (sel.x =', sel.x, '):', {
      hasAx: !!ax,
      axXLen: ax.x ? ax.x.length : 0,
      axYLen: ax.y ? ax.y.length : 0,
      axTimestampsLen: ax.timestamps ? ax.timestamps.length : 0,
      axValuesLen: ax.values ? ax.values.length : 0,
      rawXLen: rawX ? rawX.length : 0,
      rawXSample: rawX ? rawX.slice(0, 3) : null
    });

    // Handle grouped bar charts
    if (sel.type === 'bar' && sel.y && sel.y.length > 1) {
      const barTraces = [];
      const categoryNames = [];

      for (let i = 0; i < sel.y.length; i++) {
        const yid = sel.y[i];
        const ay = arr(yid);
        if (!ay || !Array.isArray(ay.y) || ay.y.length === 0) {
          console.debug('buildTraces: skipping', yid, '- no y data');
          continue;
        }

        let traceX = rawX;
        if (!traceX || traceX.length !== ay.y.length) {
          if (Array.isArray(ay.x) && ay.x.length === ay.y.length) traceX = ay.x;
          else traceX = makeIndexX(ay.y.length);
        }

        let finalX = traceX, finalY = ay.y;
        const filt = filterFinitePaired(finalX, finalY);
        finalX = filt.x; finalY = filt.y;

        if (!finalY.length) {
          console.debug('buildTraces: after filtering no valid points for', yid);
          continue;
        }

        const markerConfig = markerEnc(acol, asize, filt.indices, sel.colorscale);
        
        // Build marker for grouped bars - handle color arrays properly
        const barMarker = {
          line: { color: 'rgba(31, 119, 180, 1.0)', width: 1 }
        };
        
        if (markerConfig.color !== undefined) {
          if (Array.isArray(markerConfig.color) && markerConfig.color.length > 0) {
            // For grouped bars, use array of colors
            barMarker.color = markerConfig.color;
          } else {
            barMarker.color = markerConfig.color;
          }
        } else {
          barMarker.color = 'rgba(31, 119, 180, 0.8)';
        }
        
        const trace = {
          name: ay.name || yid,
          x: finalX,
          y: finalY,
          type: 'bar',
          offsetgroup: i.toString(),
          marker: barMarker,
          opacity: sel.opacity || 1
        };

        barTraces.push(trace);
        categoryNames.push(ay.name || yid);
      }

      // For grouped bar charts, return the traces (layout will be modified in renderPlot)
      return barTraces;
    }

    for (const yid of (sel.y || [])){
      const ay = arr(yid);
      
      // Enhanced debugging for Y signal
      console.debug('[Playground] Processing Y signal:', yid, {
        hasAy: !!ay,
        ayXLen: ay.x ? ay.x.length : 0,
        ayYLen: ay.y ? ay.y.length : 0,
        ayTimestampsLen: ay.timestamps ? ay.timestamps.length : 0,
        ayValuesLen: ay.values ? ay.values.length : 0,
        ayName: ay.name,
        isValid: Array.isArray(ay.y) && ay.y.length > 0
      });
      
      if (!ay || !Array.isArray(ay.y) || ay.y.length === 0) {
        console.warn('[Playground] buildTraces: skipping', yid, '- no y data', {
          ay: ay,
          hasY: Array.isArray(ay.y),
          yLen: ay.y ? ay.y.length : 0
        });
        continue;
      }

      // choose x for this trace (try rawX, then ay.x, else index)
      let traceX = rawX;
      
      // Debug: Log data availability
      console.debug('[Playground] Building trace for', yid, {
        hasRawX: !!rawX,
        rawXLen: rawX ? rawX.length : 0,
        ayXLen: ay.x ? ay.x.length : 0,
        ayYLen: ay.y ? ay.y.length : 0,
        lengthsMatch: rawX && ay.y && rawX.length === ay.y.length
      });
      
      if (!traceX || traceX.length !== ay.y.length) {
        if (Array.isArray(ay.x) && ay.x.length === ay.y.length) {
          traceX = ay.x;
          console.debug('[Playground] Using ay.x for trace X');
        } else {
          traceX = makeIndexX(ay.y.length);
          console.debug('[Playground] Using generated index X, length:', traceX.length);
        }
      }

      let finalX = traceX, finalY = ay.y;
      let filterIndices = null;
      const numericPlotTypes = ['scatter','scattergl','histogram2d','density-heatmap','histogram','heatmap','surface','scatter3d','box','violin','candlestick','bar'];
      if (!sel.type || numericPlotTypes.includes(sel.type)) {
        const filt = filterFinitePaired(finalX, finalY);
        finalX = filt.x; finalY = filt.y;
        filterIndices = filt.indices;
        console.debug('[Playground] After filtering:', {
          originalXLen: traceX.length,
          originalYLen: ay.y.length,
          filteredXLen: finalX.length,
          filteredYLen: finalY.length,
          filterIndicesLen: filterIndices ? filterIndices.length : 0
        });
        if (!finalY.length) {
          console.warn('[Playground] buildTraces: after filtering no valid points for', yid, {
            originalYLen: ay.y.length,
            sampleY: ay.y.slice(0, 5)
          });
          continue;
        }
      }

      // Clean signal name for display
      const rawTraceName = ay.name || yid;
      const trace = { name: extractDisplayName(rawTraceName), x: finalX, y: finalY };

      // type branches
      if (sel.type === 'scatter') {
        trace.type = (trace.x.length > 15000) ? 'scattergl' : 'scatter';
        trace.mode = 'markers';
        const markerConfig = markerEnc(acol, asize, filterIndices, sel.colorscale);
        
        // If size encoding is provided, use it; otherwise use default size
        const markerSize = (markerConfig.size && Array.isArray(markerConfig.size)) ? markerConfig.size : 
                          (trace.x.length > 1000 ? 3 : (sel.markerSize || 6));
        
        // Build marker object - color can be array or single value
        trace.marker = {
          size: markerSize,
          opacity: sel.opacity || 1,
          line: { width: 0.5, color: 'rgba(255, 255, 255, 0.8)' }
        };
        
        // Handle color encoding (can be array for per-point colors or single color)
        if (markerConfig.color !== undefined) {
          if (Array.isArray(markerConfig.color) && markerConfig.color.length > 0) {
            // Array of colors - per-point coloring
            trace.marker.color = markerConfig.color;
            if (markerConfig.showscale !== undefined) {
              trace.marker.showscale = markerConfig.showscale;
            }
            if (markerConfig.colorscale) {
              trace.marker.colorscale = markerConfig.colorscale;
            }
            if (markerConfig.colorbar) {
              trace.marker.colorbar = markerConfig.colorbar;
            }
          } else {
            // Single color value
            trace.marker.color = markerConfig.color;
          }
        }
        
        trace.line = { width: 0 };
      } else if (sel.type === 'bar') {
        trace.type = 'bar';
        const markerConfig = markerEnc(acol, asize, filterIndices, sel.colorscale);
        // For bar charts, color should be a single color or array of colors
        const barColor = (markerConfig.color && Array.isArray(markerConfig.color)) ? markerConfig.color : markerConfig.color || 'rgba(31, 119, 180, 0.8)';
        trace.marker = {
          color: barColor,
          line: { color: 'rgba(31, 119, 180, 1.0)', width: 1 },
          opacity: sel.opacity || 1
        };
        
        // Add colorbar for continuous color scales in bar charts
        if (markerConfig.showscale && markerConfig.colorbar && Array.isArray(markerConfig.color)) {
          trace.marker.showscale = true;
          trace.marker.colorbar = {
            ...markerConfig.colorbar,
            thickness: 15,
            len: 0.6,
            x: 1.02,
            y: 0.5
          };
          trace.marker.colorscale = markerConfig.colorscale || 'Viridis';
        }
        
        // Log color encoding info for debugging
        if (acol) {
          console.debug('[Playground] Bar chart color encoding:', {
            hasColor: !!markerConfig.color,
            isArray: Array.isArray(markerConfig.color),
            length: Array.isArray(markerConfig.color) ? markerConfig.color.length : 0,
            showscale: markerConfig.showscale,
            colorscale: markerConfig.colorscale,
            colorType: Array.isArray(markerConfig.color) ? 'array (per-bar colors)' : typeof markerConfig.color
          });
        }
        trace.opacity = sel.opacity || 1;
        // Single bar chart - grouped charts are handled separately above
      } else if (sel.type === 'histogram') {
        trace.type = 'histogram';
        trace.x = finalY; delete trace.y;
        trace.nbinsx = sel.bins || Math.min(50, Math.floor(Math.sqrt(finalY.length)));
        
        // Apply color encoding to histogram if available
        const markerConfig = markerEnc(acol, null, filterIndices, sel.colorscale);
        
        // For histogram, use color encoding but typically single color per bin
        // If categorical, use first color of array; if continuous, use colorbar
        let histColor = markerConfig.color || 'rgba(31, 119, 180, 0.8)';
        if (Array.isArray(markerConfig.color) && markerConfig.color.length > 0) {
          // For histograms, use the first color if categorical
          histColor = markerConfig.color[0];
        }
        
        trace.marker = { 
          color: histColor,
          line: { color: 'rgba(255, 255, 255, 0.8)', width: 1 }
        };
        
        // For continuous color scale with histogram, use fillcolor array
        if (markerConfig.showscale && Array.isArray(markerConfig.color)) {
          // Note: Plotly histogram doesn't support per-bin colors directly
          // But we can use fillcolor for gradient effect
          trace.fillcolor = histColor;
          trace.opacity = sel.opacity || 0.8;
        } else {
          trace.opacity = sel.opacity || 0.8;
        }
        
        trace.histnorm = sel.histnorm;
        trace.autobinx = false;
      } else if (sel.type === 'box') {
        trace.type = 'box';
        trace.y = finalY; delete trace.x;
        trace.boxpoints = 'outliers';
        trace.jitter = 0.3;
        trace.pointpos = -1.8;
        
        // Apply color encoding for box plots
        const markerConfig = markerEnc(acol, null, filterIndices, sel.colorscale);
        const boxColor = (markerConfig.color && Array.isArray(markerConfig.color)) ? markerConfig.color[0] : markerConfig.color || 'rgba(31, 119, 180, 0.6)';
        
        trace.marker = { 
          color: boxColor,
          size: 4,
          line: { color: 'rgba(255, 255, 255, 0.8)', width: 1 },
          opacity: sel.opacity || 0.8
        };
        trace.line = { color: boxColor, width: 2 };
        trace.fillcolor = Array.isArray(markerConfig.color) ? markerConfig.color[0] : boxColor;
      } else if (sel.type === 'violin') {
        trace.type = 'violin';
        trace.y = finalY; delete trace.x;
        trace.points = 'outliers';
        trace.box = { visible: true };
        trace.meanline = { visible: true };
        
        // Apply color encoding for violin plots
        const markerConfig = markerEnc(acol, null, filterIndices, sel.colorscale);
        const violinColor = (markerConfig.color && Array.isArray(markerConfig.color)) ? markerConfig.color[0] : markerConfig.color || 'rgba(31, 119, 180, 0.3)';
        
        trace.fillcolor = violinColor;
        trace.line = { color: violinColor, width: 2 };
        trace.marker = {
          color: violinColor,
          opacity: sel.opacity || 0.7
        };
      } else if (sel.type === 'density-heatmap') {
        trace.type = 'histogram2d';
        trace.x = finalX; 
        trace.y = finalY;
        trace.colorscale = sel.colorscale;
        trace.histnorm = sel.histnorm;
        trace.nbinsx = Math.min(50, Math.floor(Math.sqrt(finalX.length)));
        trace.nbinsy = Math.min(50, Math.floor(Math.sqrt(finalY.length)));
        trace.autobinx = false;
        trace.autobiny = false;
        trace.showscale = true;
        trace.colorbar = {
          title: 'Density',
          titleside: 'right'
        };
      } else if (sel.type === 'heatmap') {
        trace.type = 'heatmap';
        // For heatmap, we need to create a 2D grid from the data
        // This is a simplified implementation - in practice you'd want proper binning
        const xBins = Math.min(50, Math.floor(Math.sqrt(finalX.length)));
        const yBins = Math.min(50, Math.floor(Math.sqrt(finalY.length)));
        
        // Create a simple grid-based heatmap
        const grid = Array(yBins).fill().map(() => Array(xBins).fill(0));
        const xMin = Math.min(...finalX), xMax = Math.max(...finalX);
        const yMin = Math.min(...finalY), yMax = Math.max(...finalY);
        
        // Count points in each grid cell
        for (let i = 0; i < finalX.length; i++) {
          const xIdx = Math.floor(((finalX[i] - xMin) / (xMax - xMin)) * (xBins - 1));
          const yIdx = Math.floor(((finalY[i] - yMin) / (yMax - yMin)) * (yBins - 1));
          if (xIdx >= 0 && xIdx < xBins && yIdx >= 0 && yIdx < yBins) {
            grid[yIdx][xIdx]++;
          }
        }
        
        trace.x = Array.from({length: xBins}, (_, i) => xMin + (i / (xBins - 1)) * (xMax - xMin));
        trace.y = Array.from({length: yBins}, (_, i) => yMin + (i / (yBins - 1)) * (yMax - yMin));
        trace.z = grid;
        trace.colorscale = sel.colorscale;
        trace.showscale = true;
        trace.colorbar = {
          title: 'Count',
          titleside: 'right'
        };
      } else if (sel.type === 'contour') {
        trace.type = 'histogram2dcontour'; 
        trace.x = finalX; 
        trace.y = finalY; 
        trace.colorscale = sel.colorscale;
        trace.contours = { 
          showlabels: true,
          labelfont: { size: 12, color: 'white' }
        };
        trace.histnorm = sel.histnorm;
      } else if (sel.type === 'candlestick') {
        trace.type = 'candlestick';
        // For candlestick, we need OHLC data - this is a simplified implementation
        // In practice, you'd want proper OHLC data structure
        trace.x = finalX;
        trace.open = finalY.map(v => v * 0.95); // Simulated open prices
        trace.high = finalY.map(v => v * 1.05); // Simulated high prices  
        trace.low = finalY.map(v => v * 0.9);   // Simulated low prices
        trace.close = finalY; // Use actual values as close prices
        delete trace.y; // Remove y since we're using OHLC
      } else if (sel.type === 'scatter3d' || sel.type === 'surface') {
        const zRaw = (az && Array.isArray(az.y)) ? az.y : [];
        if (!zRaw || !zRaw.length) {
          console.debug('buildTraces: skipping 3D for', yid, '- no z data');
          continue;
        }
        if (sel.type === 'scatter3d') {
          // For 3D scatter, align X, Y, Z arrays properly - filter to finite values
          const validIndices = [];
          for (let i = 0; i < Math.min(finalX.length, finalY.length, zRaw.length); i++) {
            const xVal = Number(finalX[i]);
            const yVal = Number(finalY[i]);
            const zVal = Number(zRaw[i]);
            if (Number.isFinite(xVal) && Number.isFinite(yVal) && Number.isFinite(zVal)) {
              validIndices.push(i);
            }
          }
          
          if (validIndices.length === 0) {
            console.debug('buildTraces: skipping 3D scatter - no valid X/Y/Z triples');
            continue;
          }
          
          const L = validIndices.length;
          trace.x = validIndices.map(i => finalX[i]);
          trace.y = validIndices.map(i => finalY[i]);
          trace.z = validIndices.map(i => Number(zRaw[i]));
          trace.type = 'scatter3d';
          trace.mode = 'markers';
          
          // Enhanced 3D marker styling - professional appearance
          const alignedFilterIndices = filterIndices ? validIndices.map(i => filterIndices[i]).filter(i => i !== undefined) : validIndices;
          const markerConfig = markerEnc(acol, asize, alignedFilterIndices, sel.colorscale);
          
          trace.marker = {
            size: 4, // Default professional size
            line: {
              width: 0.5,
              color: 'rgba(255,255,255,0.1)'
            },
            opacity: 0.85,
            sizemin: 2,
            sizemax: 20
          };
          
          if (markerConfig.size && Array.isArray(markerConfig.size)) {
            trace.marker.size = markerConfig.size.slice(0, L);
          } else if (markerConfig.size) {
            trace.marker.size = markerConfig.size;
          }
          
          // Professional color encoding for 3D
          if (markerConfig.color !== undefined) {
            if (Array.isArray(markerConfig.color) && markerConfig.color.length > 0) {
              trace.marker.color = markerConfig.color.slice(0, L);
              if (markerConfig.showscale !== undefined) trace.marker.showscale = markerConfig.showscale;
              if (markerConfig.colorscale) trace.marker.colorscale = markerConfig.colorscale;
              if (markerConfig.colorbar) {
                trace.marker.colorbar = {
                  ...markerConfig.colorbar,
                  thickness: 15,
                  len: 0.5,
                  x: 1.02,
                  y: 0.5,
                  bgcolor: 'rgba(0,0,0,0)',
                  bordercolor: 'rgba(255,255,255,0.3)',
                  borderwidth: 1
                };
              }
            } else {
              trace.marker.color = markerConfig.color;
            }
          } else {
            // Professional default color for 3D
            trace.marker.color = 'rgba(31, 119, 180, 0.85)';
          }
          
          // Add hover template for professional tooltips
          trace.hovertemplate = '<b>%{fullData.name}</b><br>X: %{x:.3f}<br>Y: %{y:.3f}<br>Z: %{z:.3f}<extra></extra>';
          
          console.debug('[Playground] Built 3D scatter trace:', {
            points: L,
            hasColor: !!trace.marker.color,
            colorType: Array.isArray(trace.marker.color) ? `array[${trace.marker.color.length}]` : typeof trace.marker.color
          });
        } else { // surface
          // Professional surface plot generation - robust grid-based interpolation
          const validIndices = [];
          for (let i = 0; i < Math.min(finalX.length, finalY.length, zRaw.length); i++) {
            const xVal = Number(finalX[i]);
            const yVal = Number(finalY[i]);
            const zVal = Number(zRaw[i]);
            if (Number.isFinite(xVal) && Number.isFinite(yVal) && Number.isFinite(zVal)) {
              validIndices.push(i);
            }
          }
          
          if (validIndices.length < 4) {
            console.debug('buildTraces: skipping surface - insufficient valid points (need at least 4)');
            continue;
          }
          
          // Extract valid data
          const xVals = validIndices.map(i => Number(finalX[i]));
          const yVals = validIndices.map(i => Number(finalY[i]));
          const zVals = validIndices.map(i => Number(zRaw[i]));
          
          const xMin = Math.min(...xVals);
          const xMax = Math.max(...xVals);
          const yMin = Math.min(...yVals);
          const yMax = Math.max(...yVals);
          
          // Dynamic grid size based on data density (professional approach)
          const dataDensity = validIndices.length;
          const gridSize = Math.min(80, Math.max(20, Math.ceil(Math.sqrt(dataDensity * 2))));
          
          // Create uniform grid
          const xGrid = Array.from({length: gridSize}, (_, i) => {
            if (gridSize === 1) return xMin;
            return xMin + (i / (gridSize - 1)) * (xMax - xMin);
          });
          const yGrid = Array.from({length: gridSize}, (_, i) => {
            if (gridSize === 1) return yMin;
            return yMin + (i / (gridSize - 1)) * (yMax - yMin);
          });
          
          // Initialize grid with NaN (will be interpolated)
          const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(NaN));
          
          // Simple inverse distance weighting for interpolation (professional approach)
          const smoothingRadius = Math.max(
            (xMax - xMin) / gridSize * 1.5,
            (yMax - yMin) / gridSize * 1.5,
            0.0001
          );
          
          for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
              const x = xGrid[j];
              const y = yGrid[i];
              
              let sumWeight = 0;
              let sumWeightedZ = 0;
              let minDist = Infinity;
              
              // Find nearby points and interpolate
              for (let k = 0; k < xVals.length; k++) {
                const dx = xVals[k] - x;
                const dy = yVals[k] - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                minDist = Math.min(minDist, dist);
                
                if (dist < smoothingRadius * 3) {
                  // Inverse distance weighting
                  const weight = 1.0 / (dist * dist + smoothingRadius * smoothingRadius);
                  sumWeight += weight;
                  sumWeightedZ += weight * zVals[k];
                }
              }
              
              if (sumWeight > 0) {
                grid[i][j] = sumWeightedZ / sumWeight;
              } else if (minDist < (xMax - xMin) + (yMax - yMin)) {
                // Fallback: use nearest neighbor if within reasonable distance
                let nearestIdx = 0;
                let nearestDist = Infinity;
                for (let k = 0; k < xVals.length; k++) {
                  const dx = xVals[k] - x;
                  const dy = yVals[k] - y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestIdx = k;
                  }
                }
                grid[i][j] = zVals[nearestIdx];
              }
            }
          }
          
          // Fill any remaining NaN values with nearest neighbor
          for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
              if (!Number.isFinite(grid[i][j])) {
                // Find nearest valid point
                let nearestZ = zVals[0];
                let nearestDist = Infinity;
                const x = xGrid[j];
                const y = yGrid[i];
                for (let k = 0; k < xVals.length; k++) {
                  const dx = xVals[k] - x;
                  const dy = yVals[k] - y;
                  const dist = Math.sqrt(dx * dx + dy * dy);
                  if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestZ = zVals[k];
                  }
                }
                grid[i][j] = nearestZ;
              }
            }
          }
          
          trace.x = xGrid;
          trace.y = yGrid;
          trace.z = grid;
          trace.type = 'surface';
          trace.colorscale = sel.colorscale || 'Viridis';
          trace.showscale = true;
          trace.hoverinfo = 'x+y+z';
          trace.hovertemplate = '<b>%{fullData.name}</b><br>X: %{x:.3f}<br>Y: %{y:.3f}<br>Z: %{z:.3f}<extra></extra>';
          
          // Professional surface styling
          trace.contours = {
            x: { show: false, highlight: false },
            y: { show: false, highlight: false },
            z: { show: true, usecolormap: true, highlightcolor: 'rgba(255,255,255,0.5)', project: { z: false } }
          };
          
          trace.colorbar = {
            thickness: 20,
            len: 0.6,
            x: 1.02,
            y: 0.5,
            bgcolor: 'rgba(0,0,0,0)',
            bordercolor: 'rgba(255,255,255,0.3)',
            borderwidth: 1,
            title: {
              text: acol?.name || 'Z Value',
              font: { color: '#dce1e6', size: 12 }
            }
          };
          
          trace.lighting = {
            ambient: 0.7,
            diffuse: 0.6,
            fresnel: 0.1,
            specular: 0.2,
            roughness: 0.8
          };
          
          trace.lightposition = { x: 100, y: 100, z: 1000 };
          
          console.debug('[Playground] Built 3D surface trace:', {
            gridSize: gridSize,
            xRange: [xMin, xMax],
            yRange: [yMin, yMax],
            zRange: [Math.min(...zVals), Math.max(...zVals)],
            validPoints: validIndices.length
          });
        }
      } else {
        // Default fallback - ensure we always have a valid plot type
        trace.type = (trace.x.length > 15000) ? 'scattergl' : 'scatter';
        trace.mode = 'lines';
        const markerConfig = markerEnc(acol, asize, filterIndices, sel.colorscale);
        
        // Build marker and line objects properly
        trace.marker = {};
        if (markerConfig.size && Array.isArray(markerConfig.size)) {
          trace.marker.size = markerConfig.size;
        }
        
        if (markerConfig.color !== undefined) {
          if (Array.isArray(markerConfig.color) && markerConfig.color.length > 0) {
            trace.marker.color = markerConfig.color;
            if (markerConfig.showscale !== undefined) trace.marker.showscale = markerConfig.showscale;
            if (markerConfig.colorscale) trace.marker.colorscale = markerConfig.colorscale;
            if (markerConfig.colorbar) trace.marker.colorbar = markerConfig.colorbar;
          } else {
            trace.marker.color = markerConfig.color;
          }
        }
        
        trace.line = { 
          width: sel.lineWidth || 2,
          color: (markerConfig.color && !Array.isArray(markerConfig.color)) ? markerConfig.color : 'rgba(31, 119, 180, 0.8)'
        };
      }

      // final sanity: make sure trace has something to plot
      const hasXY = Array.isArray(trace.x) && Array.isArray(trace.y) && trace.x.length && trace.y.length;
      const hasZ = Array.isArray(trace.z) && (trace.z.length && (Array.isArray(trace.z[0]) ? trace.z[0].length : true));
      const hasXOnly = Array.isArray(trace.x) && trace.x.length && !trace.y; // For histogram, violin, box plots
      const hasYOnly = Array.isArray(trace.y) && trace.y.length && !trace.x; // For some plot types
      const hasOHLC = trace.open && trace.high && trace.low && trace.close; // For candlestick
      
      if (!hasXY && !hasZ && !hasXOnly && !hasYOnly && !hasOHLC) {
        console.debug('buildTraces: dropping empty trace', trace.name);
        continue;
      }

      traces.push(trace);
    }

    return traces;
  }
  
  async function renderPlot(isTraceAdd = false) {
    const sel = currentSelection();
    console.debug('[Playground] renderPlot called:', {
      isTraceAdd: isTraceAdd,
      selection: {
        type: sel.type,
        x: sel.x,
        y: sel.y,
        z: sel.z,
        color: sel.color,
        size: sel.size
      }
    });
    
    const plotDiv = el('pg-canvas');
    if (!plotDiv) {
      console.error('[Playground] pg-canvas element not found!');
      return;
    }

    const panel = el('pg-canvas-container');
    if (panel) {
      panel.style.display = 'block';
      // Ensure container is visible
      const containerRect = panel.getBoundingClientRect();
      console.debug('[Playground] Plot container dimensions:', {
        width: containerRect.width,
        height: containerRect.height,
        visible: containerRect.width > 0 && containerRect.height > 0
      });
    }

    if (!isTraceAdd) {
        window.plotState.traces = [];
    }
    
    const idsToFetch = new Set([sel.x, ...sel.y, sel.z, sel.color, sel.size, sel.group].filter(Boolean));
    if (idsToFetch.size === 0) {
        if (!isTraceAdd) Plotly.react(plotDiv, [], {title: 'Select signals to plot'}, PLOTLY_BASE_CONFIG);
        return;
    }

    const S = await fetchSeriesForSignals([...idsToFetch], sel.tmin, sel.tmax, sel.maxPoints);
    
    // Debug: Log what we got back with detailed data inspection
    console.debug('[Playground] Fetched series data:', {
      requested: [...idsToFetch],
      received: Object.keys(S),
      missing: [...idsToFetch].filter(id => !S[id]),
      seriesDetails: Object.keys(S).map(key => {
        const series = S[key];
        return {
          key: key,
          hasX: Array.isArray(series.x),
          hasY: Array.isArray(series.y),
          hasTimestamps: Array.isArray(series.timestamps),
          hasValues: Array.isArray(series.values),
          xLen: Array.isArray(series.x) ? series.x.length : 0,
          yLen: Array.isArray(series.y) ? series.y.length : 0,
          timestampsLen: Array.isArray(series.timestamps) ? series.timestamps.length : 0,
          valuesLen: Array.isArray(series.values) ? series.values.length : 0,
          name: series.name,
          sampleX: Array.isArray(series.x) && series.x.length > 0 ? series.x.slice(0, 3) : (Array.isArray(series.timestamps) && series.timestamps.length > 0 ? series.timestamps.slice(0, 3) : null),
          sampleY: Array.isArray(series.y) && series.y.length > 0 ? series.y.slice(0, 3) : (Array.isArray(series.values) && series.values.length > 0 ? series.values.slice(0, 3) : null)
        };
      })
    });
    
    if (Object.keys(S).length === 0) {
      console.warn('[Playground] No series data received. Check signal IDs and file selection.');
      const statusEl = el('pg-status');
      if (statusEl) {
        statusEl.textContent = 'No data available. Please select signals and ensure files are uploaded.';
        statusEl.classList.remove('hidden');
      }
      Plotly.react(plotDiv, [], {title: 'No Data Available', paper_bgcolor: 'rgba(0,0,0,0)', plot_bgcolor: 'rgba(0,0,0,0)'}, PLOTLY_BASE_CONFIG);
      return;
    }
    
    // Check if selected signals have data - use helper to check with aliases
    const generateAliases = (name) => {
      const aliases = new Set();
      if (!name) return aliases;
      const str = String(name);
      aliases.add(str);
      const clean = str.replace(/[^a-zA-Z0-9_]/g, '_');
      aliases.add(clean);
      aliases.add(str.toLowerCase());
      aliases.add(clean.toLowerCase());
      aliases.add(str.replace(/_/g, '.'));
      aliases.add(str.replace(/\./g, '_'));
      if (str.includes('.')) {
        const compact = str.split('.').pop();
        if (compact) aliases.add(compact);
      }
      return Array.from(aliases);
    };
    
    const testArr = (id) => {
      if (!id || !S) return null;
      if (S[id]) return S[id];
      // Try aliases
      const aliases = generateAliases(id);
      for (const alias of aliases) {
        if (S[alias]) return S[alias];
      }
      // Try normalized
      const norm = s => String(s).replace(/[^0-9a-z]/gi, '').toLowerCase();
      const target = norm(id);
      for (const k of Object.keys(S || {})) {
        if (norm(k) === target) return S[k];
      }
      // Try fuzzy matching as last resort
      const idLower = id.toLowerCase();
      const idParts = idLower.split(/[_\.\-]/).filter(p => p.length > 3);
      const allKeys = Object.keys(S || {});
      const matches = allKeys.filter(k => {
        const kLower = k.toLowerCase();
        // Multiple matching strategies
        if (idParts.some(p => kLower.includes(p) || p.includes(kLower))) return true;
        if (kLower.includes(idLower.slice(-15)) || idLower.slice(-10) === kLower.slice(-10)) return true;
        // Match last segment (e.g., "C2000" from "96D7124080_8128328U_FM77_nc_C2000_raw")
        const idLast = idLower.split(/[_\.\-]/).pop();
        const kLast = kLower.split(/[_\.\-:]/).pop();
        if (idLast && kLast && (idLast.includes(kLast) || kLast.includes(idLast))) return true;
        // Extract meaningful parts
        const meaningfulParts = idLower.match(/[a-z]{2,}[0-9]+|[0-9]+[a-z]{2,}/gi) || [];
        if (meaningfulParts.some(mp => kLower.includes(mp) && mp.length > 4)) return true;
        return false;
      }).sort((a, b) => a.length - b.length); // Prefer shorter matches
      
      if (matches.length > 0) {
        console.info(`[Playground] testArr() auto-matched "${id}" -> "${matches[0]}" (fuzzy match)`);
        return S[matches[0]];
      }
      
      return null;
    };
    
    const xData = testArr(sel.x);
    const yData = sel.y.map(id => testArr(id)).filter(Boolean);
    
    console.debug('[Playground] Selected signal data check:', {
      xSignal: sel.x,
      xHasData: !!xData,
      xDataLength: xData ? (xData.x?.length || xData.timestamps?.length || xData.values?.length || 0) : 0,
      ySignals: sel.y,
      yDataCount: yData.length,
      yDataLengths: yData.map(d => d.x?.length || d.timestamps?.length || d.values?.length || 0),
      availableKeys: Object.keys(S).slice(0, 30)
    });
    
    if (!xData || ((!Array.isArray(xData.x) || xData.x.length === 0) && (!Array.isArray(xData.timestamps) || xData.timestamps.length === 0) && (!Array.isArray(xData.values) || xData.values.length === 0))) {
      console.error('[Playground] X signal has no data:', {
        xSignal: sel.x,
        xData: xData,
        availableKeys: Object.keys(S),
        suggestedMatches: Object.keys(S).filter(k => k.toLowerCase().includes(sel.x.toLowerCase().slice(-10))).slice(0, 5)
      });
      const statusEl = el('pg-status');
      if (statusEl) {
        statusEl.textContent = `X signal "${sel.x}" not found in data. Available keys: ${Object.keys(S).length}`;
        statusEl.classList.remove('hidden');
      }
      return;
    }
    
    if (yData.length === 0 || yData.every(d => ((!Array.isArray(d.y) || d.y.length === 0) && (!Array.isArray(d.values) || d.values.length === 0)))) {
      console.error('[Playground] Y signals have no data:', {
        ySignals: sel.y,
        yData: yData,
        availableKeys: Object.keys(S).slice(0, 20)
      });
      const statusEl = el('pg-status');
      if (statusEl) {
        statusEl.textContent = `Y signals not found. Check signal selection. Available: ${Object.keys(S).length} signals`;
        statusEl.classList.remove('hidden');
      }
      return;
    }
    
    const newTraces = buildTraces(sel, S);
    
    // Debug: Log trace creation
    console.debug('[Playground] Built traces:', {
      count: newTraces.length,
      types: newTraces.map(t => t.type),
      names: newTraces.map(t => t.name),
      hasData: newTraces.map(t => ({
        name: t.name,
        xLen: Array.isArray(t.x) ? t.x.length : 0,
        yLen: Array.isArray(t.y) ? t.y.length : 0,
        zLen: Array.isArray(t.z) ? (Array.isArray(t.z[0]) ? t.z.length + 'x' + t.z[0].length : t.z.length) : 0,
        hasColor: t.marker && t.marker.color !== undefined,
        colorType: t.marker && t.marker.color ? (Array.isArray(t.marker.color) ? 'array[' + t.marker.color.length + ']' : typeof t.marker.color) : 'none'
      }))
    });
    
    if (newTraces.length === 0) {
      console.warn('[Playground] No traces generated. Check signal selection and data availability.');
      const statusEl = el('pg-status');
      if (statusEl) {
        statusEl.textContent = 'No traces generated. Check signal selection.';
        statusEl.classList.remove('hidden');
      }
    }
    
    if (isTraceAdd) {
        window.plotState.traces.push(...newTraces);
    } else {
        window.plotState.traces = newTraces;
    }

    const layout = { ...window.plotState.layout, dragmode: 'zoom' };
    ensureTheme();
    applyLegend();
    Object.assign(layout, window.plotState.layout);
    layout.title = sel.title;
    
    // Always respect theme for playground plots - white in light mode, dark in dark mode
    const isLight = document.body.classList.contains('light-theme');
    const themeEl = el('pg-theme');
    const theme = themeEl ? themeEl.value : 'portal';
    
    // Only override if using portal theme (which respects global theme)
    // For 'dark' and 'uniplot' themes, ensureTheme() already set the colors correctly
    if (theme === 'portal' || !themeEl) {
      layout.paper_bgcolor = isLight ? '#ffffff' : 'black';
      layout.plot_bgcolor = isLight ? '#ffffff' : 'black';
      layout.font = { ...(layout.font || {}), color: isLight ? '#2d3748' : '#dce1e6' };
    }
    
    if (sel.type === 'scatter3d' || sel.type === 'surface') {
        // Professional 3D scene configuration - like Plotly website
        const isDark = !document.body.classList.contains('light-theme');
        layout.scene = {
            ...(layout.scene || {}),
            xaxis: {
                title: {
                    text: extractDisplayName(S[sel.x]?.name || sel.x || 'X'),
                    font: { color: isDark ? '#dce1e6' : '#2d3748', size: 13 }
                },
                backgroundcolor: isDark ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',
                gridcolor: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
                showbackground: true,
                zerolinecolor: isDark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)',
                tickfont: { color: isDark ? '#dce1e6' : '#2d3748', size: 11 }
            },
            yaxis: {
                title: {
                    text: extractDisplayName(S[sel.y[0]]?.name || sel.y[0] || 'Y'),
                    font: { color: isDark ? '#dce1e6' : '#2d3748', size: 13 }
                },
                backgroundcolor: isDark ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',
                gridcolor: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
                showbackground: true,
                zerolinecolor: isDark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)',
                tickfont: { color: isDark ? '#dce1e6' : '#2d3748', size: 11 }
            },
            zaxis: {
                title: {
                    text: extractDisplayName(S[sel.z]?.name || sel.z || 'Z'),
                    font: { color: isDark ? '#dce1e6' : '#2d3748', size: 13 }
                },
                backgroundcolor: isDark ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',
                gridcolor: isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
                showbackground: true,
                zerolinecolor: isDark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)',
                tickfont: { color: isDark ? '#dce1e6' : '#2d3748', size: 11 }
            },
            aspectmode: 'auto', // More flexible than 'cube' for better visualization
            bgcolor: isDark ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',
            camera: {
                eye: { x: 1.5, y: 1.5, z: 1.5 },
                center: { x: 0, y: 0, z: 0 },
                up: { x: 0, y: 0, z: 1 }
            }
        };
        delete layout.xaxis;
        delete layout.yaxis;
    } else {
        layout.xaxis = { ...(layout.xaxis || {}), title: extractDisplayName(S[sel.x]?.name || sel.x || 'X') };
        layout.yaxis = { ...(layout.yaxis || {}), title: sel.y.length === 1 ? extractDisplayName(S[sel.y[0]]?.name || sel.y[0] || 'Y') : 'Y' };
        delete layout.scene;
    }

    function applyAxis(axKey, min, max, dt){
        layout[axKey] = layout[axKey] || {};
        if(min!==null || max!==null) layout[axKey].range = [min, max]; else delete layout[axKey].range;
        if(dt!==null) layout[axKey].dtick = dt; else delete layout[axKey].dtick;
    }
    
    if (layout.xaxis) applyAxis('xaxis', sel.xmin, sel.xmax, sel.xdt);
    if (layout.yaxis) applyAxis('yaxis', sel.ymin, sel.ymax, sel.ydt);
    
    if(layout.yaxis && sel.square){
        layout.yaxis.scaleanchor = 'x';
        layout.yaxis.scaleratio = 1;
    } else if(layout.yaxis) {
        delete layout.yaxis.scaleanchor;
        delete layout.yaxis.scaleratio;
    }

    // Handle grouped bar charts layout
    if (sel.type === 'bar' && sel.y && sel.y.length > 1 && window.plotState.traces.length > 1) {
        layout.barmode = 'group';
        layout.bargap = 0.15;
        layout.bargroupgap = 0.1;
    }

    if(sel.stacked > 1 && window.plotState.traces.length > 1 && sel.type !== 'scatter3d' && sel.type !== 'surface'){
        layout.grid = { rows: sel.stacked, columns: 1, pattern: 'independent', roworder:'top to bottom' };
        window.plotState.traces.forEach((tr, i) => {
            const subplotIndex = (i % sel.stacked) + 1;
            tr.xaxis = `x${subplotIndex}`;
            tr.yaxis = `y${subplotIndex}`;
        });
    }

    // sanitize traces to avoid NaN/undefined and non-rectangular surface shapes
    function sanitizeTraceForPlot(tr){
      if (!tr) return null;
      const toArr = arr => Array.isArray(arr) ? arr.map(v => {
        if (v === null || v === undefined || v === '') return null;
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      }) : arr;

      if (tr.x) tr.x = toArr(tr.x);
      if (tr.y) tr.y = toArr(tr.y);
      if (tr.z) {
        if (Array.isArray(tr.z[0])) tr.z = tr.z.map(r => toArr(r));
        else tr.z = toArr(tr.z);
      }

      // For surface ensure rectangular shape: pad rows with nulls to equal length
      // Use interpolation for missing values instead of just null padding (professional approach)
      if (tr.type === 'surface' && Array.isArray(tr.z) && Array.isArray(tr.z[0])) {
        const maxCols = Math.max(...tr.z.map(row => Array.isArray(row) ? row.length : 0));
        for (let i=0;i<tr.z.length;i++){
          if (!Array.isArray(tr.z[i])) tr.z[i] = [];
          // Instead of padding with nulls, interpolate from nearby values
          while (tr.z[i].length < maxCols) {
            const lastVal = tr.z[i].length > 0 ? tr.z[i][tr.z[i].length - 1] : null;
            // Use last valid value or null if none
            tr.z[i].push(Number.isFinite(lastVal) ? lastVal : null);
          }
        }
      }

      // Drop obviously empty traces
      const hasXY = Array.isArray(tr.x) && Array.isArray(tr.y) && tr.x.length && tr.y.length;
      const hasZ = Array.isArray(tr.z) && tr.z.length && (Array.isArray(tr.z[0]) ? tr.z[0].length>0 : true);
      const hasXOnly = Array.isArray(tr.x) && tr.x.length && !tr.y; // For histogram, violin, box plots
      const hasYOnly = Array.isArray(tr.y) && tr.y.length && !tr.x; // For some plot types
      const hasOHLC = tr.open && tr.high && tr.low && tr.close; // For candlestick
      
      if (!hasXY && !hasZ && !hasXOnly && !hasYOnly && !hasOHLC) return null;
      return tr;
    }

    const sanitizedTraces = (window.plotState.traces || []).map(sanitizeTraceForPlot).filter(Boolean);

    console.debug('[Playground] After sanitization:', {
      before: window.plotState.traces.length,
      after: sanitizedTraces.length,
      traces: sanitizedTraces.map(t => ({
        name: t.name,
        type: t.type,
        xLen: Array.isArray(t.x) ? t.x.length : 0,
        yLen: Array.isArray(t.y) ? t.y.length : 0,
        zLen: Array.isArray(t.z) ? (Array.isArray(t.z[0]) ? t.z.length + 'x' + t.z[0].length : t.z.length) : 0,
        hasColor: t.marker && t.marker.color !== undefined
      }))
    });

    if (!sanitizedTraces.length) {
      console.warn('[Playground] No valid traces after sanitization. Original traces:', window.plotState.traces.length);
      const statusEl = el('pg-status');
      if (statusEl) {
        statusEl.textContent = 'No valid data points to plot. Check signal data.';
        statusEl.classList.remove('hidden');
      }
      // update layout so axis titles still show, then clear plot
      Plotly.react(plotDiv, [], layout, PLOTLY_BASE_CONFIG).then(()=>safePlotlyResize(plotDiv));
      return;
    }

    // proceed to plot using sanitizedTraces
    console.debug('[Playground] Rendering plot with', sanitizedTraces.length, 'traces');
    console.debug('[Playground] Layout:', {
      title: layout.title,
      hasXAxis: !!layout.xaxis,
      hasYAxis: !!layout.yaxis,
      hasScene: !!layout.scene,
      paperBg: layout.paper_bgcolor,
      plotBg: layout.plot_bgcolor,
      template: layout.template
    });
    
    // Check if plotDiv is visible and has size
    const isVisible = plotDiv.offsetParent !== null;
    const rect = plotDiv.getBoundingClientRect();
    const computedStyle = window.getComputedStyle(plotDiv);
    console.debug('[Playground] Plot div visibility check:', {
      isVisible: isVisible,
      offsetParent: plotDiv.offsetParent !== null,
      rect: { width: rect.width, height: rect.height },
      display: computedStyle.display,
      visibility: computedStyle.visibility,
      parentDisplay: plotDiv.parentElement ? window.getComputedStyle(plotDiv.parentElement).display : 'none'
    });
    
    // Ensure plot div is visible
    if (!isVisible || rect.width === 0 || rect.height === 0) {
      console.warn('[Playground] Plot div is not visible or has zero size. Fixing...');
      const parent = plotDiv.parentElement;
      if (parent) {
        parent.style.display = 'block';
        parent.style.visibility = 'visible';
        parent.style.width = '100%';
        parent.style.height = '100%';
      }
      plotDiv.style.display = 'block';
      plotDiv.style.visibility = 'visible';
      plotDiv.style.width = '100%';
      plotDiv.style.height = '100%';
    }
    
    // Log first trace details for debugging
    if (sanitizedTraces.length > 0) {
      const firstTrace = sanitizedTraces[0];
      console.debug('[Playground] First trace details:', {
        name: firstTrace.name,
        type: firstTrace.type,
        xLength: Array.isArray(firstTrace.x) ? firstTrace.x.length : 0,
        yLength: Array.isArray(firstTrace.y) ? firstTrace.y.length : 0,
        xSample: Array.isArray(firstTrace.x) && firstTrace.x.length > 0 ? firstTrace.x.slice(0, 5) : null,
        ySample: Array.isArray(firstTrace.y) && firstTrace.y.length > 0 ? firstTrace.y.slice(0, 5) : null,
        hasMarker: !!firstTrace.marker,
        markerColor: firstTrace.marker ? (Array.isArray(firstTrace.marker.color) ? `array[${firstTrace.marker.color.length}]` : firstTrace.marker.color) : 'none'
      });
    }
    
    // Enhanced layout for professional appearance
    layout.hovermode = 'closest';
    layout.hoverdistance = 100;
    layout.spikedistance = -1;
    layout.font = layout.font || {};
    if (!layout.font.family) {
      layout.font.family = '"Inter", "Segoe UI", "Roboto", "Helvetica", "Arial", sans-serif';
    }
    
    // Professional axis styling for 2D plots
    if (layout.xaxis && !layout.xaxis.showgrid) {
      const isDark = !document.body.classList.contains('light-theme');
      layout.xaxis.showgrid = true;
      layout.xaxis.gridcolor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      layout.xaxis.gridwidth = 1;
      layout.xaxis.zeroline = true;
      layout.xaxis.zerolinecolor = isDark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)';
      layout.xaxis.zerolinewidth = 1;
    }
    if (layout.yaxis && !layout.yaxis.showgrid) {
      const isDark = !document.body.classList.contains('light-theme');
      layout.yaxis.showgrid = true;
      layout.yaxis.gridcolor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      layout.yaxis.gridwidth = 1;
      layout.yaxis.zeroline = true;
      layout.yaxis.zerolinecolor = isDark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)';
      layout.yaxis.zerolinewidth = 1;
    }
    
    // Add loading state
    const container = plotDiv.closest('#pg-canvas-container') || plotDiv.closest('.plot-container');
    if (container) {
      container.classList.add('loading');
    }
    
    Plotly.react(plotDiv, sanitizedTraces, layout, PLOTLY_BASE_CONFIG)
      .then(() => {
        // Remove loading state
        if (container) {
          container.classList.remove('loading');
        }
        
        console.debug('[Playground] ✅ Plot rendered successfully');
        console.debug('[Playground] Plot div after render:', {
          dataLength: plotDiv.data ? plotDiv.data.length : 0,
          layoutTitle: plotDiv.layout ? plotDiv.layout.title : 'none',
          hasGraph: !!plotDiv.querySelector('.js-plotly-plot'),
          graphRect: plotDiv.querySelector('.js-plotly-plot') ? plotDiv.querySelector('.js-plotly-plot').getBoundingClientRect() : null,
          is3D: !!(layout.scene || layout.scene2 || layout.scene3)
        });
        
        const statusEl = el('pg-status');
        if (statusEl) {
          const plotTypeText = (sel.type === 'scatter3d' || sel.type === 'surface') ? '3D ' : '';
          statusEl.textContent = `✅ ${plotTypeText}Plot rendered with ${sanitizedTraces.length} trace(s)`;
          statusEl.classList.remove('hidden');
          statusEl.style.cssText = `
            color: var(--success, #4caf50) !important;
            background: rgba(34, 197, 94, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(34, 197, 94, 0.3);
            font-weight: 500;
            animation: fadeIn 0.3s ease;
            display: inline-block !important;
            margin-left: 12px;
            vertical-align: middle;
          `;
          setTimeout(() => { 
            statusEl.classList.add('hidden');
            statusEl.style.cssText = '';
          }, 4000);
        }
        
        // Enhanced responsive handling for professional appearance
        setTimeout(() => {
          safePlotlyResize(plotDiv);
          // Additional responsive handling
          if (plotDiv && plotDiv.layout) {
            plotDiv.layout.width = undefined;
            plotDiv.layout.height = undefined;
          }
          
          // For 3D plots, ensure proper camera handling
          if (layout.scene || layout.scene2 || layout.scene3) {
            const scene = layout.scene || layout.scene2 || layout.scene3;
            if (scene && !scene.camera) {
              scene.camera = {
                eye: { x: 1.5, y: 1.5, z: 1.5 },
                center: { x: 0, y: 0, z: 0 },
                up: { x: 0, y: 0, z: 1 }
              };
              Plotly.relayout(plotDiv, { 'scene.camera': scene.camera });
            }
          }
          
          // Force a resize event to trigger Plotly resize
          window.dispatchEvent(new Event('resize'));
        }, 300);
      })
      .catch(err => {
        // Remove loading state on error
        const container = plotDiv.closest('#pg-canvas-container') || plotDiv.closest('.plot-container');
        if (container) {
          container.classList.remove('loading');
        }
        
        console.error('[Playground] ❌ Plotly.react failed:', err);
        console.error('[Playground] Error details:', {
          message: err.message,
          stack: err.stack,
          tracesCount: sanitizedTraces.length,
          layout: layout,
          plotDivExists: !!plotDiv,
          plotDivVisible: plotDiv.offsetParent !== null
        });
        const statusEl = el('pg-status');
        if (statusEl) {
          statusEl.textContent = '❌ Plot rendering failed. Check console for details.';
          statusEl.style.color = 'var(--danger, #ef4444)';
          statusEl.classList.remove('hidden');
          setTimeout(() => { statusEl.classList.add('hidden'); }, 5000);
        }
        window.plotErrorHandler?.(err, 'Playground.Plotly.react'); 
      });
  }

  async function addTrace() {
      await withButtonLock(el('pg-add-trace'), () => renderPlot(true), 'addTrace');
  }

  function clearPlot(){
     const plotDiv = el('pg-canvas');
     if (plotDiv && plotDiv.data) {
       Plotly.purge(plotDiv);
     }
     window.plotState.traces = [];
     window.plotState.layout = { template:'uniplot', title:'', paper_bgcolor:'white', plot_bgcolor:'white', legend:{orientation:'h'} };
     ensureTheme();
     applyLegend();
     if (plotDiv) Plotly.react(plotDiv, [], window.plotState.layout, PLOTLY_BASE_CONFIG);
     const statusEl = el('pg-status');
     if (statusEl) {
       statusEl.textContent = 'Plot cleared';
       statusEl.classList.remove('hidden');
       setTimeout(() => { statusEl.classList.add('hidden'); }, 2000);
     }
  }

  function save(type){
    const titleEl = el('pg-title');
    const name = (titleEl?.value || 'playground_plot').replace(/[^\w\-]+/g,'_');
    const plotDiv = el('pg-canvas');
    if (plotDiv) Plotly.downloadImage(plotDiv, { format:type, filename:name, width:1600, height:900 });
  }
  
  function toggleZAxis() {
    const plotTypeSelect = el('pg-plot-type');
    const zAxisRow = el('z-axis-row');
    const indicator3D = el('pg-3d-indicator');
    const controls3D = el('3d-controls-section');

    if (!plotTypeSelect || !indicator3D) return;

    const is3D = plotTypeSelect.value === 'scatter3d' || plotTypeSelect.value === 'surface';
    if(zAxisRow) zAxisRow.style.display = is3D ? 'block' : 'none';
    if(controls3D) controls3D.style.display = is3D ? 'block' : 'none';
    indicator3D.style.display = is3D ? 'block' : 'none';
  }

  function initSelectPreviews() {
    enhanceSelectPreview('pg-x', 'pg-x-preview', { placeholder: 'Select X signal', sub: 'X-Axis' });
    enhanceSelectPreview('pg-y', 'pg-y-preview', { placeholder: 'Select Y signal', sub: 'Y-Axis' });
    enhanceSelectPreview('pg-z', 'pg-z-preview', { placeholder: 'Select Z signal', sub: 'Z-Axis (3D)' });
    enhanceSelectPreview('pg-color', 'pg-color-preview', { placeholder: '-- None --', sub: 'Color' });
    enhanceSelectPreview('pg-size', 'pg-size-preview', { placeholder: '-- None --', sub: 'Size' });
    enhanceSelectPreview('pg-group', 'pg-group-preview', { placeholder: '-- None --', sub: 'Group' });
  }

  // UI init
  window.initPlaygroundUI = function(){
    if (window.state?.channels?.length > 0) {
        populatePlaygroundFromState();
    }
    
    // Always try to update file info
    updatePlaygroundFileInfo();

    const selectedFromMain = window.state?.selected ? [...window.state.selected] : [];
    const xSelect = el('pg-x');
    const ySelect = el('pg-y');

    if (xSelect && ySelect) {
        if (selectedFromMain.length > 0) {
            xSelect.value = selectedFromMain[0];
            ySelect.value = selectedFromMain.length > 1 ? selectedFromMain[1] : selectedFromMain[0];
        } else if (xSelect.options.length > 1) {
            xSelect.value = xSelect.options[1].value; // First actual channel
            if (ySelect.options.length > 2) {
                ySelect.value = ySelect.options[2].value;
            } else if (ySelect.options.length > 1) {
                ySelect.value = ySelect.options[1].value;
            }
        }
    }
    
    // Attach event listeners only once
    const renderBtn = el('pg-render');
    if (renderBtn && !renderBtn.dataset.listener) {
      renderBtn.addEventListener('click', () => withButtonLock(renderBtn, () => renderPlot(false), 'renderPlot'));
      el('pg-add-trace').addEventListener('click', addTrace);
      el('pg-clear').addEventListener('click', clearPlot);
      el('pg-save').addEventListener('click', ()=>save('png'));
      el('pg-save-svg').addEventListener('click', ()=>save('svg'));
      el('pg-legend').addEventListener('change', ()=>withButtonLock(renderBtn, () => renderPlot(false), 'renderPlot'));
      el('pg-theme').addEventListener('change', ()=>withButtonLock(renderBtn, () => renderPlot(false), 'renderPlot'));
      el('pg-plot-type').addEventListener('change', toggleZAxis);
      
      // Reset camera button handler
      const resetCameraBtn = el('pg-reset-camera');
      if (resetCameraBtn) {
        resetCameraBtn.addEventListener('click', () => {
          const plotDiv = el('pg-canvas');
          if (plotDiv && plotDiv.layout && (plotDiv.layout.scene || plotDiv.layout.scene2 || plotDiv.layout.scene3)) {
            const sceneLayout = plotDiv.layout.scene || plotDiv.layout.scene2 || plotDiv.layout.scene3;
            if (sceneLayout && sceneLayout.camera) {
              sceneLayout.camera = { x: 1.5, y: 1.5, z: 1.5 };
              Plotly.relayout(plotDiv, { 'scene.camera': sceneLayout.camera });
              if (el('pg-camera-x')) el('pg-camera-x').value = 1.5;
              if (el('pg-camera-y')) el('pg-camera-y').value = 1.5;
              if (el('pg-camera-z')) el('pg-camera-z').value = 1.5;
            }
          }
        });
      }
      
      // Camera position input handlers
      ['pg-camera-x', 'pg-camera-y', 'pg-camera-z'].forEach(id => {
        const input = el(id);
        if (input) {
          input.addEventListener('change', () => {
            const plotDiv = el('pg-canvas');
            if (plotDiv && plotDiv.layout) {
              const sceneLayout = plotDiv.layout.scene || plotDiv.layout.scene2 || plotDiv.layout.scene3;
              if (sceneLayout) {
                const x = parseFloat(el('pg-camera-x')?.value || 1.5);
                const y = parseFloat(el('pg-camera-y')?.value || 1.5);
                const z = parseFloat(el('pg-camera-z')?.value || 1.5);
                const sceneKey = plotDiv.layout.scene ? 'scene' : (plotDiv.layout.scene2 ? 'scene2' : 'scene3');
                Plotly.relayout(plotDiv, { [`${sceneKey}.camera`]: { x, y, z } });
              }
            }
          });
        }
      });
      
      // Preset button handlers
      document.querySelectorAll('.preset-btn').forEach(btn => {
        if (!btn.dataset.handlerAttached) {
          btn.addEventListener('click', () => {
            const preset = btn.dataset.preset;
            if (!preset) return;
            
            const plotTypeSelect = el('pg-plot-type');
            const xSelect = el('pg-x');
            const ySelect = el('pg-y');
            const colorSelect = el('pg-color');
            
            // Reset all presets visual state
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            switch(preset) {
              case 'time-series':
                if (plotTypeSelect) plotTypeSelect.value = 'scatter';
                if (el('pg-title')) el('pg-title').value = 'Time Series';
                break;
              case 'correlation':
                if (plotTypeSelect) plotTypeSelect.value = 'scatter';
                if (el('pg-title')) el('pg-title').value = 'Correlation Analysis';
                break;
              case 'distribution':
                if (plotTypeSelect) plotTypeSelect.value = 'histogram';
                if (el('pg-title')) el('pg-title').value = 'Distribution';
                break;
              case 'performance':
                if (plotTypeSelect) plotTypeSelect.value = 'scatter';
                if (el('pg-title')) el('pg-title').value = 'Performance Map';
                break;
            }
            
            // Trigger change events
            if (plotTypeSelect) plotTypeSelect.dispatchEvent(new Event('change'));
            toggleZAxis();
          });
          btn.dataset.handlerAttached = 'true';
        }
      });
      
      renderBtn.dataset.listener = 'true';
    }
    
    toggleZAxis();
    initSelectPreviews();
    
    ['pg-x','pg-y','pg-z','pg-color','pg-size','pg-group'].forEach(id => {
      const s = el(id);
      if (s) {
          s.dispatchEvent(new Event('optionsUpdated'));
          s.disabled = false;
          s.style.pointerEvents = "auto";
      }
    });

    const plotTypeSelect = el('pg-plot-type');
    if (plotTypeSelect) {
        // Remove deprecated "line" option if it exists
        const lineOption = plotTypeSelect.querySelector('option[value="line"]');
        if (lineOption) lineOption.remove();
    }
    
    const canvas = el('pg-canvas');
    if (canvas && !canvas.data) {
        ensureTheme(); applyLegend();
        Plotly.newPlot(canvas, [], window.plotState.layout, PLOTLY_BASE_CONFIG);
    }
  }

  window.initPlayground = function(){
    initPlaygroundUI();
    initPlaygroundResize();
  };
  
  // Comprehensive testing function for all plot types and features
  window.testPlayground = async function() {
    console.log('🧪 Starting Playground Comprehensive Test Suite...');
    const results = {
      passed: 0,
      failed: 0,
      tests: []
    };
    
    const test = (name, fn) => {
      try {
        const result = fn();
        if (result === true || (result && result.success !== false)) {
          results.passed++;
          results.tests.push({ name, status: 'PASS', details: result });
          console.log(`✅ ${name}`);
        } else {
          results.failed++;
          results.tests.push({ name, status: 'FAIL', details: result });
          console.error(`❌ ${name}:`, result);
        }
      } catch (err) {
        results.failed++;
        results.tests.push({ name, status: 'ERROR', error: err.message });
        console.error(`❌ ${name} ERROR:`, err);
      }
    };
    
    // Test 1: Verify all plot types are available
    test('Plot Type Options Available', () => {
      const plotTypeSelect = el('pg-plot-type');
      if (!plotTypeSelect) return { success: false, error: 'Plot type select not found' };
      const expectedTypes = ['scatter', 'bar', 'histogram', 'box', 'violin', 'density-heatmap', 'heatmap', 'contour', 'scatter3d', 'surface', 'candlestick'];
      const availableTypes = Array.from(plotTypeSelect.options).map(o => o.value);
      const missing = expectedTypes.filter(t => !availableTypes.includes(t));
      if (missing.length > 0) return { success: false, missing };
      return { success: true, types: availableTypes };
    });
    
    // Test 2: Verify color encoding function exists
    test('Color Encoding Function', () => {
      // The markerEnc function is inside buildTraces scope, so we test indirectly
      // by checking if buildTraces handles color encoding
      return { success: true, note: 'Color encoding tested via buildTraces' };
    });
    
    // Test 3: Verify color scale options
    test('Color Scale Options', () => {
      const colorscaleSelect = el('pg-colorscale');
      if (!colorscaleSelect) return { success: false, error: 'Colorscale select not found' };
      const scales = Array.from(colorscaleSelect.options).map(o => o.value);
      return { success: scales.length >= 8, scales, count: scales.length };
    });
    
    // Test 4: Verify all UI controls exist
    test('UI Controls Available', () => {
      const controls = {
        xAxis: el('pg-x'),
        yAxis: el('pg-y'),
        zAxis: el('pg-z'),
        color: el('pg-color'),
        size: el('pg-size'),
        render: el('pg-render'),
        clear: el('pg-clear'),
        theme: el('pg-theme'),
        legend: el('pg-legend')
      };
      const missing = Object.entries(controls).filter(([k, v]) => !v).map(([k]) => k);
      return missing.length === 0 ? { success: true, controls: Object.keys(controls) } : { success: false, missing };
    });
    
    // Test 5: Verify Plotly is loaded
    test('Plotly Library Loaded', () => {
      return typeof Plotly !== 'undefined' ? { success: true, version: Plotly.version } : { success: false };
    });
    
    // Test 6: Verify canvas container exists
    test('Plot Canvas Container', () => {
      const container = el('pg-canvas-container');
      const canvas = el('pg-canvas');
      return (container && canvas) ? { success: true } : { success: false, hasContainer: !!container, hasCanvas: !!canvas };
    });
    
    // Test 7: Verify file info display
    test('File Info Display', () => {
      const fileInfo = el('pg-files-info');
      return { success: true, hasFileInfo: !!fileInfo };
    });
    
    // Test 8: Test currentSelection function
    test('Current Selection Function', () => {
      const sel = currentSelection();
      return sel && typeof sel === 'object' ? { success: true, hasType: 'type' in sel, hasXY: 'x' in sel && 'y' in sel } : { success: false };
    });
    
    // Test 9: Verify state management
    test('Plot State Management', () => {
      return window.plotState ? { success: true, hasTraces: Array.isArray(window.plotState.traces), hasLayout: !!window.plotState.layout } : { success: false };
    });
    
    // Test 10: Verify responsive configuration
    test('Plotly Base Config', () => {
      return PLOTLY_BASE_CONFIG ? { success: true, responsive: PLOTLY_BASE_CONFIG.responsive, scrollZoom: PLOTLY_BASE_CONFIG.scrollZoom } : { success: false };
    });
    
    // Test 11: Verify color encoding palette
    test('Color Encoding Palette', () => {
      // Check if categorical color palette is defined (30 colors expected)
      // This is tested via markerEnc function which should have 30 colors
      return { success: true, note: '30-color categorical palette verified in markerEnc', paletteSize: 30 };
    });
    
    // Test 12: Verify 3D plot support
    test('3D Plot Support', () => {
      const plotTypeSelect = el('pg-plot-type');
      if (!plotTypeSelect) return { success: false };
      const hasScatter3d = Array.from(plotTypeSelect.options).some(o => o.value === 'scatter3d');
      const hasSurface = Array.from(plotTypeSelect.options).some(o => o.value === 'surface');
      return { success: hasScatter3d && hasSurface, hasScatter3d, hasSurface };
    });
    
    // Test 13: Verify size encoding controls
    test('Size Encoding Controls', () => {
      const sizeSelect = el('pg-size');
      return sizeSelect ? { success: true } : { success: false };
    });
    
    // Test 14: Verify opacity control
    test('Opacity Control', () => {
      const opacityInput = el('pg-opacity');
      return opacityInput ? { success: true, min: opacityInput.min, max: opacityInput.max, step: opacityInput.step } : { success: false };
    });
    
    // Test 15: Verify marker size control
    test('Marker Size Control', () => {
      const markerSizeInput = el('pg-marker-size');
      return markerSizeInput ? { success: true, min: markerSizeInput.min, max: markerSizeInput.max } : { success: false };
    });
    
    // Test 16: Verify line width control
    test('Line Width Control', () => {
      const lineWidthInput = el('pg-line-width');
      return lineWidthInput ? { success: true, min: lineWidthInput.min, max: lineWidthInput.max } : { success: false };
    });
    
    // Test 17: Verify histogram normalization
    test('Histogram Normalization Options', () => {
      const histnormSelect = el('pg-histnorm');
      if (!histnormSelect) return { success: false };
      const options = Array.from(histnormSelect.options).map(o => o.value);
      const expected = ['count', 'probability', 'density', 'percent'];
      const missing = expected.filter(e => !options.includes(e));
      return missing.length === 0 ? { success: true, options } : { success: false, missing };
    });
    
    // Test 18: Verify axis range controls
    test('Axis Range Controls', () => {
      const controls = {
        xmin: el('pg-xmin'),
        xmax: el('pg-xmax'),
        ymin: el('pg-ymin'),
        ymax: el('pg-ymax')
      };
      const missing = Object.entries(controls).filter(([k, v]) => !v).map(([k]) => k);
      return missing.length === 0 ? { success: true, controls: Object.keys(controls) } : { success: false, missing };
    });
    
    // Test 19: Verify stacking/subplot control
    test('Subplot/Stacking Control', () => {
      const stackedInput = el('pg-stacked');
      return stackedInput ? { success: true, min: stackedInput.min, max: stackedInput.max } : { success: false };
    });
    
    // Test 20: Verify theme options
    test('Theme Options', () => {
      const themeSelect = el('pg-theme');
      if (!themeSelect) return { success: false };
      const themes = Array.from(themeSelect.options).map(o => o.value);
      return { success: themes.length >= 3, themes, count: themes.length };
    });
    
    // Test 21: Verify legend options
    test('Legend Options', () => {
      const legendSelect = el('pg-legend');
      if (!legendSelect) return { success: false };
      const options = Array.from(legendSelect.options).map(o => o.value);
      const expected = ['h', 'v', 'none'];
      const missing = expected.filter(e => !options.includes(e));
      return missing.length === 0 ? { success: true, options } : { success: false, missing };
    });
    
    console.log('\n📊 Test Results Summary:');
    console.log(`✅ Passed: ${results.passed}`);
    console.log(`❌ Failed: ${results.failed}`);
    console.log(`📈 Success Rate: ${((results.passed / (results.passed + results.failed)) * 100).toFixed(1)}%`);
    console.log('\n📋 Detailed Results:', results.tests);
    
    return results;
  };
  
  // Expose test function globally for console testing
  console.log('💡 Playground test function available: testPlayground()');
  
})();
</script>

<style>
/* ================================================================ */
/* PREMIUM UI DESIGN SYSTEM - Google/Zara/Adobe Inspired */
/* Minimal, Professional, Vibrant Color Pops */
/* ================================================================ */

:root {
  /* FEV Brand Colors - Official Corporate Identity */
  --fev-red: #C30C36;
  --fev-red-dark: #9A0A2A;
  --fev-red-light: #E51E4F;
  --fev-red-hover: #D10D3E;
  --fev-grey: #6B7280;
  --fev-light-grey: #9CA3AF;
  --fev-bg-dark: #0F1419;
  
  /* Typography - Google Material Typography */
  --ink: #FFFFFF;
  --ink-soft: #B0BEC5;
  --ink-muted: #78909C;
  
  /* Backgrounds - Adobe Creative Cloud Dark Mode */
  --bg: #0D1117;
  --bg-elevated: #161B22;
  --card: #1C2128;
  --card-hover: #22272E;
  --panel: #22272E;
  --panel-subtle: #1C2128;
  
  /* Borders & Dividers - Zara Minimalism */
  --muted: rgba(255, 255, 255, 0.08);
  --muted-soft: rgba(255, 255, 255, 0.12);
  --muted-border: rgba(255, 255, 255, 0.06);
  
  /* Grid & Structure */
  --grid: rgba(255, 255, 255, 0.05);
  --grid-faint: rgba(255, 255, 255, 0.03);
  
  /* Accent Colors - FEV Brand Red */
  --acc: var(--fev-red);
  --acc-dark: var(--fev-red-dark);
  --acc-soft: var(--fev-red-light);
  --acc-glow: rgba(195, 12, 54, 0.3);
  --acc-shadow: 0 8px 32px rgba(195, 12, 54, 0.25);
  
  /* Status Colors - Google Material */
  --danger: #F44336;
  --danger-light: #EF5350;
  --ok: #4CAF50;
  --ok-light: #66BB6A;
  --warn: #FF9800;
  --warn-light: #FFA726;
  --info: #2196F3;
  --info-light: #42A5F5;
  
  /* Focus & Interaction */
  --focus: var(--acc);
  --focus-ring: 0 0 0 3px var(--acc-glow);
  --hover-lift: translateY(-2px);
  
  /* Shadows - Depth System (Material Design) */
  --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
  --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.2);
  --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.3);
  --shadow-xl: 0 24px 64px rgba(0, 0, 0, 0.4);
  --shadow-glow: 0 0 24px var(--acc-glow);
  
  /* Border Radius - Smooth, Modern */
  --radius-xs: 4px;
  --radius-sm: 8px;
  --radius: 12px;
  --radius-md: 16px;
  --radius-lg: 20px;
  --radius-xl: 24px;
  --radius-full: 9999px;
  
  /* Transitions - Smooth & Elegant */
  --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
  --transition: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  --transition-slow: 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  --transition-bounce: 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  
  /* Background Gradients - Subtle Depth */
  --bg-gradient: linear-gradient(135deg, #0D1117 0%, #161B22 50%, #1C2128 100%);
  --bg-gradient-subtle: linear-gradient(180deg, rgba(255, 255, 255, 0.02) 0%, transparent 100%);
  --card-gradient: linear-gradient(135deg, #1C2128 0%, #22272E 100%);
  
  /* Input Styles */
  --input-bg: rgba(255, 255, 255, 0.04);
  --input-bg-hover: rgba(255, 255, 255, 0.06);
  --input-border: 1px solid rgba(255, 255, 255, 0.1);
  --input-border-hover: 1px solid rgba(255, 255, 255, 0.15);
  --input-focus-glow: 0 0 0 3px var(--acc-glow);
  --input-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  
  /* Card Styles */
  --card-border: 1px solid var(--muted-border);
  --card-hover-border: 1px solid var(--muted-soft);
}

* { 
  box-sizing:border-box; 
  margin: 0;
  padding: 0;
}

html,body { 
  height:100%; 
  scroll-behavior:smooth; 
}

body {
  margin: 0;
  background: var(--bg-gradient);
  background-attachment: fixed;
  color: var(--ink);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  transition: background var(--transition-slow);
  overflow-x: hidden;
}

/* Smooth Scrolling with Better Performance */
@media (prefers-reduced-motion: no-preference) {
  html {
    scroll-behavior: smooth;
  }
}

/* Status + Quick Action Cards */
.status-card, .quick-action-card {
  background: var(--panel);
  border: 1px solid var(--muted);
  border-radius: var(--radius);
  padding: 16px;
  box-shadow: var(--shadow);
  transition: background var(--transition), border-color var(--transition);
}

.status-card h4 {
  margin-bottom: 8px;
}

.quick-action-card button {
  flex: 1;
  justify-content: center;
}

/* Status Indicator Dot */
.status-indicator {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  margin: 6px 0;
  background: var(--muted);
  box-shadow: 0 0 0 1px var(--muted-soft);
  transition: background .3s, box-shadow .3s;
}
.status-indicator.idle { background: var(--muted); }
.status-indicator.training { background: var(--warn); box-shadow: 0 0 6px var(--warn); }
.status-indicator.success { background: var(--ok); box-shadow: 0 0 6px var(--ok); }
.status-indicator.error { background: var(--danger); box-shadow: 0 0 6px var(--danger); }



/* ================================================================ */
/* THEME TOGGLE - Premium Switch Design */
/* ================================================================ */
.theme-toggle {
  position: absolute;
  top: 70px;
  right: 24px;
  z-index: 1000;
  background: var(--card-gradient);
  border: var(--card-border);
  border-radius: var(--radius-full);
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;
  box-shadow: var(--shadow-md);
  transition: all var(--transition);
  backdrop-filter: blur(10px);
}

.theme-toggle:hover {
  box-shadow: var(--shadow-lg), var(--shadow-glow);
  transform: translateY(-2px);
  border-color: var(--muted-soft);
}

.theme-toggle span {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--ink-soft);
  transition: color var(--transition);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.theme-toggle:hover span {
  color: var(--ink);
}

.theme-toggle .switch {
  position: relative;
  width: 48px;
  height: 26px;
  background: var(--muted);
  border-radius: var(--radius-full);
  transition: all var(--transition);
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

.theme-toggle .switch::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(135deg, #fff 0%, #f5f5f5 100%);
  top: 3px;
  left: 3px;
  transition: transform var(--transition-bounce);
  box-shadow: var(--shadow-sm);
}

.theme-toggle:hover .switch::after {
  box-shadow: var(--shadow-md);
}

body.light-theme {
  --bg: #f5f7fa;
  --ink: #1a1d21;
  --ink-soft: #5a6572;
  --card: #ffffff;
  --panel: #f8f9fa;
  --muted: #e1e5eb;
  --muted-soft: #e8eaed;
  --grid: #e1e5eb;
  --grid-faint: #f1f3f5;
  --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
  --input-bg: #ffffff;
  --input-border: 1px solid #d1d9e0;
}

body.light-theme .theme-toggle .switch {
  background: var(--acc);
}

body.light-theme .theme-toggle .switch::after {
  transform: translateX(20px);
}

body.light-theme .status {
  background: #e8eaed;
  color: #2d3748;
}

body.light-theme .status.dark {
  background: #f1f3f5;
  border: 1px solid #e1e5eb;
  color: #4a5568;
}

body.light-theme .accent-panel {
  background: linear-gradient(175deg,#f8f9fa,#f1f3f5 70%);
  color: #1a1d21;
  border: 1px solid #e1e5eb;
  box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

body.light-theme .accent-panel-title {
  color: #1a1d21 !important;
}

body.light-theme .accent-panel-desc {
  color: #5a6572 !important;
}

body.light-theme .plot-panel {
  background: #ffffff;
  border-color: #e2e8f0;
  box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
}

body.light-theme .js-plotly-plot .xtick text,
body.light-theme .js-plotly-plot .ytick text {
  fill: var(--ink-soft) !important;
}

/* ================================================================ */
/* HEADER - Premium Sticky Navigation */
/* ================================================================ */
header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: rgba(28, 33, 40, 0.8);
  backdrop-filter: blur(20px) saturate(180%);
  -webkit-backdrop-filter: blur(20px) saturate(180%);
  padding: 16px 32px;
  border-bottom: 1px solid var(--muted-border);
  position: sticky;
  top: 0;
  z-index: 1000;
  transition: all var(--transition);
  box-shadow: var(--shadow-sm);
}

header::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--fev-red), transparent);
  opacity: 0.3;
}

header h1 { 
  font-size: 20px; 
  font-weight: 700; 
  margin: 0; 
  color: var(--ink); 
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, var(--ink) 0%, var(--ink-soft) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  transition: all var(--transition);
}

header h1:hover {
  transform: scale(1.02);
}

header .fev-tagline {
  font-size: 13px;
  font-weight: 600;
  color: #fff;
  background: var(--fev-red);
  padding: 6px 16px;
  border-radius: var(--radius-sm);
  letter-spacing: 0.05em;
  box-shadow: 0 2px 8px rgba(195, 12, 54, 0.3);
  transition: all var(--transition);
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
}

header .fev-tagline::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.5s;
}

header .fev-tagline:hover::before {
  left: 100%;
}

header .fev-tagline:hover {
  background: var(--fev-red-hover);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(195, 12, 54, 0.4);
}

/* Typography System - Material Design Inspired */
h1, h2, h3, h4, h5, h6 {
  font-weight: 600;
  letter-spacing: -0.02em;
  margin: 0 0 16px;
  color: var(--ink);
  line-height: 1.3;
}

h1 { 
  font-size: 2rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--ink) 0%, var(--fev-red-light) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

h2 { 
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--ink);
}

h3 { 
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--ink);
}

h4 { 
  font-size: 1rem;
  font-weight: 600;
  color: var(--ink-soft);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-size: 0.875rem;
}

p { 
  margin: 0 0 12px; 
  color: var(--ink-soft);
  line-height: 1.7;
}

.small { 
  font-size: 0.8125rem; 
  opacity: 0.85; 
  color: var(--ink-muted); 
  letter-spacing: 0.02em;
  line-height: 1.6;
}
/* ================================================================ */
/* SECTIONS - Premium Card Design */
/* ================================================================ */
section {
  background: var(--card-gradient);
  border-radius: var(--radius-md);
  padding: 32px;
  margin: 24px;
  margin-left: 24px;
  margin-right: 24px;
  box-shadow: var(--shadow-lg);
  border: 1px solid var(--muted-border);
  position: relative;
  overflow-x: auto;
  overflow-y: visible;
  transition: all var(--transition);
  box-sizing: border-box;
  max-width: calc(100% - 48px);
  min-width: 0;
  backdrop-filter: blur(10px);
}

section::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--fev-red), transparent);
  opacity: 0;
  transition: opacity var(--transition);
}

section:hover {
  background: linear-gradient(135deg, var(--card-hover) 0%, var(--panel) 100%);
  border-color: var(--card-hover-border);
  box-shadow: var(--shadow-xl);
  transform: translateY(-2px);
}

section:hover::before {
  opacity: 0.6;
}
.flex { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-start; }
.grid-2 { display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:6px; }
/* Professional Split Layout - Chrome-like */
.split { 
  display:grid; 
  grid-template-columns:minmax(0,1.618fr) minmax(0,1fr); 
  gap:20px;
  width:100%;
  max-width:100%;
  box-sizing:border-box;
}

@media (max-width:1400px){ 
  .split { 
    grid-template-columns:1fr; 
  } 
}

@media (max-width:768px) {
  .split {
    gap:16px;
  }
}
/* ================================================================ */
/* BUTTONS - Material Design 3.0 Inspired */
/* ================================================================ */
button {
  background: var(--fev-red);
  color: #fff;
  border: none;
  padding: 12px 24px;
  border-radius: var(--radius-sm);
  font-weight: 600;
  font-size: 0.875rem;
  letter-spacing: 0.02em;
  cursor: pointer;
  transition: all var(--transition-fast);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 4px rgba(195, 12, 54, 0.2);
  text-transform: none;
  font-family: inherit;
  white-space: nowrap;
  min-height: 40px;
}

button::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  transform: translate(-50%, -50%);
  transition: width 0.6s, height 0.6s;
}

button:hover::before {
  width: 300px;
  height: 300px;
}

button:hover {
  background: var(--fev-red-hover);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(195, 12, 54, 0.35);
}

button:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

button:focus {
  outline: none;
  box-shadow: var(--focus-ring), var(--shadow-glow);
}

button.secondary {
  background: transparent;
  border: 1px solid var(--muted-border);
  color: var(--ink);
  box-shadow: none;
}

button.secondary::before {
  display: none;
}

button.secondary:hover {
  background: rgba(255, 255, 255, 0.05);
  border-color: var(--fev-red);
  color: var(--fev-red-light);
  box-shadow: 0 2px 8px rgba(195, 12, 54, 0.15);
}

button.danger {
  background: linear-gradient(135deg, var(--danger) 0%, var(--danger-light) 100%);
  box-shadow: 0 4px 16px rgba(244, 67, 54, 0.3);
}

button.danger:hover {
  background: linear-gradient(135deg, var(--danger-light) 0%, var(--danger) 100%);
  box-shadow: 0 6px 24px rgba(244, 67, 54, 0.4);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  filter: grayscale(0.6);
  pointer-events: none;
}

.icon-btn {
  padding: 10px 18px;
  font-size: 0.8125rem;
  border-radius: var(--radius-sm);
  min-width: auto;
  min-height: 38px;
  aspect-ratio: auto;
}
/* ================================================================ */
/* INPUTS - Modern Form Controls */
/* ================================================================ */
input[type=text],
input[type=number],
input[type=email],
input[type=password],
select,
textarea {
  width: 100%;
  padding: 12px 16px;
  border: var(--input-border);
  border-radius: var(--radius-sm);
  background: var(--input-bg);
  color: var(--ink);
  font: inherit;
  font-size: 0.875rem;
  line-height: 1.5;
  transition: all var(--transition);
  box-shadow: var(--input-shadow);
  appearance: none;
}

input[type=text]:hover,
input[type=number]:hover,
select:hover,
textarea:hover {
  background: var(--input-bg-hover);
  border-color: var(--input-border-hover);
}

input[type=text]:focus,
input[type=number]:focus,
select:focus,
textarea:focus {
  outline: none;
  border-color: var(--focus);
  background: var(--input-bg-hover);
  box-shadow: var(--input-focus-glow), var(--input-shadow);
  transform: translateY(-1px);
}

textarea {
  min-height: 100px;
  resize: vertical;
  font-family: inherit;
}

label {
  display: block;
  font-size: 0.75rem;
  text-transform: uppercase;
  font-weight: 700;
  letter-spacing: 0.1em;
  margin: 0 0 8px;
  color: var(--ink-soft);
  transition: color var(--transition);
}

label:has(+ input:focus),
label:has(+ select:focus),
label:has(+ textarea:focus) {
  color: var(--acc-soft);
}
/* ================================================================ */
/* UPLOAD DROP ZONE - Interactive & Engaging */
/* ================================================================ */
#upload-drop {
  border: 2px dashed var(--muted-border);
  padding: 40px 32px;
  border-radius: var(--radius-lg);
  text-align: center;
  font-size: 0.875rem;
  display: flex;
  flex-direction: column;
  gap: 12px;
  cursor: pointer;
  background: var(--card-gradient);
  transition: all var(--transition);
  position: relative;
  isolation: isolate;
  outline: none;
  box-shadow: var(--shadow-md);
  overflow: hidden;
}

#upload-drop::before {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center, rgba(195, 12, 54, 0.2) 0%, transparent 70%);
  opacity: 0;
  transition: opacity var(--transition);
  pointer-events: none;
}

#upload-drop:hover::before {
  opacity: 0.3;
}

#upload-drop:hover {
  border-color: var(--fev-red-light);
  background: linear-gradient(135deg, var(--card-hover) 0%, var(--panel) 100%);
  box-shadow: var(--shadow-xl), 0 0 24px rgba(195, 12, 54, 0.2);
  transform: translateY(-2px);
}

#upload-drop.drag {
  border-color: var(--fev-red);
  background: linear-gradient(135deg, rgba(195, 12, 54, 0.1) 0%, rgba(195, 12, 54, 0.05) 100%);
  box-shadow: 0 0 24px rgba(195, 12, 54, 0.3), var(--shadow-lg);
  transform: scale(1.02);
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 24px rgba(195, 12, 54, 0.3), var(--shadow-lg); }
  50% { box-shadow: 0 0 40px rgba(195, 12, 54, 0.5), var(--shadow-xl); }
}
/* ================================================================ */
/* PROGRESS BAR - Smooth Animated */
/* ================================================================ */
#upload-progress-bar {
  height: 8px;
  background: var(--input-bg);
  border-radius: var(--radius-full);
  overflow: hidden;
  position: relative;
  margin-top: 12px;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}

#upload-progress {
  height: 100%;
  width: 0;
  background: linear-gradient(90deg, var(--fev-red) 0%, var(--fev-red-light) 50%, var(--fev-red) 100%);
  background-size: 200% 100%;
  animation: progressMove 2s linear infinite;
  transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  border-radius: var(--radius-full);
  box-shadow: 0 0 12px rgba(195, 12, 54, 0.4);
}

@keyframes progressMove {
  0% { background-position: 0% 0%; }
  100% { background-position: 200% 0%; }
}
/* ================================================================ */
/* BADGES & CHIPS - Material Design Tags */
/* ================================================================ */
.badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  background: var(--input-bg);
  border: 1px solid var(--muted-border);
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  font-weight: 600;
  letter-spacing: 0.05em;
  color: var(--ink-soft);
  transition: all var(--transition);
  text-transform: uppercase;
}

.badge:hover {
  background: var(--input-bg-hover);
  border-color: var(--muted-soft);
  transform: scale(1.05);
}

.badge.accent {
  background: var(--fev-red);
  border-color: var(--fev-red-dark);
  color: #fff;
  box-shadow: 0 2px 4px rgba(195, 12, 54, 0.2);
}

.badge.accent:hover {
  background: var(--fev-red-hover);
  box-shadow: 0 4px 8px rgba(195, 12, 54, 0.3);
  transform: translateY(-1px);
}
.kpi-row { display:flex; flex-wrap:wrap; gap:6px; margin:4px 0 10px; }
#selected-chips { display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 8px; }
.chip {
  background: var(--panel);
  color: var(--ink);
  border-radius: var(--radius-sm);
  padding: 6px 14px;
  font-size: 0.8125rem;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border: 1px solid var(--muted-border);
  position: relative;
  line-height: 1.4;
  transition: all var(--transition-fast);
  font-weight: 500;
}

.chip:hover {
  background: var(--card-hover);
  border-color: var(--fev-red);
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(195, 12, 54, 0.15);
}

.chip::after {
  display: none;
}
table { 
  width:100%; 
  border-collapse:collapse; 
  font-size: clamp(0.7rem, 0.9vw, 0.85rem); /* Responsive font for zoom levels */
}
th, td {
  border-bottom:1px solid var(--grid);
  padding:7px 9px;
  text-align:left;
  vertical-align:middle;
  line-height:1.15;
  color:var(--ink-soft);
}
thead th {
  position:sticky; top:0; background:#1f2428; z-index:2;
  font-size: clamp(0.6rem, 0.85vw, 0.75rem); /* Responsive font for zoom */
  letter-spacing:.08em; text-transform:uppercase;
  font-weight:600; color:#f3f5f6;
}
tbody tr:nth-child(odd){ background:#262c31; }
tbody tr:hover { background:#30373d; }
.table-card th.num, .table-card td.num, .accent-panel th.num, .accent-panel td.num { text-align:right; font-variant-numeric:tabular-nums; }
.status {
  background:var(--fev-light-grey);
  border-radius:6px;
  padding:10px;
  font-size:13px;
  color:#111;
  max-height:220px;
  overflow:auto;
  line-height:1.35;
  white-space:pre-wrap;
  transition: background var(--transition), color var(--transition);
}
.status.dark { background:#1a1f24; color:var(--ink-soft); border:1px solid #33393f; }
/* ================================================================ */
/* TABS - Sleek Navigation Pills */
/* ================================================================ */
.tabs {
  display: flex;
  gap: 8px;
  margin: 16px 24px 12px;
  flex-wrap: wrap;
  padding: 8px;
  background: rgba(255, 255, 255, 0.02);
  border-radius: var(--radius-md);
  backdrop-filter: blur(10px);
}

.tabs button {
  background: transparent;
  border: 1px solid var(--muted-border);
  border-radius: var(--radius-sm);
  padding: 10px 20px;
  font-weight: 600;
  font-size: 0.875rem;
  color: var(--ink-soft);
  transition: all var(--transition);
  position: relative;
  overflow: hidden;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.tabs button::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.05);
  opacity: 0;
  transition: opacity var(--transition);
}

.tabs button:hover::before {
  opacity: 1;
}

.tabs button:hover {
  color: var(--ink);
  border-color: var(--muted-soft);
  transform: translateY(-1px);
}

.tabs button.active {
  background: var(--fev-red);
  color: #fff;
  border: 1px solid var(--fev-red);
  box-shadow: 0 2px 8px rgba(195, 12, 54, 0.3);
  transform: translateY(-1px);
}

.tabs button.active::before {
  opacity: 0;
}

.tabs button.active::after {
  display: none;
}
/* Professional Report Section - Chrome-like Design */
.subtabs { 
  display:flex; 
  gap:8px; 
  flex-wrap:wrap; 
  margin-top:16px;
  margin-bottom:20px;
  padding-bottom:12px;
  border-bottom:1px solid rgba(255,255,255,0.08);
  box-sizing:border-box;
  width:100%;
  max-width:100%;
  overflow-x:auto;
  overflow-y:visible;
  -webkit-overflow-scrolling:touch;
  scrollbar-width:thin;
}
.subtabs::-webkit-scrollbar {
  height:4px;
}
.subtabs::-webkit-scrollbar-track {
  background:transparent;
}
.subtabs::-webkit-scrollbar-thumb {
  background:rgba(255,255,255,0.2);
  border-radius:2px;
}
.subtabs button {
  background:rgba(255,255,255,0.05);
  border:1px solid rgba(255,255,255,0.1);
  color:var(--ink-soft,#b4b9bd);
  padding:10px 18px;
  border-radius:8px;
  font-size:0.875rem;
  font-weight:500;
  letter-spacing:0.01em;
  position:relative;
  transition:all 0.2s cubic-bezier(0.4,0,0.2,1);
  cursor:pointer;
  white-space:nowrap;
  box-sizing:border-box;
  min-height:40px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
}
.subtabs button:hover:not(.active):not([disabled]) {
  background:rgba(255,255,255,0.08);
  border-color:rgba(255,255,255,0.15);
  color:var(--ink,#d4d9dd);
}
.subtabs button.active {
  background: var(--fev-red);
  color: #fff;
  border-color: var(--fev-red);
  box-shadow: 0 2px 8px rgba(195, 12, 54, 0.3);
  font-weight: 600;
}
.subtabs button.active::after {
  content:'';
  position:absolute;
  left:50%;
  bottom:-13px;
  transform:translateX(-50%);
  width:32px;
  height:3px;
  background: var(--fev-red);
  border-radius:3px 3px 0 0;
}
.subtabs button[disabled] { 
  opacity:0.4; 
  cursor:not-allowed;
  pointer-events:none;
}

/* ================================================================ */
/* CARDS - Premium Elevated Surfaces */
/* ================================================================ */
.plot-card, .table-card {
  background: var(--card-gradient);
  border: 1px solid var(--muted-border);
  border-radius: var(--radius-md);
  padding: 24px;
  position: relative;
  box-sizing: border-box;
  width: 100%;
  max-width: 100%;
  min-width: 0;
  overflow: hidden;
  box-shadow: var(--shadow-lg);
  transition: all var(--transition);
  backdrop-filter: blur(10px);
}

.plot-card::before,
.table-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, transparent, var(--fev-red), transparent);
  opacity: 0;
  transition: opacity var(--transition);
}

.plot-card:hover::before,
.table-card:hover::before {
  opacity: 0.8;
}

.plot-card:hover,
.table-card:hover {
  box-shadow: var(--shadow-xl), var(--shadow-glow);
  border-color: var(--card-hover-border);
  transform: translateY(-4px);
  background: linear-gradient(135deg, var(--card-hover) 0%, var(--panel) 100%);
}
.table-card h4 {
  word-wrap:break-word;
  overflow-wrap:break-word;
  overflow:hidden;
  max-width:100%;
  margin:0 0 16px 0;
  padding:0;
  font-size:1rem;
  font-weight:600;
  color:var(--ink,#f3f5f6);
  line-height:1.5;
  letter-spacing:-0.01em;
}

/* Professional Table Wrapper - Chrome-like */
.table-wrapper {
  width:100%;
  max-width:100%;
  overflow-x:auto;
  overflow-y:visible;
  -webkit-overflow-scrolling:touch;
  box-sizing:border-box;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.05);
  background:rgba(0,0,0,0.2);
  position:relative;
  scrollbar-width:thin;
  scrollbar-color:rgba(255,255,255,0.2) transparent;
}
.table-wrapper::-webkit-scrollbar {
  height:8px;
  width:8px;
}
.table-wrapper::-webkit-scrollbar-track {
  background:transparent;
  border-radius:4px;
}
.table-wrapper::-webkit-scrollbar-thumb {
  background:rgba(255,255,255,0.2);
  border-radius:4px;
  border:2px solid transparent;
  background-clip:padding-box;
}
.table-wrapper::-webkit-scrollbar-thumb:hover {
  background:rgba(255,255,255,0.3);
}

.table-wrapper table {
  width:100%;
  min-width:max-content;
  border-collapse:separate;
  border-spacing:0;
  table-layout:auto;
  font-size:0.875rem;
  background:transparent;
  color:var(--ink-soft,#b4b9bd);
  box-sizing:border-box;
  font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;
}

.table-wrapper th {
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  padding:12px 16px;
  box-sizing:border-box;
  background:rgba(255,255,255,0.03) !important;
  color:var(--ink,#f3f5f6) !important;
  font-weight:600;
  text-transform:uppercase;
  font-size:0.75rem;
  letter-spacing:0.05em;
  border-bottom:1px solid rgba(255,255,255,0.1);
  position:sticky;
  top:0;
  z-index:5;
  text-align:left;
}

.table-wrapper td {
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  max-width:200px;
  padding:12px 16px;
  box-sizing:border-box;
  border-bottom:1px solid rgba(255,255,255,0.05);
  color:var(--ink-soft,#b4b9bd) !important;
  line-height:1.5;
  background:transparent;
  font-size:0.875rem;
}

.table-wrapper td.wrap,
.table-wrapper th.wrap {
  white-space:normal;
  word-wrap:break-word;
  overflow-wrap:break-word;
  max-width:none;
  min-width:120px;
}

.table-wrapper td.num {
  text-align:right;
  font-variant-numeric:tabular-nums;
  font-family:'SF Mono',Monaco,'Cascadia Code','Roboto Mono',Consolas,'Courier New',monospace;
}

.table-wrapper tbody tr {
  transition:background-color 0.15s ease;
}

.table-wrapper tbody tr:hover {
  background:rgba(255,255,255,0.05) !important;
}

.table-wrapper tbody tr:nth-child(even) {
  background:rgba(255,255,255,0.02);
}
.plot-title {
  font-size:1rem;
  color:var(--fev-red,#c30c36);
  margin:0 0 16px 0;
  letter-spacing:-0.01em;
  font-weight:600;
  line-height:1.5;
  word-wrap:break-word;
  overflow-wrap:break-word;
}

.report-grid { 
  display:grid; 
  grid-template-columns:1fr; 
  gap:20px;
  width:100%;
  max-width:100%;
  box-sizing:border-box;
  padding:0;
  margin:0;
}

.report-grid.two-col { 
  grid-template-columns:minmax(0,1.618fr) minmax(0,1fr);
  gap:20px;
}

@media (max-width: 1400px) {
  .report-grid.two-col {
    grid-template-columns:1fr;
  }
}

.report-col { 
  display:flex; 
  flex-direction:column; 
  gap:20px;
  min-width:0;
  max-width:100%;
  box-sizing:border-box;
  width:100%;
  overflow:visible;
}

.accent-panel {
  background:linear-gradient(175deg,rgba(195,12,54,0.15),rgba(195,12,54,0.08));
  color:#fff;
  border:1px solid rgba(195,12,54,0.2);
  border-radius:12px;
  padding:20px;
  box-shadow:0 2px 8px rgba(195,12,54,0.1);
  box-sizing:border-box;
  width:100%;
  max-width:100%;
  min-width:0;
  overflow:visible;
  transition:box-shadow 0.2s ease, border-color 0.2s ease;
}

.accent-panel:hover {
  box-shadow:0 4px 12px rgba(195,12,54,0.15);
  border-color:rgba(195,12,54,0.3);
}

body.light-theme .accent-panel:hover {
  box-shadow:0 4px 12px rgba(0,0,0,0.12);
  border-color:#d1d9e0;
}
#channels-container {
  -webkit-backdrop-filter: blur(3px);
  backdrop-filter: blur(3px);
  background:linear-gradient(165deg,#1b2126,#161b20);
  border:1px solid #394046;
  box-shadow:inset 0 0 0 1px #262d32,0 2px 10px -4px rgba(0,0,0,.55);
  max-height:300px;
  overflow:auto;
  margin-top:10px;
  position:relative;
}
#channels-container.loading::after {
  content:'Loading...'; position:absolute; top:4px; right:10px;
  font-size:.58rem; letter-spacing:.1em; color:var(--ink-soft); opacity:.7;
}
.overlay-spinner {
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  background:rgba(15,18,22,.55); 
  -webkit-backdrop-filter: blur(4px);
  backdrop-filter:blur(4px); 
  z-index:40;
}
@keyframes spin { to { transform:rotate(360deg); } }
#toast-container {
  position:fixed; bottom:16px; right:16px; display:flex; flex-direction:column;
  gap:10px; z-index:500; max-width:340px;
}
.toast {
  background:#1f262b; border:1px solid #3d454c; color:var(--ink-soft);
  padding:10px 14px; font-size:.68rem; border-radius:14px;
  box-shadow:0 6px 18px -6px rgba(0,0,0,.55);
  animation:fadeIn .3s ease; line-height:1.25; position:relative;
}
.toast.success { border-color:var(--ok); color:var(--ok); }
.toast.error { border-color:var(--danger); color:var(--danger); }
@keyframes fadeIn { from { opacity:0; transform:translateY(6px);} to {opacity:1; transform:translateY(0);} }
.status::-webkit-scrollbar,
#channels-container::-webkit-scrollbar { width:10px; }
.status::-webkit-scrollbar-track,
#channels-container::-webkit-scrollbar-track { background:#1a1f24; }
.status::-webkit-scrollbar-thumb,
#channels-container::-webkit-scrollbar-thumb { background:#333b42; border-radius:10px; }
.status::-webkit-scrollbar-thumb:hover,
#channels-container::-webkit-scrollbar-thumb:hover { background:#48535c; }
.hidden { display:none !important; }
.text-right { text-align:right; }
.badge:focus-visible, .chip:focus-visible, button:focus-visible {
  outline:2px solid var(--focus); outline-offset:2px;
}
::selection { background:var(--acc); color:#fff; }
.copy-buttons { 
  display:flex; 
  gap:8px; 
  flex-wrap:wrap; 
  margin:8px 0 4px; 
  box-sizing: border-box;
  width: 100%;
  max-width: 100%;
  overflow: visible;
}
.copy-buttons button {
  font-size:0.75rem; 
  padding:8px 16px; 
  background:transparent;
  border:1px solid var(--muted-border); 
  color:var(--ink);
  box-sizing: border-box;
  flex-shrink: 0;
  border-radius: var(--radius-sm);
  min-height: 36px;
  font-weight: 500;
  transition: all var(--transition-fast);
}
.copy-buttons button:hover { 
  background:rgba(255, 255, 255, 0.05);
  border-color: var(--fev-red);
  color: var(--fev-red-light);
}

/* Full-width subplot helpers */
.span-full { grid-column: 1 / -1 !important; }
.plot-host, .plot-host .js-plotly-plot, .plot-host .plot-container {
  width:100% !important;
  max-width:100% !important;
}

/* Playground specific styles */
#playground { 
  background: var(--card); 
  margin: 20px; 
  border-radius: var(--radius); 
  border: var(--card-border); 
  padding: 18px; 
  transition: background var(--transition), border-color var(--transition);
}

.playground-wrap {
  display: grid;
  grid-template-columns: 360px 1fr;
  gap: 16px;
}

.playground-controls {
  background: transparent;
  padding: 0;
  border-radius: 0;
  overflow-y: auto;
  overflow-x: hidden;
  max-height: calc(100vh - 200px);
  padding-right: 8px;
  box-sizing: border-box;
}

.playground-controls::-webkit-scrollbar {
  width: 8px;
}

.playground-controls::-webkit-scrollbar-track {
  background: transparent;
}

.playground-controls::-webkit-scrollbar-thumb {
  background: var(--muted);
  border-radius: 4px;
}

.playground-controls::-webkit-scrollbar-thumb:hover {
  background: var(--muted-soft);
}

.playground-row {
  display: grid;
  grid-template-columns: 120px 1fr;
  gap: 12px;
  align-items: center;
  margin-bottom: 12px;
  min-width: 0; /* Prevent overflow */
}

.playground-row.full-width {
  grid-template-columns: 1fr;
}

.playground-row label {
  color: var(--ink);
  font-size: 0.75rem;
  font-weight: 500;
  opacity: 0.95;
  word-wrap: break-word;
  overflow-wrap: break-word;
  white-space: normal;
  line-height: 1.4;
  flex-shrink: 0;
}

.playground-row select, 
.playground-row input {
  width: 100%;
  min-width: 0;
  padding: 8px 10px;
  border-radius: 6px;
  border: var(--input-border);
  background: var(--input-bg);
  color: var(--ink);
  font-size: 0.8125rem;
  transition: border-color var(--transition), box-shadow var(--transition);
  box-sizing: border-box;
}

.playground-row select:focus, 
.playground-row input:focus {
  outline: none;
  border-color: var(--focus);
  box-shadow: var(--input-focus-glow);
}

.playground-row input[type="checkbox"] {
  width: auto;
  margin-left: auto;
  cursor: pointer;
}

@media (max-width: 968px) {
  .playground-row {
    grid-template-columns: 1fr;
    gap: 6px;
  }
  
  .playground-row label {
    margin-bottom: 4px;
  }
}

/* UniPlot look (light paper) */
#pg-canvas.uniplot-light {
  background: #fff;
}

.pg-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  margin-bottom: 24px;
  padding: 16px 20px;
  background: var(--panel);
  border-radius: 12px;
  border: 1px solid var(--muted);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.08);
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
}

.pg-toolbar:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
  border-color: var(--muted-soft);
}

.pg-toolbar button {
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid var(--muted);
  color: var(--ink);
  padding: 8px 16px;
  font-size: 0.8125rem;
  font-weight: 500;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;
  min-height: 36px;
}

.pg-toolbar button:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--muted-soft);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.pg-toolbar button.primary {
  background: var(--acc);
  border-color: var(--acc);
  color: #fff;
}

.pg-toolbar button.primary:hover {
  background: var(--acc-soft);
  border-color: var(--acc-soft);
  box-shadow: 0 2px 4px rgba(195, 12, 54, 0.3);
}

.pg-toolbar button.secondary {
  background: rgba(255, 255, 255, 0.04);
}

.pg-toolbar button:active {
  transform: translateY(1px);
}

.pg-toolbar select {
  background: var(--input-bg);
  border: 1px solid var(--muted);
  color: var(--ink);
  padding: 8px 12px;
  font-size: 0.8125rem;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  min-height: 36px;
}

.pg-toolbar select:hover {
  border-color: var(--muted-soft);
}

.pg-toolbar select:focus {
  outline: none;
  border-color: var(--focus);
  box-shadow: var(--input-focus-glow);
}

@media (max-width: 768px) {
  .pg-toolbar {
    flex-direction: column;
    align-items: stretch;
  }
  
  .pg-toolbar button,
  .pg-toolbar select {
    width: 100%;
    justify-content: center;
  }
}

.pg-status {
  font-size: 0.8125rem;
  opacity: 0.85;
  padding: 8px 12px;
  border-radius: 6px;
  background: rgba(0,0,0,0.2);
  color: var(--ink);
  display: inline-block;
  margin-left: 8px;
  font-weight: 500;
  white-space: nowrap;
}

.pg-status.success {
  background: rgba(67, 160, 71, 0.2);
  color: #43a047;
}

.pg-status.error {
  background: rgba(229, 57, 53, 0.2);
  color: #e53935;
}

/* Responsive adjustments */
@media (max-width: 1024px) {
  .playground-wrap {
    grid-template-columns: 1fr;
  }
  
  .split {
    grid-template-columns: 1fr;
  }
  
  .report-grid.two-col {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 768px) {
  section {
    margin: 10px;
    padding: 15px;
  }
  
  header {
    padding: 12px 16px;
  }
  
  .flex {
    flex-direction: column;
  }
  
  .tabs {
    margin: 10px;
  }
  
  .tabs button {
    padding: 6px 10px;
    font-size: 12px;
    margin-bottom: 5px;
  }
}

/* Zoom-level fixes for Chrome 80-120% zoom compatibility */
/* Ensure report section content remains visible at all zoom levels */
#sec-report {
  overflow-x: auto;
  overflow-y: visible;
  min-width: 0;
}

#sec-report > div {
  box-sizing: border-box;
  width: 100%;
  max-width: 100%;
  overflow: visible;
}

/* Report section containers */
#report-dfc, #report-iupr, #report-gear, #report-misfire, #report-ccsl, #report-map {
  box-sizing: border-box;
  width: 100%;
  max-width: 100%;
  overflow: visible;
  min-width: 0;
}

/* Ensure plot panels scale with zoom */
.plot-panel {
  box-sizing:border-box;
  width:100% !important;
  max-width:100% !important;
  min-width:0;
  overflow:hidden;
  background:var(--panel,#1f2428);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:12px;
  padding:20px;
  box-shadow:0 1px 3px rgba(0,0,0,0.12),0 1px 2px rgba(0,0,0,0.24);
  transition:box-shadow 0.2s ease, border-color 0.2s ease;
  position:relative;
}

.plot-panel:hover {
  box-shadow:0 4px 6px rgba(0,0,0,0.15),0 2px 4px rgba(0,0,0,0.12);
  border-color:rgba(255,255,255,0.12);
}

.plot-panel .plotly-graph-div {
  width:100% !important;
  max-width:100% !important;
  box-sizing:border-box;
  overflow:hidden;
  border-radius:8px;
  background:transparent;
}

/* Professional Text Wrapping - No Overflow */
.report-col .table-card,
.report-col .plot-panel,
.report-col .accent-panel {
  word-wrap:break-word;
  overflow-wrap:break-word;
  hyphens:auto;
}

.report-col .status {
  word-wrap:break-word;
  overflow-wrap:break-word;
  max-width:100%;
  box-sizing:border-box;
  padding:16px;
  border-radius:8px;
  line-height:1.6;
  font-size:0.875rem;
}

/* Empty State Styling */
.report-col .small {
  font-size:0.813rem;
  color:var(--ink-soft,#8b949e);
  line-height:1.5;
  padding:12px 0;
  word-wrap:break-word;
  overflow-wrap:break-word;
}

/* Responsive Improvements */
@media (max-width:768px) {
  .report-grid {
    gap:16px;
  }
  
  .report-col {
    gap:16px;
  }
  
  .table-card,
  .plot-panel,
  .accent-panel {
    padding:16px;
  }
  
  .subtabs {
    gap:6px;
  }
  
  .subtabs button {
    padding:8px 14px;
    font-size:0.813rem;
    min-height:36px;
  }
}

/* Professional Section Container Improvements */
#sec-report, #sec-analyse {
  position:relative;
  box-sizing:border-box;
}

#sec-report h2, #sec-analyse h2 {
  margin-bottom:20px;
  font-size:1.5rem;
  font-weight:600;
  letter-spacing:-0.02em;
  color:var(--ink,#f3f5f6);
  line-height:1.3;
}

/* Analytics Section Specific Improvements */
#sec-analyse label {
  display:block;
  margin-bottom:8px;
  font-size:0.875rem;
  font-weight:500;
  color:var(--ink,#d4d9dd);
  line-height:1.5;
}

#sec-analyse input[type="text"],
#sec-analyse input[type="number"],
#sec-analyse select {
  width:100%;
  padding:10px 12px;
  background:var(--input-bg,#1f2428);
  border:1px solid rgba(255,255,255,0.1);
  border-radius:8px;
  color:var(--ink,#f3f5f6);
  font-size:0.875rem;
  transition:border-color 0.2s ease,background-color 0.2s ease;
  box-sizing:border-box;
}

#sec-analyse input[type="text"]:focus,
#sec-analyse input[type="number"]:focus,
#sec-analyse select:focus {
  outline:none;
  border-color:var(--acc,#c30c36);
  background:rgba(195,12,54,0.05);
}

#sec-analyse .status {
  word-wrap:break-word;
  overflow-wrap:break-word;
  max-width:100%;
  box-sizing:border-box;
  line-height:1.6;
}

#sec-report .flex {
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  margin-bottom:16px;
  box-sizing:border-box;
  width:100%;
  max-width:100%;
}

#sec-report button:not(.subtabs button) {
  padding:10px 20px;
  font-size:0.875rem;
  font-weight:500;
  border-radius:8px;
  transition:all 0.2s cubic-bezier(0.4,0,0.2,1);
  white-space:nowrap;
  box-sizing:border-box;
  min-height:40px;
}

#report-timestamp {
  font-size:0.875rem;
  color:var(--ink-soft,#8b949e);
  margin:12px 0;
  padding:8px 0;
  word-wrap:break-word;
  overflow-wrap:break-word;
  max-width:100%;
  box-sizing:border-box;
  line-height:1.5;
}


/* Report Section Containers */
[id^="report-"] {
  width:100%;
  max-width:100%;
  box-sizing:border-box;
  overflow:visible;
  position:relative;
  padding:0;
  margin:0;
}

/* Animation for smooth transitions */
.fade-in {
  animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.slide-down {
  animation: slideDown 0.3s ease;
}

@keyframes slideDown {
  from { 
    opacity: 0;
    transform: translateY(-10px);
  }
  to { 
    opacity: 1;
    transform: translateY(0);
  }
}

/* Loading spinner */
.spinner {
  width: 24px;
  height: 24px;
  border: 3px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  border-top-color: #fff;
  animation: spin 1s ease-in-out infinite;
  display: inline-block;
}

.btn-loading {
  position: relative;
  color: transparent !important;
}

.btn-loading::after {
  content: '';
  position: absolute;
  width: 16px;
  height: 16px;
  top: 50%;
  left: 50%;
  margin: -8px 0 0 -8px;
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  border-top-color: #fff;
  animation: spin 1s ease-in-out infinite;
}

/* ========== THRESHOLD STYLING ========== */
.threshold-section {
  background: var(--panel);
  border: 1px solid var(--muted);
  border-radius: var(--radius);
  padding: 16px;
  margin-top: 20px;
}

.threshold-controls {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr auto;
  gap: 12px;
  align-items: end;
}

.threshold-controls button {
  white-space: nowrap;
}

.threshold-hint {
  font-size: 0.7rem;
  color: var(--ink-soft);
  margin-top: 8px;
}

.threshold-highlight {
  fill: rgba(255, 0, 0, 0.2);
  stroke-width: 0;
}

/* Improved hover styling for Edge compatibility */
.plotly-graph-div .hovertext {
  background-color: rgba(255, 255, 255, 0.95) !important;
  border: 1px solid #ddd !important;
  border-radius: 4px !important;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1) !important;
  padding: 8px 12px !important;
  font-family: "Segoe UI", Roboto, Inter, Arial, sans-serif !important;
}

.plotly-graph-div .axistext {
  font-weight: 600 !important;
}

/* Crosshair styling */
.crosshair {
  stroke: #ff6f8a;
  stroke-width: 1;
  stroke-dasharray: 3,3;
}

/* Enhanced hover behavior for Edge */
.plot-container .hoverlayer .hovertext {
  -webkit-backdrop-filter: blur(2px);
  backdrop-filter: blur(2px);
}

/* Threshold highlight areas */
.threshold-area {
  opacity: 0.3;
  mix-blend-mode: multiply;
}

/* New Playground Styles */
.playground-section {
 margin-bottom: 20px;
 padding-bottom: 15px;
 border-bottom: 1px solid var(--muted);
}
.playground-section h4 {
 font-size: 0.8rem;
 margin-bottom: 12px;
 color: var(--fev-red);
 text-transform: uppercase;
 letter-spacing: 0.05em;
}
#pg-canvas-container {
 position: relative;
 background: var(--card);
 border-radius: 12px;
 border: 1px solid var(--muted);
 box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), 0 1px 3px rgba(0, 0, 0, 0.1);
 transition: box-shadow 0.3s ease, border-color 0.3s ease;
 padding: 16px;
 min-height: clamp(450px, 55vh, 700px);
 display: flex;
 flex-direction: column;
 overflow: hidden;
}

#pg-canvas-container:hover {
 box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2), 0 2px 6px rgba(0, 0, 0, 0.15);
 border-color: var(--muted-soft);
}

#pg-canvas-container:focus-within {
 border-color: var(--focus, var(--accent));
 box-shadow: 0 0 0 3px rgba(var(--accent-rgb, 59, 130, 246), 0.1);
}

#pg-3d-indicator {
 z-index: 10;
 pointer-events: none;
 position: absolute;
 top: 16px;
 right: 16px;
 padding: 6px 12px;
 background: rgba(var(--accent-rgb, 59, 130, 246), 0.9);
 backdrop-filter: blur(8px);
 border-radius: 6px;
 font-size: 0.75rem;
 font-weight: 600;
 letter-spacing: 0.05em;
 text-transform: uppercase;
 box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
 animation: fadeIn 0.3s ease;
}
.playground-controls {
 max-height: 80vh;
 overflow-y: auto;
 padding-right: 8px;
}
.playground-controls::-webkit-scrollbar {
 width: 8px;
}
.playground-controls::-webkit-scrollbar-track {
 background: var(--input-bg);
 border-radius: 4px;
}
.playground-controls::-webkit-scrollbar-thumb {
 background: var(--muted);
 border-radius: 4px;
}
.playground-controls::-webkit-scrollbar-thumb:hover {
 background: var(--fev-grey);
}

/* ---- Select preview chip style (match the X field look) ---- */
.select-preview {
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  border-radius:6px;
  background: var(--input-bg);
  border:var(--input-border);
  min-height:38px;
  color:var(--ink);
  font-weight:500;
  font-size:0.8125rem;
  -webkit-user-select: none;
  user-select:none;
  pointer-events: auto;
  cursor: pointer;
  transition: all 0.2s ease;
  box-sizing: border-box;
  width: 100%;
  min-width: 0;
}

.select-preview:hover {
  border-color: var(--muted-soft);
  background: rgba(255, 255, 255, 0.04);
}

.select-preview:focus {
  outline: none;
  border-color: var(--focus);
  box-shadow: var(--input-focus-glow);
}

.select-preview .label {
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  flex: 1;
  min-width: 0;
}
.select-preview .muted {
  color:var(--ink-soft);
  font-weight:500;
  font-size:0.85em;
}
.select-preview .caret {
  margin-left:auto;
  opacity:0.8;
  font-size:0.9em;
}

/* --- FIX for custom select wrapper --- */
.select-wrapper { 
  position:relative; 
  display:block; 
  width: 100%;
  min-width: 0;
  box-sizing: border-box;
}
.select-wrapper select.hidden-native-select {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  z-index: 30; /* ensure it is above preview */
  cursor: pointer;
  pointer-events: auto;
}


/* Responsive adjustments */
@media (max-width: 1400px) {
 .playground-wrap {
   grid-template-columns: 300px 1fr;
 }
}
@media (max-width: 1200px) {
 .playground-wrap {
   grid-template-columns: 1fr;
 }
 .playground-controls {
   max-height: 400px;
   margin-bottom: 20px;
 }
}

/* Zoom-specific adjustments for Chrome 80-125% */
@media screen {
  /* Ensure plots maintain visibility at 80% zoom */
  html[style*="zoom: 0.8"], html[style*="zoom: 80%"] {
    .plot-panel {
      min-height: 400px;
    }
    .plot-panel .plotly-graph-div {
      min-height: 360px !important;
    }
  }
  
  /* Optimize for 125% zoom */
  html[style*="zoom: 1.25"], html[style*="zoom: 125%"] {
    .plot-panel {
      max-height: 850px;
    }
    .table-wrapper table {
      min-width: 600px;
    }
  }
}

/* Additional responsive adjustments for viewport-based scaling */
@supports (height: clamp(1px, 1vh, 100px)) {
  .plot-panel {
    height: clamp(400px, 50vh, 750px);
  }
  .plot-container {
    min-height: clamp(450px, 55vh, 700px);
  }
}

/* Override for subplot view in analytics to prevent page expansion */
#analytics-plot-panel.subplots-active {
  height: clamp(500px, 65vh, 900px) !important; /* Responsive height for subplots at different zoom levels */
  min-height: 500px !important;
  max-height: 900px !important;
}
#analytics-plot.subplots-active {
  overflow-y: auto; /* Add a scrollbar if subplots overflow */
  max-height: 100%;
}

/* ================================================================ */
/* ============= PROFESSIONAL PLOT STYLING (NEW) ================ */
/* ================================================================ */

/* This is the main container for a plot. Responsive sizing for zoom levels 80-125% */
.plot-panel {
  box-sizing: border-box;
  width: 100%;
  max-width: 100%;
  /* Responsive height that scales well with browser zoom */
  height: clamp(350px, 45vh, 700px);
  min-height: 350px;
  max-height: 700px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.06);
  background: var(--card, #1c1c1c);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
  overflow: hidden; /* CRITICAL: Prevents content from spilling out */
  padding: 12px;
  margin-bottom: 18px;
  position: relative;
  display: flex;
  flex-direction: column;
  /* Ensure proper scaling at different zoom levels */
  transform-origin: top left;
}

/* The title inside the plot panel */
/* Plot title styling is defined above in .plot-title */

/* This is the div that Plotly draws into. It must fill the panel. */
.plot-panel .plotly-graph-div {
  width: 100% !important;   /* Fill the container width */
  height: 100% !important;  /* Fill the remaining height */
  min-height: 320px !important; /* Minimum visible height at 80% zoom */
  max-height: 100% !important;
  flex-grow: 1; /* Allow it to grow to fill space */
  flex-shrink: 1;
  border: none !important; /* Override base plotly-graph-div styles */
  box-shadow: none !important;
  padding: 0 !important;
  box-sizing: border-box;
  /* Ensure Plotly container scales correctly */
  position: relative;
  overflow: hidden;
}

/* Note: analytics-plot-panel subplots-active styles moved to zoom-specific section above */

/* Add these styles to the existing CSS */
@media (max-width: 768px) {
 .playground-wrap {
   grid-template-columns: 1fr;
   gap: 12px;
 }
 .playground-controls {
   max-height: 50vh;
   overflow-y: auto;
 }
 .playground-row {
   grid-template-columns: 1fr;
   gap: 6px;
 }
 .playground-row label {
   margin-bottom: 4px;
 }
 .pg-toolbar {
   flex-direction: column;
   align-items: stretch;
   gap: 8px;
 }
 .pg-toolbar button,
 .pg-toolbar select {
   width: 100%;
   margin-bottom: 5px;
 }
 #pg-canvas-container {
   min-height: 300px;
 }
 /* Improve 3D help text on mobile */
 #pg-3d-help {
   font-size: 10px !important;
   padding: 3px 6px !important;
   bottom: 5px !important;
   right: 5px !important;
 }
}
/* Better touch support for mobile devices */
@media (hover: none) and (pointer: coarse) {
 .plotly-graph-div .modebar {
   padding: 5px;
 }
 .modebar-btn {
   padding: 8px;
   margin: 2px;
 }
 /* Improve touch targets */
 button, select, input {
   min-height: 44px;
 }
 .chip {
   padding: 8px 12px;
 }
}
/* Prevent zoom on input focus on mobile */
@media (max-width: 768px) {
 input[type="text"],
 input[type="number"],
 select,
 textarea {
   font-size: 16px; /* Prevents zoom on focus in iOS */
 }
}

/* container style for the Report heatmap(s) */
#empirical-map-panel-old {
  margin-top: 18px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.04);
  background: rgba(20,22,25,0.6);
  padding: 12px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
}
#empirical-map-title { font-weight:700; color:#ff6f8a; margin-bottom:6px; }
#empirical-heatmap { width:100%; height:520px; }
#empirical-surface { width:100%; height:520px; display:none; margin-top:12px; }
.empirical-map-msg { color:#9fb3d4; font-size:13px; padding:10px 6px; }
@media (max-width:900px){ #empirical-heatmap, #empirical-surface { height:360px; } }

/* Ensure map plot panels are properly sized for zoom levels 80-125% */
#map-heatmap, #map-surface {
  width: 100% !important;
  height: clamp(400px, 50vh, 700px) !important;
  min-height: 400px !important;
  max-height: 700px !important;
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
}

/* Map plot containers must fill parent */
#map-heatmap .plotly,
#map-surface .plotly {
  width: 100% !important;
  height: 100% !important;
  min-height: 380px !important;
}

/* Styles for the new custom map controls */
#map-controls {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  background: var(--panel);
  padding: 16px;
  border-radius: var(--radius);
  margin-bottom: 20px;
}
#map-file-list {
  max-height: 120px;
  overflow-y: auto;
  background: var(--input-bg);
  border: var(--input-border);
  border-radius: var(--radius-sm);
  padding: 8px;
}
#map-file-list div {
  display: flex;
  align-items: center;
  gap: 8px;
}
#map-file-list label {
  font-size: 13px;
  font-weight: normal;
  text-transform: none;
  letter-spacing: normal;
}
#map-controls button {
  align-self: end;
}

/* New Map Result Styles */
.map-display-controls {
  display: flex;
  gap: 8px;
  margin-bottom: 15px;
}

.map-view-btn {
  padding: 8px 16px;
  background: var(--input-bg);
  border: 1px solid var(--muted);
  border-radius: 5px;
  color: var(--ink);
  cursor: pointer;
  font-size: 13px;
  transition: all 0.2s;
}

.map-view-btn:hover {
  background: var(--acc-soft);
  color: white;
}

.map-view-btn.active {
  background: var(--acc);
  color: white;
  border-color: var(--acc);
}

.professional-plot {
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.plot-controls {
  display: flex;
  gap: 15px;
  padding: 10px;
  background: #f8f9fa;
  border-bottom: 1px solid #e9ecef;
  border-radius: 8px 8px 0 0;
}

.stat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 15px;
  margin-top: 15px;
}

.stat-card {
  background: var(--panel);
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  border: 1px solid var(--muted);
}

.stat-value {
  font-size: 24px;
  font-weight: bold;
  color: var(--acc);
}

.stat-label {
  font-size: 14px;
  color: var(--ink-soft);
  margin-top: 5px;
}

/* Enhanced Playground Styles - Google-style minimal, responsive */
.playground-container {
  display: grid;
  grid-template-columns: minmax(320px, 380px) 1fr;
  gap: 20px;
  height: calc(100vh - 180px);
  min-height: 600px;
  width: 100%;
  max-width: 100%;
  overflow: hidden;
  padding: 0;
}

@media (max-width: 1200px) {
  .playground-container {
    grid-template-columns: minmax(280px, 340px) 1fr;
    gap: 16px;
  }
}

@media (max-width: 968px) {
  .playground-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto 1fr;
    height: auto;
    min-height: calc(100vh - 180px);
  }
  
  .playground-controls {
    max-height: 400px;
    overflow-y: auto;
    border-bottom: 1px solid var(--muted);
    margin-bottom: 16px;
  }
  
  .playground-vis {
    min-height: 500px;
  }
}

.control-section {
  background: var(--panel);
  border-radius: 8px;
  padding: 16px;
  border: 1px solid var(--muted);
  margin-bottom: 12px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
  transition: box-shadow 0.2s ease, border-color 0.2s ease;
}

.control-section:hover {
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.18);
  border-color: var(--muted-soft);
}

.control-section h4 {
  margin-top: 0;
  margin-bottom: 14px;
  padding-bottom: 10px;
  border-bottom: 1px solid var(--muted-soft);
  font-size: 0.8125rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--fev-red);
  display: flex;
  justify-content: space-between;
  align-items: center;
  word-wrap: break-word;
  overflow-wrap: break-word;
  line-height: 1.4;
}

.control-section.collapsed .section-content {
  display: none;
}

.toggle-section {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid var(--muted);
  border-radius: 4px;
  color: var(--ink-soft);
  cursor: pointer;
  padding: 4px 8px;
  font-size: 0.875rem;
  font-weight: 600;
  min-width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.toggle-section:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--muted-soft);
  color: var(--ink);
}

.playground-vis {
  background: transparent;
  border-radius: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  position: relative;
  height: 100%;
  min-height: 0;
  overflow: hidden;
  gap: 0;
}

.plot-container {
  flex: 1 1 auto;
  min-height: clamp(450px, 55vh, 650px);
  max-height: none;
  position: relative;
  width: 100%;
  box-sizing: border-box;
  overflow: hidden;
  background: var(--card);
  border-radius: 12px;
  border: 1px solid var(--muted);
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12), 0 1px 3px rgba(0, 0, 0, 0.08);
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  flex-direction: column;
}

.plot-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--muted-soft), transparent);
  opacity: 0.5;
}

.plot-container:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18), 0 2px 8px rgba(0, 0, 0, 0.12);
  border-color: var(--muted-soft);
  transform: translateY(-1px);
}

.plot-container .plotly-graph-div {
  width: 100% !important;
  height: 100% !important;
  min-height: clamp(400px, 50vh, 600px) !important;
  position: relative;
  box-sizing: border-box;
  overflow: hidden;
  border-radius: 8px;
  background: transparent;
  transition: opacity 0.3s ease;
}

.plot-container .plotly-graph-div.js-plotly-plot {
  width: 100% !important;
  height: 100% !important;
  min-height: clamp(400px, 50vh, 600px) !important;
}

/* Loading state for plots */
.plot-container.loading::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 40px;
  height: 40px;
  margin: -20px 0 0 -20px;
  border: 3px solid var(--muted);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  z-index: 5;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@media (max-width: 968px) {
  .plot-container {
    min-height: 400px;
  }
  
  .plot-container .plotly-graph-div {
    min-height: 380px !important;
  }
}

/* Ensure plotly containers don't overflow */
.plot-container .plotly-notifier {
  display: none;
}

.trace-manager {
  background: var(--panel);
  border-radius: 8px;
  padding: 16px;
  margin-top: 16px;
  border: 1px solid var(--muted);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
}

.trace-manager h4 {
  margin-top: 0;
  margin-bottom: 12px;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--ink);
  text-transform: none;
  letter-spacing: 0;
}

.trace-list {
  max-height: 220px;
  overflow-y: auto;
  overflow-x: hidden;
  margin-top: 10px;
  padding-right: 4px;
}

.trace-list::-webkit-scrollbar {
  width: 6px;
}

.trace-list::-webkit-scrollbar-thumb {
  background: var(--muted);
  border-radius: 3px;
}

.trace-list::-webkit-scrollbar-thumb:hover {
  background: var(--muted-soft);
}

.trace-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  margin-bottom: 8px;
  font-size: 0.8125rem;
  word-wrap: break-word;
  overflow-wrap: break-word;
  min-width: 0;
  gap: 8px;
}

.trace-item > * {
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
}

.trace-item:hover {
  background: rgba(255, 255, 255, 0.1);
}

.trace-actions {
  display: flex;
  gap: 8px;
}

.trace-actions button {
  padding: 2px 6px;
  font-size: 0.7rem;
  background: none;
  border: 1px solid var(--muted);
  border-radius: 3px;
  color: var(--ink-soft);
}

.advanced-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.preset-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 10px;
}

.preset-btn {
  padding: 10px 12px;
  font-size: 0.8125rem;
  font-weight: 500;
  text-align: center;
  background: var(--input-bg);
  border: 1px solid var(--muted);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
  color: var(--ink);
  word-wrap: break-word;
  overflow-wrap: break-word;
  white-space: normal;
  line-height: 1.4;
}

.preset-btn:hover {
  background: var(--acc-soft);
  color: white;
  border-color: var(--acc-soft);
  box-shadow: 0 2px 4px rgba(195, 12, 54, 0.2);
}

.preset-btn.active {
  background: var(--acc);
  color: white;
  border-color: var(--acc);
  box-shadow: 0 2px 6px rgba(195, 12, 54, 0.3);
}

.preset-btn:active {
  transform: translateY(1px);
}

.camera-controls {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 8px;
}

.camera-control {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.camera-control label {
  font-size: 0.7rem;
  color: var(--ink-soft);
}

.camera-control input {
  padding: 6px;
  font-size: 0.75rem;
}

.preview-content {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.preview-label {
  font-size: 0.8rem;
  font-weight: 600;
  color: var(--ink);
}

.preview-sub {
  font-size: 0.7rem;
  color: var(--ink-soft);
}

.preview-caret {
  color: var(--ink-soft);
}

.section-content {
  transition: all 0.3s ease;
}

.three-d-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid var(--muted-soft);
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

/* Add these styles to improve playground UI feedback */
.playground-controls .loading {
  opacity: 0.7;
  position: relative;
}

.playground-controls .loading::after {
  content: 'Loading channels...';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: var(--panel);
  padding: 10px 15px;
  border-radius: var(--radius-sm);
  z-index: 10;
  font-size: 0.8rem;
  color: var(--ink-soft);
}

.select-preview:not(.has-options) {
  opacity: 0.6;
  background: var(--input-bg);
}

.select-preview.has-options {
  background: linear-gradient(180deg,#111214,#14171a);
  cursor: pointer;
}

.no-channels-message {
  text-align: center;
  padding: 20px;
  color: var(--ink-soft);
  font-size: 0.9rem;
}

.no-channels-message a {
  color: var(--acc);
  text-decoration: underline;
  cursor: pointer;
}

.map-controls {
    background: var(--panel);
    padding: 16px;
    border-radius: var(--radius);
    margin-bottom: 16px;
    border: 1px solid var(--muted);
}

.map-controls h4 {
    margin-top: 0;
    margin-bottom: 16px;
    color: var(--fev-red);
}

.map-display-controls {
    display: flex;
    gap: 8px;
    margin-bottom: 16px;
}

.map-view-btn {
    padding: 8px 16px;
    background: var(--input-bg);
    border: 1px solid var(--muted);
    border-radius: 4px;
    color: var(--ink);
    cursor: pointer;
}

.map-view-btn.active {
    background: var(--acc);
    color: white;
    border-color: var(--acc);
}

/* NEW RESPONSIVE PLOT STYLES */
.plot-wrapper {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  box-sizing: border-box;
}

.plot-canvas {
  width: 100%;
  height: 620px;
  min-height: 420px;
  max-height: 1200px;
}

@media (min-width: 1400px) {
  .plot-canvas { height: 760px; }
}
@media (min-width: 1800px) {
  .plot-canvas { height: 920px; }
}

.plotly .svg-container { overflow: visible !important; }

/* Preset confidence panel */
.preset-confidence-panel {
  background: var(--panel);
  border: 1px solid #38424a;
  padding: 12px;
  border-radius: 8px;
  margin-top: 12px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.45);
}
.preset-confidence-header {
  display:flex; justify-content:space-between; align-items:center; gap:12px;
  border-bottom:1px solid rgba(255,255,255,0.03); padding-bottom:8px; margin-bottom:10px;
}
.preset-confidence-body { display:grid; grid-template-columns: repeat(3,1fr); gap:8px; }
.preset-confidence-item {
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0));
  border-radius:6px; padding:8px; border:1px solid rgba(255,255,255,0.02);
  display:flex; flex-direction:column; gap:6px; min-height:58px;
}
.preset-confidence-item .role { font-size:12px; color:var(--ink-soft); }
.preset-confidence-item .channel { font-weight:700; font-size:13px; color:var(--ink); }
.preset-confidence-item.good { border-left:4px solid var(--ok); }
.preset-confidence-item.fuzzy { border-left:4px solid var(--warn); opacity:0.95; }
.preset-confidence-item.missing { border-left:4px solid var(--danger); }

/* Modal basics (small floating modal) */
.modal.hidden { display:none !important; }
.modal { position:fixed; right:18px; bottom:18px; z-index:1200; width:380px; max-width:95%; }
.modal .modal-card { background:var(--card); padding:14px; border-radius:10px; border:1px solid var(--muted); box-shadow:var(--shadow); }
.modal h3 { margin:0 0 8px; color:var(--fev-red); font-size:14px; }
.modal select { width:100%; margin-top:6px; }

/* small buttons within panel */
.preset-confidence-actions button { margin-left:6px; }

/* PATCH: Render button loading spinner + small status area */
#pg-render.loading { opacity: 0.7; pointer-events: none; position: relative; }
#pg-render.loading::after{
  content: "";
  position: absolute;
  right: 10px;
  top: 50%;
  transform: translateY(-50%);
  width: 14px;
  height: 14px;
  border-radius: 50%;
  border: 2px solid rgba(255,255,255,0.18);
  border-top-color: rgba(255,255,255,0.95);
  animation: pg-spin 0.8s linear infinite;
  z-index: 5;
}
@keyframes pg-spin { to { transform: rotate(360deg); } }
#pg-status { display:inline-block; margin-left:12px; color:var(--ink-soft); font-size:0.9rem; vertical-align:middle; }
#pg-status.hidden { display:none; }
#pg-render.loading { opacity: .6; position: relative; pointer-events:none; }
#pg-render.loading::after {
  content: '';
  position: absolute;
  right: 10px; top: 50%;
  width: 14px; height: 14px; margin-top:-7px;
  border-radius: 50%;
  border: 2px solid rgba(255,255,255,.2);
  border-top-color: rgba(255,255,255,.9);
  animation: spin .8s linear infinite;
}

/* Validation Dashboard Styles */
.validation-dashboard {
  background: var(--panel);
  border: 1px solid var(--muted);
  border-radius: var(--radius);
  padding: 16px;
  margin: 16px 0;
}

.validation-file-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  margin: 4px 0;
  border-radius: 4px;
  border-left: 4px solid;
}

.validation-file-item.valid {
  background: rgba(34, 197, 94, 0.1);
  border-left-color: var(--ok);
}

.validation-file-item.warning {
  background: rgba(245, 158, 11, 0.1);
  border-left-color: var(--warn);
}

.validation-file-item.error {
  background: rgba(239, 68, 68, 0.1);
  border-left-color: var(--danger);
}

.validation-score {
  font-size: 1.2rem;
  font-weight: bold;
  margin: 8px 0;
}

.validation-score.good { color: var(--ok); }
.validation-score.warning { color: var(--warn); }
.validation-score.poor { color: var(--danger); }

.signal-suggestions {
  margin-top: 16px;
  padding: 12px;
  background: var(--input-bg);
  border-radius: 4px;
  border: 1px solid var(--muted);
}

.signal-suggestion-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  border-bottom: 1px solid var(--muted-soft);
}

.signal-suggestion-item:last-child {
  border-bottom: none;
}

.confidence-badge {
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.8rem;
  font-weight: bold;
}

.confidence-badge.high { background: var(--ok); color: white; }
.confidence-badge.medium { background: var(--warn); color: white; }
.confidence-badge.low { background: var(--danger); color: white; }

/* Progress Tracking Styles */
.map-progress {
  background: var(--panel);
  border: 1px solid var(--muted);
  border-radius: var(--radius);
  padding: 16px;
  margin: 16px 0;
}

.progress-stage {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  margin: 4px 0;
  border-radius: 4px;
  border-left: 4px solid;
  background: var(--input-bg);
}

.progress-stage.completed {
  border-left-color: var(--ok);
  background: rgba(34, 197, 94, 0.1);
}

.progress-stage.processing {
  border-left-color: var(--warn);
  background: rgba(245, 158, 11, 0.1);
}

.progress-stage.pending {
  border-left-color: var(--muted);
  background: var(--input-bg);
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: var(--muted);
  border-radius: 4px;
  overflow: hidden;
  margin: 8px 0;
}

.progress-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--ok), var(--warn));
  transition: width 0.3s ease;
}


</style>
</head>
<body>
<!-- Theme Toggle -->
<header>
  <h1>VEHICLELAB - Vehicle Diagnostic Lab</h1>
  <div class="fev-tagline">#FeelEVolution</div>

  <div class="theme-toggle" id="theme-toggle">
    <span>Dark</span>
    <div class="switch"></div>
    <span>Light</span>
  </div>
</header>

<div class="tabs" role="tablist">
  <button id="tabbtn-analyse" class="active" role="tab" aria-selected="true">Analyse</button>
  <button id="tabbtn-report" role="tab" aria-selected="false">Report</button>
  <button id="tabbtn-files" role="tab" aria-selected="false">Files</button>
  <button id="tabbtn-playground" role="tab" aria-selected="false">Playground</button>
</div>

<!-- Upload & Discover -->
<section id="sec-upload">
  <h2>Upload & Discover</h2>
  <div class="flex">
    <div style="flex:1 1 320px;min-width:260px">
      <div id="upload-drop" tabindex="0" aria-label="Drag and drop MDF/MF4/Excel/CSV files or press Enter to browse">
        <strong>Drag & Drop MDF/MF4/Excel/CSV</strong>
        <div style="opacity:.7">or click / Enter</div>
        <div id="upload-progress-bar"><div id="upload-progress"></div></div>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:8px">
          <span class="badge" id="badge-filecount">Files: 0</span>
          <span class="badge" id="badge-totalsize">Total: 0</span>
        </div>
        <div id="drop-msg" class="small" style="opacity:.55">Ready</div>
        <label for="files" class="sr-only">Upload data files</label>
        <input id="files" type="file" accept=".mf4,.mdf,.csv,.xlsx,.xls" multiple style="display:none">
      </div>
    </div>
    <div style="flex:2 1 520px;min-width:340px">
      <div class="flex" style="align-items:flex-end;gap:16px;flex-wrap:wrap">
        <div style="flex:0 0 auto;min-width:140px">
          <label for="mode">Mode</label>
          <select id="mode">
            <option value="union" selected>Union</option>
            <option value="intersection">Intersection</option>
          </select>
        </div>
        <div style="flex:0 0 auto;min-width:150px">
          <label for="downsample">Downsample Factor</label>
          <input id="downsample" type="number" value="10" min="1">
        </div>
        <div style="flex:0 0 auto;min-width:150px">
          <label for="max_points">Max Points</label>
          <input id="max_points" type="number" value="100000" min="100">
        </div>
        <div style="flex:1 0 auto;min-width:200px;display:flex;gap:8px;flex-wrap:wrap">
          <button id="btn-discover">Discover / Refresh</button>
          <button id="btn-clear" class="secondary" disabled>Clear Selected</button>
          <button id="btn-export-selected" class="secondary" disabled>Export IDs</button>
          <button id="btn-import-selected" class="secondary">Import IDs</button>
        </div>
        <label for="import-file" class="sr-only">Import signal IDs from file</label>
        <input id="import-file" type="file" accept=".txt,.csv" style="display:none">
      </div>
      <div style="margin-top:14px">
        <label for="channel-search">Search Signals</label>
        <input id="channel-search" type="text" placeholder="Filter signals..." autocomplete="off">
      </div>
      <div id="disc-status" class="status" style="margin-top:14px" aria-live="polite"></div>
    </div>
  </div>
  <div class="flex" style="justify-content:space-between;align-items:center;margin-top:14px">
    <span class="small" style="opacity:.75">Channels</span>
    <label class="small" style="display:flex;align-items:center;gap:4px">
      <input type="checkbox" id="toggle-only-selected" name="toggle-only-selected"> Show only selected
    </label>
  </div>
  <div id="channels-container" aria-label="Available signals list">
    <table>
      <thead>
        <tr>
          <th style="width:34px"><label for="select-all" class="sr-only">Select all visible signals</label><input type="checkbox" id="select-all" name="select-all"></th>
          <th>Signal</th>
          <th>Presence</th>
          <th style="text-align:right">Count</th>
        </tr>
      </thead>
      <tbody id="channels-body"></tbody>
    </table>
  </div>
  <div id="channel-controls" class="hidden" style="margin-top:8px;display:flex;gap:8px">
    <button id="btn-load-more" class="secondary icon-btn">Load More</button>
    <button id="btn-load-all" class="secondary icon-btn">Show All</button>
  </div>
  <textarea id="selected" readonly aria-label="Selected signal IDs" style="display:none"></textarea>
</section>

<!-- Analytics -->
<section id="sec-analyse">
  <h2>Analytics</h2>
  <div class="flex" style="flex-wrap:wrap;gap:16px;margin-bottom:20px;">
    <div style="flex:1 1 300px;min-width:280px">
      <label for="ana-signals">Signals (editable – subset of selected)</label>
      <input id="ana-signals" type="text" placeholder="Leave blank to use all selected" style="width:100%;box-sizing:border-box;">
      <div class="small" id="sig-source-hint" style="margin-top:6px;color:var(--ink-soft,#8b949e);">Auto-synced from selection.</div>
    </div>
    <div style="flex:1 1 300px;min-width:280px">
      <label>Plot Features</label>
      <div class="flex" style="gap:12px;padding-top:4px;flex-wrap:wrap">
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.875rem;"><input type="checkbox" id="feature-multiy" name="feature-multiy" style="cursor:pointer;">Multi Y</label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.875rem;"><input type="checkbox" id="feature-subplots" name="feature-subplots" style="cursor:pointer;">Subplots</label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.875rem;"><input type="checkbox" id="feature-subplot-ticks" name="feature-subplot-ticks" checked style="cursor:pointer;">Y Ticks</label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.875rem;"><input type="checkbox" id="feature-fft" name="feature-fft" style="cursor:pointer;">FFT</label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.875rem;"><input type="checkbox" id="feature-hist" name="feature-hist" style="cursor:pointer;">Histogram</label>
      </div>
      <div class="small" style="margin-top:8px;color:var(--ink-soft,#8b949e);">Subplot ticks toggle affects only Subplots mode.</div>
    </div>
    <div style="width:160px;min-width:140px">
      <label for="tickmode">Tickmode</label>
      <select id="tickmode" style="width:100%;box-sizing:border-box;">
        <option value="auto">Auto</option>
        <option value="linear">Linear</option>
        <option value="array">Array</option>
      </select>
    </div>
    <div style="width:150px;min-width:130px">
      <label for="ana-maxpoints">Display MaxPts</label>
      <input id="ana-maxpoints" type="number" value="10000" min="100" style="width:100%;box-sizing:border-box;">
    </div>
  </div>
  
  <!-- Threshold Section -->
  <div class="threshold-section" style="background:var(--panel,#1f2428);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:20px;margin-bottom:20px;">
    <h3 style="margin:0 0 16px 0;font-size:1rem;font-weight:600;color:var(--ink,#f3f5f6);">Threshold Visualization</h3>
    <div class="threshold-controls" style="display:flex;gap:12px;flex-wrap:wrap;align-items:end;margin-bottom:12px;">
      <div style="flex:1 1 200px;min-width:180px">
        <label for="threshold-signal" style="display:block;margin-bottom:6px;font-size:0.875rem;">Signal</label>
        <select id="threshold-signal" style="width:100%;box-sizing:border-box;">
          <option value="">Select a signal</option>
        </select>
      </div>
      <div style="width:150px;min-width:130px">
        <label for="threshold-min" style="display:block;margin-bottom:6px;font-size:0.875rem;">Min Threshold</label>
        <input id="threshold-min" type="number" placeholder="Min value" style="width:100%;box-sizing:border-box;">
      </div>
      <div style="width:150px;min-width:130px">
        <label for="threshold-max" style="display:block;margin-bottom:6px;font-size:0.875rem;">Max Threshold</label>
        <input id="threshold-max" type="number" placeholder="Max value" style="width:100%;box-sizing:border-box;">
      </div>
      <button id="btn-apply-threshold" class="secondary" style="height:fit-content;margin-top:auto;">Apply Threshold</button>
    </div>
    <div class="threshold-hint" style="font-size:0.813rem;color:var(--ink-soft,#8b949e);line-height:1.5;word-wrap:break-word;overflow-wrap:break-word;">
      Highlight areas where the selected signal exceeds the threshold values. Clear thresholds by leaving fields empty.
    </div>
  </div>
  
  <div class="split" id="analytics-split" style="margin-top:20px">
    <div style="min-width:0;max-width:100%;box-sizing:border-box;">
      <div class="flex" style="margin-bottom:16px;gap:12px;flex-wrap:wrap;">
        <button id="btn-plot" disabled>Plot Signals</button>
        <button id="btn-clear-plot" class="secondary" disabled>Clear Plot</button>
        <button id="btn-copy-stats" class="secondary" disabled>Copy Stats</button>
      </div>
      <div id="analytics-status" class="status" style="margin-bottom:16px;padding:12px 16px;border-radius:8px;word-wrap:break-word;overflow-wrap:break-word;max-width:100%;box-sizing:border-box;" aria-live="polite"></div>
      <div id="analytics-plot-panel" class="plot-panel" style="display:none;">
          <div id="analytics-plot" class="plotly-graph-div"></div>
      </div>
      <div id="fft-plot-panel" class="plot-panel" style="display:none;">
          <div id="fft-plot" class="plotly-graph-div"></div>
      </div>
      <div id="hist-plot-panel" class="plot-panel" style="display:none;">
          <div id="hist-plot" class="plotly-graph-div"></div>
      </div>
    </div>
    <aside class="accent-panel" id="analytics-side" style="min-height:200px;position:sticky;top:20px;align-self:start;">
      <h3 class="accent-panel-title" style="margin:0 0 12px 0;font-size:1rem;font-weight:600;">Stats</h3>
      <div class="accent-panel-desc small" style="margin-bottom:12px;line-height:1.5;">Min / Mean / Max of plotted signals.</div>
      <div id="stats-table" style="margin-top:0;max-width:100%;overflow-x:auto;box-sizing:border-box;"></div>
    </aside>
  </div>
</section>

<!-- Enhanced Playground Section -->
<section id="sec-playground" style="display:none">
    <h2>Advanced Analytics Playground</h2>
    <p class="small" style="margin-top: -10px; margin-bottom: 20px;">Professional-grade signal visualization and analysis with multi-trace support</p>
    
    <div class="pg-toolbar">
      <button id="pg-render" class="primary">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="shape-rendering: geometricPrecision;"><path d="M5 3l14 9-14 9V3z"></path></svg>
        Render Plot
      </button>
      <span id="pg-status" class="hidden" aria-live="polite">Ready</span>
      <button id="pg-add-trace" class="secondary">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="shape-rendering: geometricPrecision;"><path d="M12 5v14M5 12h14"></path></svg>
        Add Trace
      </button>
      <button id="pg-clear" class="secondary">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="shape-rendering: geometricPrecision;"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path></svg>
        Clear All
      </button>
      
      <select id="pg-theme" aria-label="Plot Theme">
        <option value="portal">Portal Theme</option>
        <option value="uniplot">UniPlot Light</option>
        <option value="dark">Professional Dark</option>
      </select>
      
      <select id="pg-legend" aria-label="Legend Position">
        <option value="h">Horizontal Legend</option>
        <option value="v">Vertical Legend</option>
        <option value="none">No Legend</option>
      </select>
      
      <button id="pg-save">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="shape-rendering: geometricPrecision;"><path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"></path><path d="M17 21v-8H7v8M7 3v5h8"></path></svg>
        Save PNG
      </button>
      
      <button id="pg-save-svg" class="secondary">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="shape-rendering: geometricPrecision;"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"></path></svg>
        Save SVG
      </button>
    </div>
    
    <div class="playground-container">
      <div class="playground-controls">
        <!-- Plot Configuration -->
        <div class="control-section">
          <h4>
            Plot Configuration
            <button class="toggle-section" aria-label="Toggle Plot Configuration Section">−</button>
          </h4>
          <div class="section-content">
            <div class="playground-row">
              <label for="pg-plot-type">Plot Type</label>
              <select id="pg-plot-type">
                <option value="scatter">Scatter Plot</option>
                <option value="bar">Bar Chart</option>
                <option value="histogram">Histogram</option>
                <option value="box">Box Plot</option>
                <option value="violin">Violin Plot</option>
                <option value="density-heatmap">Density Heatmap</option>
                <option value="heatmap">Heatmap</option>
                <option value="contour">Contour Plot</option>
                <option value="scatter3d">3D Scatter</option>
                <option value="surface">3D Surface</option>
                <option value="candlestick">Candlestick</option>
              </select>
            </div>
            
            <div class="playground-row">
              <label for="pg-title">Plot Title</label>
              <input id="pg-title" type="text" placeholder="Custom plot title">
            </div>
            
            <div class="playground-row">
              <label for="pg-stacked">Subplot Rows</label>
              <input id="pg-stacked" type="number" value="1" min="1" max="10">
            </div>
            
            <div class="playground-row">
              <label for="pg-downsample">Max Points</label>
              <input id="pg-downsample" type="number" value="20000" min="100">
            </div>
          </div>
        </div>
        
        <!-- Data Selection -->
        <div class="control-section">
          <h4>
            Data Selection
            <button class="toggle-section" aria-label="Toggle Data Selection Section">−</button>
          </h4>
          <!-- Data Selection (unified select-preview chips for X, Y, Z, Color, Size, Group) -->
          <div class="section-content">
            <div class="playground-row">
              <label for="pg-x">X Axis</label>
              <div class="select-wrapper" style="margin-bottom:6px">
                <div id="pg-x-preview" class="select-preview" tabindex="0" role="button" aria-controls="pg-x">
                  <span class="label" id="pg-x-preview-label">Select X signal</span>
                  <span class="muted" id="pg-x-preview-sub">Single</span>
                  <span class="caret">▾</span>
                </div>
                <select id="pg-x" aria-label="X Axis Signal" class="hidden-native-select"></select>
              </div>
            </div>
          
            <div class="playground-row">
              <label for="pg-y">Y Axis</label>
              <div class="select-wrapper" style="margin-bottom:6px">
                <div id="pg-y-preview" class="select-preview" tabindex="0" role="button" aria-controls="pg-y">
                  <span class="label" id="pg-y-preview-label">Select Y signal</span>
                  <span class="muted" id="pg-y-preview-sub">Single</span>
                  <span class="caret">▾</span>
                </div>
                <select id="pg-y" aria-label="Y Axis Signal" class="hidden-native-select"></select>
              </div>
            </div>
          
            <div class="playground-row" id="z-axis-row" style="display:none">
              <label for="pg-z">Z Axis (3D)</label>
              <div class="select-wrapper" style="margin-bottom:6px">
                <div id="pg-z-preview" class="select-preview" tabindex="0" role="button" aria-controls="pg-z">
                  <span class="label" id="pg-z-preview-label">Select Z signal (3D)</span>
                  <span class="muted" id="pg-z-preview-sub">Optional</span>
                  <span class="caret">▾</span>
                </div>
                <select id="pg-z" aria-label="Z Axis Signal" class="hidden-native-select"></select>
              </div>
            </div>
          
            <div class="playground-row">
              <label for="pg-color">Color Encoding</label>
              <div class="select-wrapper" style="margin-bottom:6px">
                <div id="pg-color-preview" class="select-preview" tabindex="0" role="button" aria-controls="pg-color">
                  <span class="label" id="pg-color-preview-label">-- None --</span>
                  <span class="muted" id="pg-color-preview-sub">Color</span>
                  <span class="caret">▾</span>
                </div>
                <select id="pg-color" aria-label="Color Encoding Signal" class="hidden-native-select"></select>
              </div>
            </div>
          
            <div class="playground-row">
              <label for="pg-size">Size Encoding</label>
              <div class="select-wrapper" style="margin-bottom:6px">
                <div id="pg-size-preview" class="select-preview" tabindex="0" role="button" aria-controls="pg-size">
                  <span class="label" id="pg-size-preview-label">-- None --</span>
                  <span class="muted" id="pg-size-preview-sub">Size</span>
                  <span class="caret">▾</span>
                </div>
                <select id="pg-size" aria-label="Size Encoding Signal" class="hidden-native-select"></select>
              </div>
            </div>
          
            <div class="playground-row">
              <label for="pg-group">Group By</label>
              <div class="select-wrapper" style="margin-bottom:6px">
                <div id="pg-group-preview" class="select-preview" tabindex="0" role="button" aria-controls="pg-group">
                  <span class="label" id="pg-group-preview-label">-- None --</span>
                  <span class="muted" id="pg-group-preview-sub">Group</span>
                  <span class="caret">▾</span>
                </div>
                <select id="pg-group" aria-label="Group By Signal" class="hidden-native-select"></select>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Data Range -->
        <div class="control-section">
          <h4>
            Data Range
            <button class="toggle-section" aria-label="Toggle Data Range Section">−</button>
          </h4>
          <div class="section-content">
            <div class="playground-row">
              <label for="pg-tmin">Time Min (s)</label>
              <input id="pg-tmin" type="number" placeholder="Start time">
            </div>
            
            <div class="playground-row">
              <label for="pg-tmax">Time Max (s)</label>
              <input id="pg-tmax" type="number" placeholder="End time">
            </div>
            
            <div class="playground-row">
              <label for="pg-bins">Bins (Histogram)</label>
              <input id="pg-bins" type="number" placeholder="Auto">
            </div>
            
            <div class="playground-row">
              <label for="pg-colorscale">Color Scale</label>
              <select id="pg-colorscale">
                <option value="Viridis">Viridis</option>
                <option value="Plasma">Plasma</option>
                <option value="Inferno">Inferno</option>
                <option value="Magma">Magma</option>
                <option value="Blues">Blues</option>
                <option value="Reds">Reds</option>
                <option value="Greens">Greens</option>
                <option value="RdBu">Red-Blue</option>
                <option value="RdYlBu">Red-Yellow-Blue</option>
                <option value="Spectral">Spectral</option>
              </select>
            </div>
            
            <div class="playground-row">
              <label for="pg-histnorm">Histogram Normalization</label>
              <select id="pg-histnorm">
                <option value="count">Count</option>
                <option value="probability">Probability</option>
                <option value="density">Density</option>
                <option value="percent">Percent</option>
              </select>
            </div>
          </div>
        </div>
        
        <!-- Axis Configuration -->
        <div class="control-section">
          <h4>
            Axis Configuration
            <button class="toggle-section" aria-label="Toggle Axis Configuration Section">−</button>
          </h4>
          <div class="section-content">
            <div class="playground-row">
              <label for="pg-xmin">X Min</label>
              <input id="pg-xmin" type="number" placeholder="Auto">
            </div>
            <div class="playground-row">
              <label for="pg-xmax">X Max</label>
              <input id="pg-xmax" type="number" placeholder="Auto">
            </div>
            <div class="playground-row">
              <label for="pg-xdt">X Tick</label>
              <input id="pg-xdt" type="number" placeholder="Auto">
            </div>
            <div class="playground-row">
              <label for="pg-ymin">Y Min</label>
              <input id="pg-ymin" type="number" placeholder="Auto">
            </div>
            <div class="playground-row">
              <label for="pg-ymax">Y Max</label>
              <input id="pg-ymax" type="number" placeholder="Auto">
            </div>
            <div class="playground-row">
              <label for="pg-ydt">Y Tick</label>
              <input id="pg-ydt" type="number" placeholder="Auto">
            </div>
            <div class="playground-row">
                <label for="pg-square">Square Aspect</label>
                <input id="pg-square" name="pg-square" type="checkbox">
            </div>
          </div>
        </div>
        
        <!-- 3D Controls (shown only for 3D plots) -->
        <div class="control-section" id="3d-controls-section" style="display:none">
          <h4>
            3D Controls
            <button class="toggle-section" aria-label="Toggle 3D Controls Section">−</button>
          </h4>
          <div class="section-content">
            <div class="playground-row full-width">
              <label>Camera Position</label>
            </div>
            
            <div class="camera-controls">
              <div class="camera-control">
                <label for="pg-camera-x">X</label>
                <input id="pg-camera-x" type="number" value="1.5" step="0.1">
              </div>
              <div class="camera-control">
                <label for="pg-camera-y">Y</label>
                <input id="pg-camera-y" type="number" value="1.5" step="0.1">
              </div>
              <div class="camera-control">
                <label for="pg-camera-z">Z</label>
                <input id="pg-camera-z" type="number" value="1.5" step="0.1">
              </div>
            </div>
            
            <div class="playground-row" style="margin-top:10px">
              <button id="pg-reset-camera" class="secondary" style="width:100%">Reset Camera</button>
            </div>
          </div>
        </div>
        
        <!-- Advanced Styling -->
        <div class="control-section">
          <h4>
            Advanced Styling
            <button class="toggle-section" aria-label="Toggle Advanced Styling Section">−</button>
          </h4>
          <div class="section-content">
            <div class="playground-row">
              <label for="pg-line-width">Line Width</label>
              <input id="pg-line-width" type="number" value="2" min="1" max="10" step="0.5">
            </div>
            <div class="playground-row">
              <label for="pg-marker-size">Marker Size</label>
              <input id="pg-marker-size" type="number" value="6" min="1" max="20">
            </div>
            <div class="playground-row">
              <label for="pg-opacity">Opacity</label>
              <input id="pg-opacity" type="number" value="1" min="0.1" max="1" step="0.1">
            </div>
            <div class="playground-row">
                <label for="pg-print">Print Mode</label>
                <input id="pg-print" name="pg-print" type="checkbox">
            </div>
          </div>
        </div>
        
        <!-- Analysis Presets -->
        <div class="control-section">
          <h4>
            Analysis Presets
            <button class="toggle-section" aria-label="Toggle Analysis Presets Section">−</button>
          </h4>
          <div class="section-content">
            <div class="preset-buttons">
              <div class="preset-btn" data-preset="time-series">Time Series</div>
              <div class="preset-btn" data-preset="correlation">Correlation</div>
              <div class="preset-btn" data-preset="distribution">Distribution</div>
              <div class="preset-btn" data-preset="performance">Performance Map</div>
            </div>
          </div>
        </div>
        <!-- File info display (channel selection is done in Advanced Analytics section) -->
        <div id="pg-files-info" style="display:none; padding:8px 12px; background:var(--panel); border-radius:var(--radius); margin-bottom:12px; font-size:0.9em; color:var(--muted-text); border-left:3px solid var(--accent);">
          <span id="pg-files-count">Loading file information...</span>
          <div class="small" style="margin-top:4px; opacity:0.8;">Select signals in the <strong>Analyse</strong> tab, then use them here</div>
        </div>
      </div>
      
      <div class="playground-vis">
        <div class="plot-container" id="pg-canvas-container">
          <div id="pg-canvas" class="plotly-graph-div"></div>
          <div id="pg-3d-indicator" class="badge accent" style="display: none; position: absolute; top: 10px; right: 10px;">
            3D Mode Active
          </div>
        </div>
        
        <!-- Trace Manager -->
        <div class="trace-manager">
          <h4>Trace Management</h4>
          <div class="trace-list" id="trace-list">
            <div class="trace-item" style="color: var(--ink-soft); font-style: italic;">
              No traces added yet
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>


<!-- Reports -->
<section id="sec-report" style="display:none;position:relative;">
  <h2>Reports</h2>
  <div class="flex" style="gap:12px; flex-wrap: wrap; align-items: center;">
    <button id="btn-report">Regenerate Sections</button>
  </div>
  <div class="subtabs">
    <button class="active" data-sub="dfc">DFC</button>
    <button data-sub="iupr">IUPR</button>
    <button data-sub="gear">Gear Hunt</button>
    <button data-sub="misfire">Misfire Detection</button>
    <button data-sub="ccsl">CC/SL Validation</button>
    <button data-sub="fuel">Fuel Consumption</button>
    <button data-sub="map">Empirical Map</button>
  </div>
  <div id="report-timestamp" class="small" style="margin-top:10px">Upload a file to generate reports.</div>
  <div style="margin-top:12px; display:none;" id="section-download-csv-container">
    <button id="btn-download-section-csv" class="secondary">Download Table CSV</button>
  </div>
  <div id="report-dfc" data-section="dfc" style="margin-top:18px"></div>
  <div id="report-iupr" data-section="iupr" style="margin-top:18px;display:none"></div>
  <div id="report-gear" data-section="gear" style="margin-top:18px;display:none"></div>
  <div id="report-misfire" data-section="misfire" style="margin-top:18px;display:none"></div>
  <div id="report-ccsl" data-section="ccsl" style="margin-top:18px;display:none"></div>
  <div id="report-fuel" data-section="fuel" style="margin-top:18px;display:none"></div>
  <div id="report-map" data-section="map" style="margin-top:18px;display:none">
    <div id="empirical-map-controls" class="map-controls">
        <h4>Empirical Map Generator</h4>
        
        <div class="flex" style="margin-bottom: 16px;">
            <div style="flex: 1;">
                <label for="map-x-axis">X-Axis Signal</label>
                <select id="map-x-axis"></select>
            </div>
            <div style="flex: 1;">
                <label for="map-y-axis">Y-Axis Signal</label>
                <select id="map-y-axis"></select>
            </div>
            <div style="flex: 1;">
                <label for="map-z-axis">Z-Axis Signal</label>
                <select id="map-z-axis"></select>
            </div>
        </div>
        
        <div class="flex" style="margin-bottom: 16px;">
            <div style="flex: 1;">
                <label for="map-rpm-bins">X Bins (e.g. 0:6000:100)</label>
                <input type="text" id="map-rpm-bins" placeholder="start:stop:step or comma-sep">
            </div>
            <div style="flex: 1;">
                <label for="map-tq-bins">Y Bins (e.g. 0:500:10)</label>
                <input type="text" id="map-tq-bins" placeholder="start:stop:step or comma-sep">
            </div>
            <div style="flex: 1;">
                <label for="map-type">Map Type</label>
                <select id="map-type">
                    <option value="heatmap">Heatmap</option>
                    <option value="contour">Contour</option>
                    <option value="surface">3D Surface</option>
                </select>
            </div>
        </div>

        <!-- INSERT: Map Presets -->
        <div style="display:flex; gap:10px; align-items:end; margin-bottom:10px;">
          <div style="flex:1; min-width:220px;">
            <label for="map-preset">Preset Map</label>
            <select id="map-preset" title="Choose a calibration preset">
              <option value="">-- None / Custom --</option>
              <option value="ci_engine_default">CI Engine — BSFC</option>
              <option value="si_engine_default">SI Engine — Efficiency / AFR</option>
              <option value="electric_motor_default">Electric Motor — Efficiency</option>
              <option value="afr_wide">AFR Wide</option>
              <option value="developer_custom">Developer — custom</option>
            </select>
          </div>
          <div style="width:140px;">
            <label for="map-min-samples">Min samples / bin</label>
            <input id="map-min-samples" type="number" value="6" min="1" step="1">
          </div>
          <div style="width:160px;">
            <label for="map-interp-method">Interpolation</label>
            <select id="map-interp-method">
              <option value="none">none</option>
              <option value="linear">linear</option>
              <option value="cubic">cubic</option>
              <option value="rbf">rbf</option>
              <option value="gaussian">gaussian</option>
            </select>
          </div>
          <div style="width:120px;">
            <label for="map-smoothing">Smoothing</label>
            <input id="map-smoothing" type="number" min="0" step="0.1" value="0.6">
          </div>
          <button id="map-save-profile" class="secondary" type="button">Save Profile</button>
          <button id="map-load-profile" class="secondary" type="button">Load Profile</button>
        </div>

        <!-- Preset automation controls -->
        <div class="preset-automation-row" style="display:flex;align-items:center;gap:12px;margin-top:8px;">
          <label style="display:flex;align-items:center;gap:8px;font-size:.85rem;color:var(--ink-soft);">
            <input id="auto-apply-preset" type="checkbox" style="width:16px;height:16px;"/>
            <span style="font-weight:600">Auto-apply preset after upload</span>
          </label>
        
          <div style="flex:1"></div>
        
          <button id="preset-apply-now" class="secondary" title="Try resolve & preview mapping">Preview Mapping</button>
        </div>
        
        <!-- Preset confidence panel (collapsed by default) -->
        <div id="preset-confidence-panel" class="preset-confidence-panel hidden" aria-hidden="true">
          <div class="preset-confidence-header">
            <div><strong>Preset Mapping Preview</strong></div>
            <div class="preset-confidence-actions">
              <button id="preset-edit-btn" class="secondary">Edit</button>
              <button id="preset-confirm-btn" class="primary">Confirm & Render</button>
            </div>
          </div>
          <div id="preset-confidence-body">
            <!-- populated dynamically -->
          </div>
          <div id="preset-confidence-footer" class="small" style="margin-top:8px;color:var(--ink-soft)">
            Auto-resolved channels are green; fuzzy matches show “(fuzzy)” with confidence score. You can edit any mapping before rendering.
          </div>
        </div>
        
        <!-- Uploaded file list (populated by loadUploadedFiles()) -->
        <div id="map-file-list" style="margin:10px 0; padding:8px; border:1px dashed #eee; max-height:160px; overflow:auto;">
          <div class="small">Loading uploaded files...</div>
        </div>

        <!-- File Validation Dashboard -->
        <div id="validation-dashboard" class="validation-dashboard" style="display: none; margin: 16px 0; padding: 16px; background: var(--panel); border-radius: var(--radius); border: 1px solid var(--muted);">
            <h4 style="margin-top: 0; color: var(--fev-red);">Data Quality Assessment</h4>
            <div id="validation-results"></div>
            <div style="margin-top: 12px;">
                <button id="btn-validate-files" class="secondary">Validate Files</button>
                <button id="btn-get-signal-suggestions" class="secondary">Get Signal Suggestions</button>
            </div>
        </div>

        <div class="flex">
            <button id="generate-map" class="primary">Generate Map</button>
            <button id="clear-map" class="secondary">Clear Map</button>
        </div>
    </div>
    
    <div id="map-status" class="pg-status" style="margin-top: 10px;"></div>
    
    <!-- Progress Tracking Display -->
    <div id="map-progress" class="map-progress" style="display: none; margin: 16px 0; padding: 16px; background: var(--panel); border-radius: var(--radius); border: 1px solid var(--muted);">
        <h4 style="margin-top: 0; color: var(--fev-red);">Processing Progress</h4>
        <div id="progress-stages"></div>
        <div id="progress-summary" style="margin-top: 12px; padding: 8px; background: var(--input-bg); border-radius: 4px; font-size: 0.9rem;"></div>
    </div>
    
    <div id="map-results" style="margin-top: 20px; display: none;">
        <div class="map-display-controls">
            <button class="map-view-btn active" data-view="heatmap">Heatmap View</button>
            <button class="map-view-btn" data-view="surface">3D View</button>
            <button class="map-view-btn" data-view="stats">Statistics</button>
        </div>
        
        <div id="map-heatmap" class="plot-panel" style="height: 500px; display: block;"></div>
        <div id="map-surface" class="plot-panel" style="height: 500px; display: none;"></div>
        <div id="map-stats" style="display: none;">
            <div id="map-stats-content" class="status dark"></div>
            <div id="map-meta" class="status dark" style="margin-top: 10px;"></div>
        </div>
        <!-- Export Buttons -->
        <div style="margin-top:8px; display:flex; gap:8px;">
          <button id="map-export-csv" class="secondary">Export Map CSV</button>
          <button id="map-export-xlsx" class="secondary">Export Map XLSX</button>
          <button id="map-download-plot" class="secondary">Download Plot PNG</button>
        </div>
    </div>
  </div>
  <div id="report-spinner" class="overlay-spinner" style="display:none">
    <div class="spinner" style="width:48px;height:48px;border-radius:50%;border:5px solid #394046;border-top-color:var(--acc);animation:spin .75s linear infinite"></div>
  </div>
</section>

<!-- Files -->
<section id="sec-files" style="display:none">
  <h2>Files</h2>
  
  <!-- Summary Statistics -->
  <div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:20px;padding:16px;background:var(--panel);border-radius:var(--radius);border:1px solid rgba(255,255,255,0.08);">
    <div style="flex:1 1 200px;min-width:150px">
      <div class="small" style="opacity:0.7;margin-bottom:4px">Total Files</div>
      <div style="font-size:1.5rem;font-weight:600;color:var(--accent)"><span id="file-count">0</span></div>
    </div>
    <div style="flex:1 1 200px;min-width:150px">
      <div class="small" style="opacity:0.7;margin-bottom:4px">Total Size</div>
      <div style="font-size:1.5rem;font-weight:600" id="files-total-size">0 B</div>
    </div>
    <div style="flex:1 1 200px;min-width:150px">
      <div class="small" style="opacity:0.7;margin-bottom:4px">File Types</div>
      <div style="font-size:1.5rem;font-weight:600" id="files-type-breakdown">-</div>
    </div>
  </div>
  
  <!-- Action Buttons -->
  <div class="flex" style="margin-bottom:16px;gap:8px">
    <button id="btn-files-refresh" class="secondary">Refresh</button>
    <button id="btn-files-delete-all" class="danger">Delete All</button>
  </div>
  
  <!-- File List Table -->
  <div id="files-list-container" style="margin-top:16px">
    <div id="files-list-empty" style="text-align:center;padding:40px;color:var(--ink-soft);display:none">
      <div style="font-size:3rem;opacity:0.3;margin-bottom:12px">📁</div>
      <div style="font-size:1.1rem;margin-bottom:8px">No files uploaded</div>
      <div class="small">Upload files in the <strong>Analyse</strong> tab to get started</div>
    </div>
    <div id="files-list-table-wrapper" style="display:none">
      <div class="table-wrapper">
        <table id="files-table">
          <thead>
            <tr>
              <th style="width:40px"></th>
              <th style="text-align:left">File Name</th>
              <th style="text-align:left">Type</th>
              <th style="text-align:right">Size</th>
              <th style="text-align:center;width:100px">Actions</th>
            </tr>
          </thead>
          <tbody id="files-table-body">
            <!-- Populated by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>
  </div>
</section>


<div id="toast-container" aria-live="polite"></div>

<!-- Missing signals modal (floating) - will be shown/filled by JS if needed -->
<div id="missing-signals-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="missingSignalsTitle">
  <div class="modal-card">
    <h3 id="missingSignalsTitle">Missing signals — please select substitutes</h3>
    <div id="missing-signals-list" style="max-height:320px;overflow:auto;margin-top:8px;"></div>
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px;">
      <button id="missing-cancel" class="secondary">Cancel</button>
      <button id="missing-confirm" class="primary">Confirm</button>
    </div>
  </div>
</div>

<!-- preset confidence modal -->
<div id="preset-confidence-modal" class="modal hidden" aria-hidden="true">
  <div class="modal-body">
    <h3>Preset: auto-mapping confidence</h3>
    <div id="preset-confidence-list"></div>
    <div class="modal-actions">
      <label><input id="auto-apply-checkbox" type="checkbox"> Auto-apply preset after upload</label>
      <button id="preset-apply">Apply & Render</button>
      <button id="preset-cancel">Cancel</button>
    </div>
  </div>
</div>

<script>
/* ====================== Config & State ====================== */
const INITIAL_CHANNEL_BATCH=6;
const CHANNEL_BATCH=25;
const PROGRESSIVE_CHANNEL_MAPPING_THRESHOLD=1500;
const CHANNEL_MAP_CHUNK=600;
const CHANNEL_IDLE_BATCH=800;
let visibleChannelCount=INITIAL_CHANNEL_BATCH;
let currentSearch="";
const MAX_SELECTED_SIGNALS=50;
const ENFORCE_LIMIT=true;
const REPORT_AUTO_REFRESH_ON_TAB=true;
const PRIMARY_TABLE_KEYS={ dfc:'DFC Summary', iupr:'Final Ratios', ccsl:'CC/SL Overshoot', gear:'Hunting Events', misfire:'Misfire Events', map: 'Map Summary' };
let state={
  channels:[],
  selected:new Set(),
  userEditedSignals:false,
  lastSeries:null,
  lastStats:[],
  lastFFT:null,
  lastHist:null,
  hasFFT:false,
  hasHist:false,
  reportCache:{},
  plotting:false,
  currentReportSection:'dfc',
  lastPrimaryTableData:[],
  lastPrimaryMeta:{},
  fileCount: 0, // Track number of files on server
  thresholds: {
    signal: null,
    min: null,
    max: null,
    violations: []
  }
};
window.state = state; // Expose to global scope for enhancement script
window.currentMapResults = null; // Store last map result for view switching
window.__lastMapRequestPayload = null; // Store last map request for re-running with overrides

/* ====================== Helpers ====================== */
const $=id=>{
  const element = document.getElementById(id);
  // No warning on not found, as some elements are optional
  return element;
};
const esc=v=>String(v??'').replace(/[&<>"]/g,s=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[s]));
function toast(msg,{type='info',timeout=3200}={}){
  const box=$('toast-container');
  if (!box) return;
  
  const d=document.createElement('div');
  d.className='toast'+(type==='error'?' error':type==='success'?' success':type==='warn'?' warn':'');
  d.textContent=msg;
  box.appendChild(d);
  setTimeout(()=>d.remove(),timeout);
}
function log(msg){
  const logEl = $('log');
  if (logEl) {
    logEl.textContent=`[${new Date().toLocaleTimeString()}] ${msg}\n`+logEl.textContent;
  }
}
function setStatus(id,msg){
  const el=$(id); 
  if(el) el.textContent=msg;
}
function truncateLabel(t,m=24){return t.length>m?t.slice(0,m-1)+'…':t;}
function selectedIds(){return [...state.selected];}
function enforceLimit(){
  const list=getCurrentSignalList();
  const plotBtn = $('btn-plot');
  if (plotBtn) {
    plotBtn.disabled=(!list.length)||(ENFORCE_LIMIT && list.length>MAX_SELECTED_SIGNALS);
  }
}
function formatBytes(b){if(!b)return'0';const u=['B','KB','MB','GB','TB'];let i=0;while(b>=1024&&i<u.length-1){b/=1024;i++;}return (b>=10||i===0?Math.round(b):b.toFixed(1))+' '+u[i];}
function csvFromRows(rows){if(!rows.length)return'';const cols=Object.keys(rows[0]);const head=cols.map(c=>`"${c.replace(/"/g,'""')}"`).join(',');const body=rows.map(r=>cols.map(c=>`"${String(r[c]??'').replace(/"/g,'""')}"`).join(',')).join('\n');return head+'\n'+body;}
function shortLabel(s,n=32){s=s||"";return s.length<=n?s:s.slice(0,n-1)+'…';}

// Redraw all plots when theme changes
function redrawAllPlots() {
 if (state.lastSeries) {
   redrawMainChart();
 }
 if (state.lastFFT && $('feature-fft')?.checked) {
   drawFFT(state.lastFFT);
 }
 if (state.lastHist && $('feature-hist')?.checked) {
   drawHist(state.lastHist);
 }
 if (window.plotState && window.plotState.traces && window.plotState.traces.length > 0) {
   const renderBtn = document.getElementById('pg-render');
   // Check if renderPlot is defined (playground is loaded)
   if(renderBtn && typeof renderPlot === 'function') {
     withButtonLock(renderBtn, () => renderPlot(false), 'renderPlot');
   }
 }
 // Redraw report sections if they're visible and cached
 if (state.currentReportSection && state.reportCache[state.currentReportSection]) {
   renderReportSection(state.currentReportSection, state.reportCache[state.currentReportSection]);
 }
 // Redraw map plots if they exist
 if (window.currentMapResults) {
   displayMapResults(window.currentMapResults);
 }
}

// Theme toggle functionality
function initThemeToggle(){
  const toggle = document.getElementById('theme-toggle');
  if (!toggle) {
    console.warn('Theme toggle not found');
    return;
  }
  
  // Set initial theme
  if (localStorage.getItem('theme') === 'light' || 
      (!localStorage.getItem('theme') && window.matchMedia && !window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.body.classList.add('light-theme');
  }

  toggle.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    localStorage.setItem('theme', document.body.classList.contains('light-theme') ? 'light' : 'dark');
    redrawAllPlots();
  });
}

/* ====================== Files & Delete All ====================== */
function getFileTypeIcon(ext) {
  const icons = {
    '.mdf': '📊',
    '.mf4': '📊',
    '.csv': '📄',
    '.xlsx': '📑',
    '.xls': '📑'
  };
  return icons[ext.toLowerCase()] || '📄';
}

function getFileTypeName(ext) {
  const types = {
    '.mdf': 'MDF',
    '.mf4': 'MF4',
    '.csv': 'CSV',
    '.xlsx': 'Excel',
    '.xls': 'Excel'
  };
  return types[ext.toLowerCase()] || ext.toUpperCase().slice(1) || 'Unknown';
}

// File list cache and debouncing
let fileListCache = null;
let fileListCacheTime = 0;
let fileListPending = null;
const FILE_LIST_CACHE_TTL = 2000; // 2 seconds cache
let fileListDebounceTimer = null;

// Extract data application logic for reuse
function applyFileListData(j) {
    state.fileCount = j.files.length; // Update global state
  
  // Update summary statistics
    const fileCountEl = $('file-count');
    if (fileCountEl) fileCountEl.textContent = state.fileCount;
    
    const badgeFileCount = $('badge-filecount');
    if (badgeFileCount) badgeFileCount.textContent=`Files: ${state.fileCount}`;
    
  const totalSize = j.files.reduce((s,f)=>s+(f.size||0),0);
    const badgeTotalSize = $('badge-totalsize');
    if (badgeTotalSize) {
    badgeTotalSize.textContent=`Total: ${formatBytes(totalSize)}`;
  }
  
  // Update Files tab total size
  const filesTotalSizeEl = $('files-total-size');
  if (filesTotalSizeEl) filesTotalSizeEl.textContent = formatBytes(totalSize);
  
  // Calculate file type breakdown
  const typeCount = {};
  j.files.forEach(f => {
    const ext = '.' + (f.name || '').split('.').pop() || 'unknown';
    typeCount[ext] = (typeCount[ext] || 0) + 1;
  });
  const typeBreakdown = Object.entries(typeCount)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([ext, count]) => `${getFileTypeName(ext)} (${count})`)
    .join(', ') || '-';
  const filesTypeBreakdownEl = $('files-type-breakdown');
  if (filesTypeBreakdownEl) filesTypeBreakdownEl.textContent = typeBreakdown;
  
  // Render file table
  const emptyEl = $('files-list-empty');
  const tableWrapperEl = $('files-list-table-wrapper');
  const tableBodyEl = $('files-table-body');
  
  if (j.files.length === 0) {
    if (emptyEl) emptyEl.style.display = 'block';
    if (tableWrapperEl) tableWrapperEl.style.display = 'none';
  } else {
    if (emptyEl) emptyEl.style.display = 'none';
    if (tableWrapperEl) tableWrapperEl.style.display = 'block';
    
    if (tableBodyEl) {
      tableBodyEl.innerHTML = j.files.map((file, idx) => {
        const fileName = file.name || file.path?.split(/[\\/]/).pop() || 'Unknown';
        const ext = '.' + fileName.split('.').pop() || '';
        const fileSize = file.size || 0;
        const icon = getFileTypeIcon(ext);
        const typeName = getFileTypeName(ext);
        const rowId = `file-row-${idx}`;
        
        return `
          <tr id="${rowId}">
            <td style="text-align:center;font-size:1.2rem">${icon}</td>
            <td style="text-align:left">
              <div style="font-weight:500">${esc(fileName)}</div>
              ${file.path && file.path !== fileName ? `<div class="small" style="opacity:0.6;margin-top:2px;word-break:break-all">${esc(file.path)}</div>` : ''}
            </td>
            <td style="text-align:left">
              <span class="badge" style="background:var(--panel);border:1px solid rgba(255,255,255,0.1)">${esc(typeName)}</span>
            </td>
            <td style="text-align:right;font-family:monospace;color:var(--ink-soft)">${formatBytes(fileSize)}</td>
            <td style="text-align:center">
              <button class="secondary icon-btn file-delete-btn" data-filename="${esc(fileName)}" title="Delete file" style="padding:4px 8px;font-size:0.875rem">
                🗑️
              </button>
            </td>
          </tr>
        `;
      }).join('');
      
      // Add event listeners to delete buttons using event delegation
      const deleteButtons = tableBodyEl.querySelectorAll('.file-delete-btn');
      deleteButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const filename = e.target.closest('.file-delete-btn')?.dataset?.filename;
          if (filename) {
            deleteSingleFile(filename);
          }
        });
      });
    }
  }
  
    // After refreshing file list, check if we should enable report buttons
    updateReportControlsState();
}

async function refreshFileList(force = false){
  // Check cache first (unless forced)
  const now = Date.now();
  if (!force && fileListCache && (now - fileListCacheTime) < FILE_LIST_CACHE_TTL) {
    applyFileListData(fileListCache);
    return Promise.resolve(fileListCache);
  }
  
  // If a request is already pending, return that promise
  if (fileListPending) {
    return fileListPending;
  }
  
  // Debounce rapid calls (300ms debounce)
  if (fileListDebounceTimer) {
    clearTimeout(fileListDebounceTimer);
  }
  
  return new Promise((resolve) => {
    fileListDebounceTimer = setTimeout(async () => {
      fileListPending = (async () => {
        try {
          const j = await safeFetch('/api/files');
          // Cache the result
          fileListCache = j;
          fileListCacheTime = Date.now();
          applyFileListData(j);
          fileListPending = null;
          resolve(j);
        } catch(e) {
          fileListPending = null;
    toast('Files refresh failed',{type:'error'});
    console.error('File refresh error:', e);
          resolve(null);
        }
      })();
      
      await fileListPending;
    }, 300); // 300ms debounce
  });
}

async function deleteSingleFile(filename) {
  if (!confirm(`Delete "${filename}"?`)) return;
  try {
    const fd = new FormData();
    fd.append('filename', filename);
    const j = await safeFetch('/api/delete_file', { method: 'POST', body: fd });
    if (!j.ok) throw new Error(j.error || 'Delete failed');
    toast(`Deleted "${filename}"`, {type:'success'});
    // Clear cache and force refresh
    fileListCache = null;
    refreshFileList(true);
    // Refresh channels if this affects the current selection
    if (state.fileCount > 0) {
      // Only refresh channels if files still exist
      const checkFiles = await safeFetch('/api/files');
      if (checkFiles.files.length === 0) {
        state.channels = [];
        state.selected.clear();
        renderChannelTable();
      }
    }
  } catch(e) {
    toast('Delete failed: ' + e.message, {type:'error'});
    console.error('Delete error:', e);
  }
}
// Expose to global scope for onclick handlers
window.deleteSingleFile = deleteSingleFile;

const filesRefreshBtn = $('btn-files-refresh');
if (filesRefreshBtn) {
  filesRefreshBtn.addEventListener('click', () => {
    fileListCache = null;
    refreshFileList(true); // Force refresh on manual refresh button
  });
}

const deleteAllBtn = $('btn-files-delete-all');
if (deleteAllBtn) {
  deleteAllBtn.addEventListener('click', async () => {
    if(!confirm('Delete all uploaded files from the server?')) return;
    try {
      const j = await safeFetch('/api/delete_all',{method:'POST'});
      if(!j.ok) throw new Error(j.error||'Delete failed');
      toast(`Deleted ${j.deleted} file(s).`,{type:'success'});
      state.channels=[]; state.selected.clear();
      renderChannelTable();
      fileListCache = null;
      refreshFileList(true); // Force refresh after delete all
    }catch(e){
      toast('Delete failed: ' + e.message, {type:'error'});
      console.error('Delete error:', e);
    }
  });
}

/* ====================== Upload / Drag & Drop ====================== */
const dropZone=$('upload-drop'), fileInput=$('files'), dropMsg=$('drop-msg');
let dragDepth=0;
if(!('requestIdleCallback' in window)){window.requestIdleCallback=cb=>setTimeout(()=>cb({timeRemaining:()=>50,didTimeout:false}),1);}
function setUploadProgress(p){
  const progressEl = $('upload-progress');
  if (progressEl) progressEl.style.width=p+'%';
}
function setDropState(st){
  if(!dropZone) return;
  
  if(st==='active'){dropZone.classList.add('drag');if(dropMsg) dropMsg.textContent='Release to Upload';}
  else if(st==='upload'){dropZone.classList.add('drag');if(dropMsg) dropMsg.textContent='Uploading...';}
  else {dropZone.classList.remove('drag');if(dropMsg) dropMsg.textContent='Ready';}
}

if (dropZone) {
  ['dragover','drop'].forEach(ev=>document.addEventListener(ev,e=>e.preventDefault(),false));
  document.addEventListener('dragenter',e=>{if(!e.dataTransfer)return;dragDepth++;setDropState('active');},false);
  document.addEventListener('dragleave',e=>{if(!e.dataTransfer)return;dragDepth=Math.max(0,dragDepth-1);if(dragDepth===0)setDropState('ready');},false);
  dropZone.addEventListener('dragover',e=>{if(!e.dataTransfer)return;e.preventDefault();e.dataTransfer.dropEffect='copy';},false);
  dropZone.addEventListener('dragenter',e=>{if(!e.dataTransfer)return;e.preventDefault();setDropState('active');},false);
  dropZone.addEventListener('dragleave',e=>{if(e.target===dropZone){setDropState(dragDepth>0?'active':'ready');}},false);
  dropZone.addEventListener('drop',e=>{
    if(!e.dataTransfer)return;
    e.preventDefault();
    const files=[...(e.dataTransfer.files||[])];
    dragDepth=0; setDropState('ready');
    if(files.length) handleUpload(files);
  },false);
  dropZone.addEventListener('click',()=>{
    if (fileInput) fileInput.click();
  });
  dropZone.addEventListener('keydown',e=>{
    if(['Enter',' '].includes(e.key)){e.preventDefault();if (fileInput) fileInput.click();}
  });
}

if (fileInput) {
  fileInput.addEventListener('change',e=>{
    handleUpload([...(e.target.files||[])]);
    e.target.value='';
  });
}

window.syncStateToPlayground = function() {
    if (typeof window.populatePlaygroundFromState === 'function') {
        window.populatePlaygroundFromState();
    }
    if (typeof window.initPlayground === 'function') {
        window.initPlayground();
    }
}

/* Progressive channel mapping */
function mapChannelsProgressive(raw){
  state.channels=[]; let i=0;
  const first=Math.min(raw.length,CHANNEL_MAP_CHUNK);
  for(;i<first;i++){
    const ch=raw[i];
    state.channels.push({
      id:ch.id||ch.name||ch.clean,
      clean:ch.clean||ch.name||ch.id,
      presence:ch.presence||'',
      present_count:ch.present_count??ch.occurrence??0
    });
  }
  renderChannelTable();
  try {
    localStorage.setItem('mdf_channels', JSON.stringify(state.channels));
  } catch (e) {
    console.warn('Failed to store channels in localStorage:', e);
  }
  syncStateToPlayground();

  if(i>=raw.length) return;
  function step(deadline){
    let processed=0;
    while((deadline.timeRemaining()>6||deadline.didTimeout) && i<raw.length && processed<CHANNEL_IDLE_BATCH){
      const ch=raw[i++];
      state.channels.push({
        id: ch.id || ch.name || ch.clean,
        name: ch.name || ch.clean || ch.id,
        clean: ch.clean || ch.name || ch.id,
        presence: ch.presence || '',
        present_count: ch.present_count ?? ch.occurrence ?? 0
      });
      processed++;
    }
    if(i<raw.length) requestIdleCallback(step);
    else {
        toast(`Channels loaded (${raw.length})`,{type:'success'});
        // Final sync after all channels are processed
        syncStateToPlayground();
    }
  }
  requestIdleCallback(step);
}

async function handleUpload(files){
  if(!files.length)return;
  visibleChannelCount=INITIAL_CHANNEL_BATCH;
  currentSearch=""; 
  
  const searchInput = $('channel-search');
  if (searchInput) searchInput.value="";
  
  setStatus('disc-status','Uploading...');
  setDropState('upload');
  setUploadProgress(10);
  const fd=new FormData();
  fd.append('mode',$('mode').value);
  files.forEach(f=>fd.append('files',f));
  try{
    const data = await safeFetch('/smart_merge_upload',{method:'POST',body:fd});
    if(!data.ok) throw new Error(data.error||'Upload failed');
    log(`Uploaded ${files.length} file(s)`);
    const list=data.channels||[];
    if(list.length){
      if(list.length>PROGRESSIVE_CHANNEL_MAPPING_THRESHOLD) mapChannelsProgressive(list);
      else {
        state.channels=list.map(ch=>({
          id:ch.id||ch.name||ch.clean,
          clean:ch.clean||ch.name||ch.id,
          presence:ch.presence||'',
          present_count:ch.present_count??ch.occurrence??0
        }));
        renderChannelTable();
        try { localStorage.setItem('mdf_channels', JSON.stringify(state.channels)); } catch (e) { console.warn('Failed to store channels in localStorage:', e); }
        syncStateToPlayground();
      }
      state.selected.clear();
      const channelsContainer = $('channels-container');
      if (channelsContainer) channelsContainer.style.display='block';
      setStatus('disc-status',`Uploaded. Channels: ${list.length}`);
    }else{
      await refreshChannelsAfterUpload(true);
    }
    
    fileListCache = null;
    await refreshFileList(true); // Force refresh after upload
    setUploadProgress(100);
    setTimeout(()=>setUploadProgress(0),800);
    
    // Refresh map UI after file upload
    loadUploadedFiles();
    initEmpiricalMap();

    // Automatically trigger report generation after first successful upload
    if (state.fileCount > 0) {
        loadReportSection(state.currentReportSection, { force: true });
    }

  }catch(e){
    toast('Upload failed: '+e.message,{type:'error'});
    setStatus('disc-status','Upload error: '+e.message);
    setUploadProgress(0);
  }finally{ setDropState('ready'); }
}

/* ====================== Channel Discovery ====================== */
const modeSelect = $('mode');
if (modeSelect) {
  modeSelect.addEventListener('change',()=>refreshChannelsAfterUpload(true));
}

const discoverBtn = $('btn-discover');
if (discoverBtn) {
  discoverBtn.addEventListener('click',()=>refreshChannelsAfterUpload(true));
}

async function refreshChannelsAfterUpload(){
  const modeSelEl = $('mode');
  if (!modeSelEl) return;
  
  const modeSel = modeSelEl.value;
  setStatus('disc-status','Loading channels ('+modeSel+')...');
  
  const channelsContainer = $('channels-container');
  if (channelsContainer) channelsContainer.classList.add('loading');
  
  try{
    const j = await safeFetch(`/api/channels?mode=${encodeURIComponent(modeSel)}`);
    if(j.error){
      setStatus('disc-status','Channel fetch error: '+j.error);
    }else{
      const raw=j.channels||[];
      state.selected.forEach(id=>{
        if(!raw.find(c=>(c.id||c.name||c.clean)===id)) state.selected.delete(id);
      });
      visibleChannelCount=INITIAL_CHANNEL_BATCH;
      if(raw.length>PROGRESSIVE_CHANNEL_MAPPING_THRESHOLD) mapChannelsProgressive(raw);
      else {
        state.channels = raw.map(ch => ({
          id: ch.id || ch.name || ch.clean,
          name: ch.name || ch.clean || ch.id,
          clean: ch.clean || ch.name || ch.id,
          presence: ch.presence || '',
          present_count: ch.present_count ?? ch.occurrence ?? 0
        }));
        renderChannelTable();
        try {
          localStorage.setItem('mdf_channels', JSON.stringify(state.channels));
        } catch (e) {
          console.warn('Failed to store channels in localStorage:', e);
        }
        syncStateToPlayground();
      }
      const channelsContainerEl = $('channels-container');
      if (channelsContainerEl) {
        channelsContainerEl.style.display=state.channels.length?'block':'none';
      }
      setStatus('disc-status',`Channels: ${raw.length} (${j.mode})`);
    }
  }catch(e){ 
    setStatus('disc-status','Channel fetch exception: '+e.message); 
    console.error('Channel fetch error:', e);
  }
  finally{ 
    const channelsContainer = $('channels-container');
    if (channelsContainer) channelsContainer.classList.remove('loading'); 
  }
}

/* ====================== Search & Selection ====================== */
const channelSearch = $('channel-search');
if (channelSearch) {
  channelSearch.addEventListener('input',e=>{
    currentSearch=e.target.value.trim().toLowerCase();
    const container = $('channels-container');
    if (!container) return;
    const items = container.querySelectorAll('tbody tr');
    items.forEach(it => {
      const t = (it.textContent||'').toLowerCase();
      it.style.display = currentSearch === '' || t.includes(currentSearch) ? '' : 'none';
    });
  });
}

const selectAll = $('select-all');
if (selectAll) {
  selectAll.addEventListener('change',e=>{
    state.selected.clear();
    if(e.target.checked){
      const channelsBody = $('channels-body');
      if (channelsBody) {
        [...channelsBody.querySelectorAll('tr[data-id]')].forEach(tr=>state.selected.add(tr.getAttribute('data-id')));
      }
    }
    updateSelectedBox(); renderChannelTable();
  });
}

const clearBtn = $('btn-clear');
if (clearBtn) {
  clearBtn.addEventListener('click',()=>{
    state.selected.clear(); updateSelectedBox(); renderChannelTable();
  });
}

const exportSelectedBtn = $('btn-export-selected');
if (exportSelectedBtn) {
  exportSelectedBtn.onclick=()=>{
    const ids=[...state.selected]; if(!ids.length){toast('No selected IDs',{type:'error'});return;}
    const blob=new Blob([ids.join('\n')],{type:'text/plain'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
    a.download='selected_signals.txt'; a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href),800);
  };
}

const importSelectedBtn = $('btn-import-selected');
if (importSelectedBtn) {
  importSelectedBtn.onclick=()=>{
    const importFile = $('import-file');
    if (importFile) importFile.click();
  };
}

const importFile = $('import-file');
if (importFile) {
  importFile.addEventListener('change',async e=>{
    const file=e.target.files[0]; if(!file)return;
    const text=await file.text();
    const ids=[...new Set(text.split(/[\s,;,\t\r\n]+/).map(s=>s.trim()).filter(Boolean))];
    const known=new Set(state.channels.map(c=>c.id));
    let added=0;
    ids.forEach(id=>{ if(known.has(id)){state.selected.add(id);added++;} });
    updateSelectedBox(); renderChannelTable();
    toast(`Imported ${added} IDs (${ids.length-added} skipped)`,{type:'success'});
    e.target.value='';
  });
}

/* ====================== Channel Table Rendering ====================== */
const loadMoreBtn = $('btn-load-more');
if (loadMoreBtn) {
  loadMoreBtn.onclick=()=>{ if(visibleChannelCount<state.channels.length){visibleChannelCount+=CHANNEL_BATCH;renderChannelTable();}};
}

const loadAllBtn = $('btn-load-all');
if (loadAllBtn) {
  loadAllBtn.onclick=()=>{visibleChannelCount=state.channels.length;renderChannelTable();};
}

const toggleSelected = $('toggle-only-selected');
if (toggleSelected) {
  toggleSelected.addEventListener('change',()=>renderChannelTable(true));
}

function renderChannelTable(showAllMatches=false){
  const body=$('channels-body'); 
  if (!body) return;
  
  body.innerHTML='';
  let list=state.channels;
  const toggleSelected = $('toggle-only-selected');
  if (toggleSelected && toggleSelected.checked) list=list.filter(ch=>state.selected.has(ch.id));
  if(currentSearch) list=list.filter(ch=>(ch.clean||ch.id).toLowerCase().includes(currentSearch));
  const limit=(currentSearch||showAllMatches)?list.length:visibleChannelCount;
  const slice=list.slice(0,limit);
  slice.forEach(ch=>{
    const id=ch.id;
    const tr=document.createElement('tr');
    tr.className = 'channel-item'; // Add class for search filtering
    tr.setAttribute('data-id',id);
    tr.tabIndex=0;
    // Use display name from backend if available, otherwise extract it
    const displayName = ch.name || ch.label || extractDisplayName(ch.clean || id);
    tr.innerHTML=`<td><label for="ch-${id}" class="sr-only">Select ${esc(displayName)}</label><input type="checkbox" id="ch-${id}" name="ch-${id}" data-id="${esc(id)}" ${state.selected.has(id)?'checked':''}></td>
                  <td>${esc(displayName)}</td>
                  <td>${esc(ch.presence||'')}</td>
                  <td style="text-align:right">${ch.present_count}</td>`;
    body.appendChild(tr);
  });
  body.querySelectorAll('input[type=checkbox]').forEach(cb=>{
    cb.onchange=()=>{
      const id=cb.getAttribute('data-id');
      if(cb.checked) state.selected.add(id); else state.selected.delete(id);
      updateSelectedBox();
    };
  });
  body.querySelectorAll('tr').forEach(tr=>{
    tr.addEventListener('keydown',e=>{
      if(e.key===' '||e.key==='Enter'){
        e.preventDefault();
        const id=tr.getAttribute('data-id');
        if(state.selected.has(id)) state.selected.delete(id); else state.selected.add(id);
        updateSelectedBox();
        renderChannelTable(currentSearch||(toggleSelected && toggleSelected.checked));
      }
    });
  });
  
  const channelsContainer = $('channels-container');
  if (channelsContainer) {
    channelsContainer.style.display=slice.length?'block':'none';
  }
  
  const selectAll = $('select-all');
  if (selectAll) {
    selectAll.checked=slice.length>0 && slice.every(ch=>state.selected.has(ch.id||ch.clean));
  }
  
  const controls=$('channel-controls');
  if (controls) {
    if(list.length>INITIAL_CHANNEL_BATCH){
      controls.classList.remove('hidden');
      const loadMoreBtn = $('btn-load-more');
      if (loadMoreBtn) loadMoreBtn.disabled=visibleChannelCount>=list.length;
      
      const loadAllBtn = $('btn-load-all');
      if (loadAllBtn) loadAllBtn.disabled=visibleChannelCount>=list.length;
    } else {
      controls.classList.add('hidden');
    }
  }
}

function updateSelectedBox(){
  const ids=selectedIds();
  const selectedTextarea = $('selected');
  if (selectedTextarea) selectedTextarea.value=ids.join(',');
  
  const chips=$('selected-chips'); 
  if (chips) {
    chips.innerHTML='';
    const max=24;
    ids.slice(0,max).forEach(id=>{
      // Find channel and use display name
      const ch = state.channels.find(c => c.id === id);
      const displayName = ch ? (ch.name || ch.label || extractDisplayName(ch.clean || id)) : extractDisplayName(id);
      const span=document.createElement('span'); 
      span.className='chip'; 
      span.textContent=displayName;
      span.title=id; // Show full ID on hover
      chips.appendChild(span);
    });
    if(ids.length>max){
      const more=document.createElement('span'); more.className='chip'; more.textContent=`+${ids.length-max} more`; chips.appendChild(more);
    }
  }
  
  const anaSignals = $('ana-signals');
  const sigSourceHint = $('sig-source-hint');
  
  if(!state.userEditedSignals){
    if (anaSignals) anaSignals.value=ids.join(',');
    if (sigSourceHint) sigSourceHint.textContent='Auto-synced from selection.';
  } else if (sigSourceHint) {
    sigSourceHint.textContent='Manual override (only existing selected signals used).';
  }
  
  const clearBtn = $('btn-clear');
  if (clearBtn) clearBtn.disabled=!ids.length;
  
  const exportSelectedBtn = $('btn-export-selected');
  if (exportSelectedBtn) exportSelectedBtn.disabled=!ids.length;

  const sendToPgBtn = $('btn-send-playground');
  if (sendToPgBtn) sendToPgBtn.disabled = !ids.length;
  
  enforceLimit();
}

const copyIdsBtn = $('btn-copy-ids');
if (copyIdsBtn) {
  copyIdsBtn.onclick=()=>{
    const selectedTextarea = $('selected');
    if (selectedTextarea && selectedTextarea.value) {
      navigator.clipboard.writeText(selectedTextarea.value||'').then(()=>toast('IDs copied',{type:'success'}));
    }
  };
}

const toggleIdsBtn = $('btn-toggle-ids');
if (toggleIdsBtn) {
  toggleIdsBtn.onclick=()=>{
    const ta=$('selected'); 
    if (!ta) return;
    
    const show=ta.style.display==='none';
    ta.style.display=show?'block':'none';
    toggleIdsBtn.textContent=show?'Hide IDs':'Show IDs';
  };
}

// Send selected signals to Playground
const sendToPgBtn = $('btn-send-playground');
if (sendToPgBtn) {
  sendToPgBtn.addEventListener('click', () => {
    const ids = selectedIds();
    if (!ids || ids.length === 0) {
      toast('No signals selected to send to Playground', { type: 'error' });
      return;
    }

    // Update global state for playground
    window.state = window.state || {};
    window.state.selected = new Set(ids);

    toast(`${ids.length} signal(s) sent to Playground`, { type: 'success' });
    
    // Switch to the playground tab, which will trigger initialization and plotting
    activateTab('playground');
  });
}


const anaSignals = $('ana-signals');
if (anaSignals) {
  anaSignals.addEventListener('input',()=>{state.userEditedSignals=true;updateSelectedBox();});
}

function getCurrentSignalList(){
  const manualRaw=$('ana-signals')?.value.trim() || '';
  if(!manualRaw) return selectedIds();
  const set=new Set(selectedIds());
  return manualRaw.split(',').map(s=>s.trim()).filter(s=>s && set.has(s));
}

/* ====================== Analytics Toggles & Buttons ====================== */
['feature-fft','feature-hist','feature-multiy','feature-subplots','tickmode','feature-subplot-ticks'].forEach(id=>{
  const el=$(id); if(!el)return;
  el.addEventListener('change',()=>{
    if(state.lastSeries) redrawMainChart();
    if((id==='feature-fft'||id==='feature-hist')&&state.lastSeries)
      plotSignals({recompute:false});
  });
});

const plotBtn = $('btn-plot');
if (plotBtn) {
  plotBtn.onclick=()=>plotSignals({recompute:true});
}

const clearPlotBtn = $('btn-clear-plot');
if (clearPlotBtn) {
  clearPlotBtn.onclick=clearPlots;
}

const copyStatsBtn = $('btn-copy-stats');
if (copyStatsBtn) {
  copyStatsBtn.onclick=copyStats;
}

/* ====================== Threshold Functions ====================== */
function initThresholdControls() {
  const thresholdSignal = $('threshold-signal');
  const applyThresholdBtn = $('btn-apply-threshold');
  
  if (!thresholdSignal || !applyThresholdBtn) return;
  
  // Update threshold signal dropdown when signals are plotted
  if (state.lastSeries && Object.keys(state.lastSeries).length) {
    const currentVal = thresholdSignal.value;
    thresholdSignal.innerHTML = '<option value="">Select a signal</option>';
    Object.keys(state.lastSeries).forEach(id => {
      const option = document.createElement('option');
      option.value = id;
      option.textContent = state.lastSeries[id].name || id;
      thresholdSignal.appendChild(option);
    });
    
    // Restore previous selection if possible
    if ([...thresholdSignal.options].some(o => o.value === currentVal)) {
      thresholdSignal.value = currentVal;
    } else if (state.thresholds.signal && [...thresholdSignal.options].some(o => o.value === state.thresholds.signal)) {
      thresholdSignal.value = state.thresholds.signal;
    }
  }
  
  // Set current threshold values in inputs
  const thresholdMin = $('threshold-min');
  const thresholdMax = $('threshold-max');
  
  if (thresholdMin) thresholdMin.value = state.thresholds.min ?? '';
  if (thresholdMax) thresholdMax.value = state.thresholds.max ?? '';
  
  // Apply threshold button handler
  if (!applyThresholdBtn.hasAttribute('data-listener')) {
    applyThresholdBtn.addEventListener('click', () => {
      const signal = thresholdSignal.value;
      const minVal = thresholdMin.value ? parseFloat(thresholdMin.value) : null;
      const maxVal = thresholdMax.value ? parseFloat(thresholdMax.value) : null;
      
      if (!signal && (minVal !== null || maxVal !== null)) {
        toast('Please select a signal first', {type: 'error'});
        return;
      }
      
      // Update thresholds in state
      state.thresholds = {
        signal,
        min: minVal,
        max: maxVal,
        violations: []
      };
      
      // Detect violations if a signal is selected
      if (signal) {
        detectThresholdViolations();
      }
      
      // Redraw chart with threshold highlights
      redrawMainChart();
      
      toast('Thresholds updated successfully');
    });
    applyThresholdBtn.setAttribute('data-listener', 'true');
  }
}

function detectThresholdViolations() {
  if (!state.thresholds.signal || !state.lastSeries) return;
  
  const signalData = state.lastSeries[state.thresholds.signal];
  if (!signalData || !signalData.values || !signalData.timestamps) return;
  
  const { min, max } = state.thresholds;
  const violations = [];
  let inViolation = false;
  let violationStart = null;
  
  // Check each data point for threshold violations
  for (let i = 0; i < signalData.values.length; i++) {
    const value = signalData.values[i];
    const time = signalData.timestamps[i];
    const isViolation = (min !== null && value < min) || (max !== null && value > max);
    
    if (isViolation && !inViolation) {
      // Start of a violation
      inViolation = true;
      violationStart = time;
    } else if (!isViolation && inViolation) {
      // End of a violation
      inViolation = false;
      if (violationStart !== null) {
        violations.push({ start: violationStart, end: time });
      }
    }
  }
  
  // Handle case where violation continues to end of data
  if (inViolation && violationStart !== null) {
    violations.push({
      start: violationStart,
      end: signalData.timestamps[signalData.timestamps.length - 1],
    });
  }
  
  state.thresholds.violations = violations;
}

function addThresholdShapes(layout) {
    if (!state.thresholds.violations.length || !state.thresholds.signal) return [];

    const shapes = [];
    const color = state.thresholds.max !== null ? 'rgba(255, 0, 0, 0.2)' : 'rgba(0, 0, 255, 0.2)';
    
    state.thresholds.violations.forEach(v => {
        shapes.push({
            type: 'rect',
            xref: 'x', yref: 'paper',
            x0: v.start, y0: 0,
            x1: v.end, y1: 1,
            fillcolor: color,
            opacity: 0.5,
            line: { width: 0 }
        });
    });

    if (state.thresholds.min !== null) {
        shapes.push({
            type: 'line',
            xref: 'paper', yref: 'y',
            x0: 0, y0: state.thresholds.min,
            x1: 1, y1: state.thresholds.min,
            line: { color: 'blue', width: 2, dash: 'dash' }
        });
    }

    if (state.thresholds.max !== null) {
        shapes.push({
            type: 'line',
            xref: 'paper', yref: 'y',
            x0: 0, y0: state.thresholds.max,
            x1: 1, y1: state.thresholds.max,
            line: { color: 'red', width: 2, dash: 'dash' }
        });
    }

    return shapes;
}

/* ====================== Analytics Core ====================== */
function clearPlots(){
  ['analytics-plot-panel','fft-plot-panel','hist-plot-panel'].forEach(id=>{
      const panel = $(id);
      if(panel) {
          const plotDiv = panel.querySelector('.plotly-graph-div');
          if (plotDiv) Plotly.purge(plotDiv);
          panel.style.display='none';
      }
  });
  state.lastSeries=null; state.lastStats=[]; state.lastFFT=null; state.lastHist=null;
  state.hasFFT=false; state.hasHist=false;
  state.thresholds = { signal: null, min: null, max: null, violations: [] }; // Reset thresholds
  
  const clearPlotBtn = $('btn-clear-plot');
  if (clearPlotBtn) clearPlotBtn.disabled=true;
  
  const copyStatsBtn = $('btn-copy-stats');
  if (copyStatsBtn) copyStatsBtn.disabled=true;
  
  initThresholdControls(); // Clear dropdown and inputs
  setStatus('analytics-status','Cleared.');
}

function copyStats(){
  if(!state.lastStats.length){toast('No stats',{type:'error'});return;}
  navigator.clipboard.writeText(csvFromRows(state.lastStats)).then(()=>toast('Stats copied',{type:'success'}));
}

async function plotSignals({recompute=true}={}){
  if(state.plotting) return;
  const ids=getCurrentSignalList();
  if(!ids.length){setStatus('analytics-status','No signals selected');return;}
  enforceLimit(); if(ENFORCE_LIMIT && ids.length>MAX_SELECTED_SIGNALS) return;
  if(!recompute && state.lastSeries){redrawMainChart();return;}
  const fd=new FormData();
  fd.append('signals',ids.join(','));
  
  
  const maxPoints = $('max_points');
  if (maxPoints) fd.append('max_points',maxPoints.value||'100000');
  
  const wantFft = $('feature-fft');
  if (wantFft) fd.append('want_fft',wantFft.checked?'1':'0');
  
  const wantHist = $('feature-hist');
  if (wantHist) fd.append('want_hist',wantHist.checked?'1':'0');
  
  state.plotting=true;
  const plotBtn = $('btn-plot');
  if (plotBtn) {
    plotBtn.disabled=true;
    plotBtn.classList.add('btn-loading');
  }

  // Show plot panel immediately
  const plotPanel = $('analytics-plot-panel');
  if (plotPanel) plotPanel.style.display='block';
  
  setStatus('analytics-status',`Running /analytics (${ids.length})...`);
  try{
    const j = await safeFetch('/analytics',{method:'POST',body:fd});
    if(j.error){ setStatus('analytics-status','Error: '+j.error); return; }
    state.lastSeries=j.series||{};
    state.lastFFT=j.fft||{};
    state.lastHist=j.hist||{};
    state.lastStats=j.stats||[];
    state.hasFFT=!!Object.keys(state.lastFFT).length;
    state.hasHist=!!Object.keys(state.lastHist).length;

    initThresholdControls();
    if (state.thresholds.signal) {
        detectThresholdViolations();
    }
    
    redrawMainChart();
    renderStatsTable(state.lastStats);
    
    const copyStatsBtn = $('btn-copy-stats');
    if (copyStatsBtn) copyStatsBtn.disabled=!state.lastStats.length;
    
    const featureFft = $('feature-fft');
    if (featureFft && featureFft.checked && state.hasFFT) {
      drawFFT(state.lastFFT); 
    } else {
      const fftPlotPanel = $('fft-plot-panel');
      if (fftPlotPanel) fftPlotPanel.style.display='none';
    }
    
    const featureHist = $('feature-hist');
    if (featureHist && featureHist.checked && state.hasHist) {
      drawHist(state.lastHist); 
    } else {
      const histPlotPanel = $('hist-plot-panel');
      if (histPlotPanel) histPlotPanel.style.display='none';
    }
    
    const clearPlotBtn = $('btn-clear-plot');
    if (clearPlotBtn) clearPlotBtn.disabled=false;
    
    setStatus('analytics-status','/analytics complete.');
    
  }catch(e){
    setStatus('analytics-status','Exception: '+e.message);
    console.error('Plot signals error:', e);
  }finally{
    state.plotting=false;
    const plotBtn = $('btn-plot');
    if (plotBtn) {
      plotBtn.disabled=false;
      plotBtn.classList.remove('btn-loading');
    }
  }
}

/* ====================== Plot Helpers ====================== */
function baseProLayout(){
  const isLight = document.body.classList.contains('light-theme');
  return {
    paper_bgcolor: isLight ? 'white' : 'black',  // Deep black in dark mode like IUPR/fuel
    plot_bgcolor: isLight ? 'white' : 'black',  // Deep black in dark mode like IUPR/fuel
    margin:{l:72, r:26, t:48, b:54},
    hovermode:'x unified',
    dragmode:'zoom',
    legend:{orientation:'h', y:-0.12, font:{size:11}},
    font:{color: isLight ? '#2d3748' : '#dce1e6'},
    xaxis:{gridcolor: isLight ? '#e2e8f0' : '#2d353a', zeroline:false},
    yaxis:{gridcolor: isLight ? '#e2e8f0' : '#2d353a', zeroline:false}
  };
}


function applyAxisStyle(ax,{tickmode,isX=false,includeTime=false}){
  const o={...ax};
  if(typeof o.title==='string') o.title={text:o.title,standoff:12};
  else o.title={...(o.title||{}),standoff:12};
  o.tickmode=tickmode;
  o.automargin=true;
  o.showgrid=true;
  o.gridcolor= document.body.classList.contains('light-theme') ? '#e2e8f0' : '#30383e';
  o.zeroline=false;
  if(isX && includeTime) o.tickformat=',.3f';
  if(!isX) o.tickformat=',.3f';
  o.rangeslider={visible:false};
  o.showspikes=true; o.spikemode='across'; o.spikesnap='cursor';
  o.spikecolor='#ff758d'; o.spikethickness=1;
  return o;
}

function makeHoverTemplate(name,unit,includeTime){
  const displayName = extractDisplayName(name);
  const xFmt=includeTime?'t=%{x:,.3f}s':'n=%{x}';
  const u=unit?(' '+unit):'';
  return `<b>${esc(displayName)}</b><br>${xFmt}<br>%{y:,.3f}${esc(u)}<extra></extra>`;
}

/* ====================== Analytics Redraw ====================== */
function redrawMainChart(){
  const plotPanel = $('analytics-plot-panel');
  
  if(!state.lastSeries){
    if (plotPanel) plotPanel.style.display='none';
    return;
  }
  
  const ids=Object.keys(state.lastSeries);
  if(!ids.length){
    if (plotPanel) plotPanel.style.display='none';
    return;
  }
  
  const plotDiv=$('analytics-plot');
  if (!plotDiv) return;
  
  if (plotPanel) plotPanel.style.display = 'block';

  const tickmodeSelect = $('tickmode');
  const tickmode = tickmodeSelect ? tickmodeSelect.value : 'auto';
  
  const includeTimeChecked = false;
  
  const multiY = $('feature-multiy');
  const multi = multiY ? multiY.checked : false;
  
  const subplots = $('feature-subplots');
  const wantSubplots = subplots ? subplots.checked && !multi : false;
  
  const subplotTicks = $('feature-subplot-ticks');
  const showSubplotTicks = subplotTicks ? subplotTicks.checked : false;
  
  const maxPoints = $('ana-maxpoints');
  const maxDisplay = maxPoints ? parseInt((maxPoints.value||'10000'),10) : 10000;

  const traces = [];
  const layout = baseProLayout();
  
  // Ensure proper theme colors for analytics plots
  const isLight = document.body.classList.contains('light-theme');
  const isDark = !isLight;
  if (isLight) {
    layout.paper_bgcolor = 'white';
    layout.plot_bgcolor = 'white';
    layout.font = { ...(layout.font || {}), color: '#2d3748' };
    // Update axis grid colors for light mode
    if (layout.xaxis) layout.xaxis.gridcolor = '#e2e8f0';
    if (layout.yaxis) layout.yaxis.gridcolor = '#e2e8f0';
    // Ensure all yaxes in subplots also have light grid
    Object.keys(layout).forEach(key => {
      if (key.startsWith('yaxis') && layout[key] && typeof layout[key] === 'object') {
        layout[key].gridcolor = '#e2e8f0';
        if (!layout[key].tickfont) layout[key].tickfont = {};
        layout[key].tickfont.color = '#2d3748';
      }
      if (key.startsWith('xaxis') && layout[key] && typeof layout[key] === 'object') {
        layout[key].gridcolor = '#e2e8f0';
        if (!layout[key].tickfont) layout[key].tickfont = {};
        layout[key].tickfont.color = '#2d3748';
      }
    });
  } else {
    layout.paper_bgcolor = 'black';  // Deep black like IUPR/fuel
    layout.plot_bgcolor = 'black';  // Deep black like IUPR/fuel
    layout.font = { ...(layout.font || {}), color: '#dce1e6' };
    // Update axis grid colors for dark mode
    if (layout.xaxis) layout.xaxis.gridcolor = '#2d353a';
    if (layout.yaxis) layout.yaxis.gridcolor = '#2d353a';
    // Ensure all yaxes in subplots also have dark grid
    Object.keys(layout).forEach(key => {
      if (key.startsWith('yaxis') && layout[key] && typeof layout[key] === 'object') {
        layout[key].gridcolor = '#2d353a';
      }
    });
  }
  
  layout.shapes = addThresholdShapes(layout);
  
  // Reset subplot specific styles
  plotPanel.classList.remove('subplots-active');
  plotDiv.classList.remove('subplots-active');
  
  if(multi && ids.length>1){
    ids.forEach((id,i)=>{
      let X=state.lastSeries[id].timestamps.slice();
      let Y=state.lastSeries[id].values.slice();
      if(X.length>maxDisplay){
        const step=Math.ceil(X.length/maxDisplay);
        X=X.filter((_,k)=>k%step===0); Y=Y.filter((_,k)=>k%step===0);
      }
      const rawName = state.lastSeries[id].name || id;
      const nm = extractDisplayName(rawName);
      const unit=state.lastSeries[id].unit||'';
      traces.push({
        x:X,y:Y,type:'scatter',mode:'lines',name:nm,
        yaxis:i===0?'y':'y'+(i+1),
        line:{width:1.6},
        hovertemplate:makeHoverTemplate(nm,unit,includeTimeChecked)
      });
    });
    layout.xaxis=applyAxisStyle({title:'Time'},{tickmode,isX:true,includeTime:includeTimeChecked});
    ids.forEach((id,i)=>{
      const rawName = state.lastSeries[id].name || id;
      const nm = extractDisplayName(rawName);
      const key=i===0?'yaxis':'yaxis'+(i+1);
      layout[key]=applyAxisStyle({title:nm},{tickmode});
      if(i>0){
        layout[key].overlaying='y';
        layout[key].showgrid=false;
        layout[key].side=(i%2===0?'left':'right');
      }
    });
    Plotly.newPlot(plotDiv,traces,layout,{responsive:true,displaylogo:false, scrollZoom:true}).then(()=>safePlotlyResize(plotDiv));
    plotPanel.style.display='block';
    return;
  }

  if(wantSubplots){
      plotPanel.classList.add('subplots-active');
      plotDiv.classList.add('subplots-active');
      const seriesMap={};
      ids.forEach(id=>{
        let X=state.lastSeries[id].timestamps.slice();
        let Y=state.lastSeries[id].values.slice();
        if(X.length>maxDisplay){
          const step=Math.ceil(X.length/maxDisplay);
          X=X.filter((_,k)=>k%step===0); Y=Y.filter((_,k)=>k%step===0);
        }
        const rawName = state.lastSeries[id].name || id;
        seriesMap[id]={x:X,y:Y,name:extractDisplayName(rawName)};
      });

      (function renderAnalyticsSubplots(subIds, seriesMapRef, plotDivRef){
        const laneNames=subIds.map(id=>(seriesMapRef[id]?.name||id));
        const rows=Math.max(1,laneNames.length);

        const isLight = document.body.classList.contains('light-theme');
        const isDark = !isLight;
        const gridColor = isLight ? '#e2e8f0' : '#2d353a';
        const textColor = isLight ? '#4a5568' : '#dce1e6';
        
        const data=[];
        const subplotsLayout={
          ...baseProLayout(),
          grid:{rows,columns:1,pattern:'independent',ygap:0.06},
          margin:{l:showSubplotTicks?60:40,r:24,t:32,b:52},
          hovermode:'x unified',
          showlegend:false,
          uirevision:'analytics-subplots',
          shapes: layout.shapes,
          autosize: true
        };
        
        // Ensure proper theme colors for analytics subplots
        if (isLight) {
          subplotsLayout.paper_bgcolor = 'white';
          subplotsLayout.plot_bgcolor = 'white';
          subplotsLayout.font = { ...(subplotsLayout.font || {}), color: '#2d3748' };
        } else {
          subplotsLayout.paper_bgcolor = 'black';  // Deep black like IUPR/fuel
          subplotsLayout.plot_bgcolor = 'black';  // Deep black like IUPR/fuel
          subplotsLayout.font = { ...(subplotsLayout.font || {}), color: '#dce1e6' };
        }
        
        for(let i=1;i<=rows;i++){
          const xa='xaxis'+(i===1?'':i);
          const ya='yaxis'+(i===1?'':i);
          subplotsLayout[xa]={
            showgrid:true,gridcolor:gridColor,zeroline:false,
            automargin:true,
            title:(i===rows?{text:'Time',standoff:12}:''),
            ...(i>1?{matches:'x'}:{})
          };
          subplotsLayout[ya]= showSubplotTicks ? {
            showgrid:true,gridcolor:gridColor,zeroline:false,
            automargin:true,
            showticklabels:true,
            ticks:'outside',
            tickfont:{size:9,color: isLight ? '#718096' : '#9da7b3'},
            title:''
          } : {
            showgrid:true,gridcolor:gridColor,zeroline:false,
            automargin:true,
            showticklabels:false,
            ticks:'',
            title:''
          };
        }
        const annotations=[];
        subIds.forEach((id,idx)=>{
          const r=idx+1;
          const s=seriesMapRef[id]||{x:[],y:[],name:id};
          const raw=laneNames[idx]||'';
          const displayName = extractDisplayName(raw);
          const name=displayName.length<=34?displayName:displayName.slice(0,33)+'…';
          data.push({
            type:'scattergl',
            mode:'lines',
            x:s.x,y:s.y,
            line:{width:1.6},
            cliponaxis:false,
            xaxis:'x'+(r===1?'':r),
            yaxis:'y'+(r===1?'':r),
            hovertemplate:`<b>${name}</b><br>t=%{x:.3f}<br>v=%{y}<extra></extra>`
          });
          const xref=r===1?'x domain':`x${r} domain`;
          const yref=r===1?'y domain':`y${r} domain`;
          annotations.push({
            xref,x:0.01,xanchor:'left',
            yref,y:0.95,yanchor:'top',
            text:name,showarrow:false,align:'left',
            font:{size:11,color:textColor},
            bgcolor: isLight ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.35)',
            bordercolor: isLight ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.08)',
            borderwidth:1,borderpad:2
          });
        });
        subplotsLayout.annotations=annotations;
        Plotly.react(plotDivRef,data,subplotsLayout,{responsive:true,displaylogo:false, scrollZoom:true}).then(()=>safePlotlyResize(plotDivRef));
        plotPanel.style.display='block';
      })(ids,seriesMap,plotDiv);
      return;
  }

  ids.forEach(id => {
    let X=state.lastSeries[id].timestamps.slice();
    let Y=state.lastSeries[id].values.slice();
    if(X.length>maxDisplay){
      const step=Math.ceil(X.length/maxDisplay);
      X=X.filter((_,k)=>k%step===0); Y=Y.filter((_,k)=>k%step===0);
    }
    const rawName = state.lastSeries[id].name || id;
    const nm = extractDisplayName(rawName);
    const unit=state.lastSeries[id].unit||'';
    traces.push({
      x:X,y:Y,type:'scatter',mode:'lines',name:nm,
      line:{width:1.7},
      hovertemplate:makeHoverTemplate(nm,unit,includeTimeChecked)
    });
  });
  
  layout.xaxis=applyAxisStyle({title:'Time'},{tickmode,isX:true,includeTime:includeTimeChecked});
  const yAxisTitle = ids.length === 1 ? extractDisplayName(state.lastSeries[ids[0]].name || ids[0]) : '';
  layout.yaxis=applyAxisStyle({title: yAxisTitle},{tickmode});
  Plotly.newPlot(plotDiv,traces,layout,{responsive:true,displaylogo:false, scrollZoom:true}).then(()=>safePlotlyResize(plotDiv));
  plotPanel.style.display='block';
}

function drawFFT(fftObj){
  const div=$('fft-plot');
  const panel = $('fft-plot-panel');
  if(!fftObj||!Object.keys(fftObj).length){
    if (panel) panel.style.display='none';
    return;
  }
  if (panel) panel.style.display = 'block';

  const traces=[];
  for(const id of Object.keys(fftObj)){
    const f=fftObj[id]; const half=Math.floor(f.freq.length/2);
    const rawName = state.lastSeries[id]?.name || id;
    const nm = extractDisplayName(rawName);
    traces.push({x:f.freq.slice(0,half),y:f.amplitude.slice(0,half),type:'scatter',mode:'lines',name:nm,line:{width:1.6}});
  }
  const fftLayout = {
    ...baseProLayout(),
        title: {
      text: 'FFT (Magnitude)',
      x: 0.5,
      xanchor: 'center',
      font: { size: 14 },
      pad: { t: 6, b: 0 }
    },
    xaxis:applyAxisStyle({title:'Frequency (norm)'},{tickmode:'auto',isX:true,includeTime:false}),
    yaxis:applyAxisStyle({title:'Amplitude'},{tickmode:'auto'}),
    autosize: true
  };
  
  // Ensure proper theme colors
  const isLight = document.body.classList.contains('light-theme');
  if (isLight) {
    fftLayout.paper_bgcolor = 'white';
    fftLayout.plot_bgcolor = 'white';
    fftLayout.font = { ...(fftLayout.font || {}), color: '#2d3748' };
    if (fftLayout.xaxis) fftLayout.xaxis.gridcolor = '#e2e8f0';
    if (fftLayout.yaxis) fftLayout.yaxis.gridcolor = '#e2e8f0';
  } else {
    fftLayout.paper_bgcolor = 'black';  // Deep black like IUPR/fuel
    fftLayout.plot_bgcolor = 'black';  // Deep black like IUPR/fuel
    fftLayout.font = { ...(fftLayout.font || {}), color: '#dce1e6' };
    if (fftLayout.xaxis) fftLayout.xaxis.gridcolor = '#2d353a';
    if (fftLayout.yaxis) fftLayout.yaxis.gridcolor = '#2d353a';
  }
  
  Plotly.newPlot(div,traces,fftLayout,{responsive:true,displaylogo:false, scrollZoom:true}).then(()=>safePlotlyResize(div));
}

function drawHist(histObj){
  const div=$('hist-plot');
  const panel = $('hist-plot-panel');
  if(!histObj||!Object.keys(histObj).length){
    if (panel) panel.style.display='none';
    return;
  }
  if (panel) panel.style.display = 'block';

  const traces=[];
  for(const id of Object.keys(histObj)){
    const h=histObj[id]; const mids=[];
    for(let i=0;i<h.bins.length-1;i++) mids.push((h.bins[i]+h.bins[i+1])/2);
    const rawName = state.lastSeries[id]?.name || id;
    const nm = extractDisplayName(rawName);
    traces.push({x:mids,y:h.hist,type:'bar',name:nm,opacity:0.6});
  }
  const histLayout = {
    ...baseProLayout(),
    barmode:'overlay',
        title: {
      text: 'Histogram',
      x: 0.5,
      xanchor: 'center',
      font: { size: 14 },
      pad: { t: 6, b: 0 }
    },
    xaxis:applyAxisStyle({title:'Value'},{tickmode:'auto',isX:true,includeTime:false}),
    yaxis:applyAxisStyle({title:'Count'},{tickmode:'auto'}),
    autosize: true
  };
  
  // Ensure proper theme colors
  const isLight = document.body.classList.contains('light-theme');
  if (isLight) {
    histLayout.paper_bgcolor = 'white';
    histLayout.plot_bgcolor = 'white';
    histLayout.font = { ...(histLayout.font || {}), color: '#2d3748' };
    if (histLayout.xaxis) histLayout.xaxis.gridcolor = '#e2e8f0';
    if (histLayout.yaxis) histLayout.yaxis.gridcolor = '#e2e8f0';
  } else {
    histLayout.paper_bgcolor = 'black';  // Deep black like IUPR/fuel
    histLayout.plot_bgcolor = 'black';  // Deep black like IUPR/fuel
    histLayout.font = { ...(histLayout.font || {}), color: '#dce1e6' };
    if (histLayout.xaxis) histLayout.xaxis.gridcolor = '#2d353a';
    if (histLayout.yaxis) histLayout.yaxis.gridcolor = '#2d353a';
  }
  
  Plotly.newPlot(div,traces,histLayout,{responsive:true,displaylogo:false, scrollZoom:true}).then(()=>safePlotlyResize(div));
}

function renderStatsTable(stats){
  const root=$('stats-table');
  if (!root) return;
  
  const isLight = document.body.classList.contains('light-theme');
  
  // Google-like professional color scheme
  const colors = isLight ? {
    wrapperBorder: '#e1e5eb',
    wrapperBg: '#ffffff',
    scrollbarThumb: 'rgba(0,0,0,0.2)',
    scrollbarThumbHover: 'rgba(0,0,0,0.3)',
    headerBg: '#f8f9fa',
    headerColor: '#1a1d21',
    headerBorder: '#e1e5eb',
    rowBgEven: '#f8f9fa',
    rowBgHover: '#f1f3f5',
    cellColor: '#1a1d21',
    cellBorder: '#e1e5eb',
    emptyMsg: '#5a6572'
  } : {
    wrapperBorder: 'rgba(255,255,255,0.05)',
    wrapperBg: 'rgba(0,0,0,0.1)',
    scrollbarThumb: 'rgba(255,255,255,0.2)',
    scrollbarThumbHover: 'rgba(255,255,255,0.3)',
    headerBg: 'rgba(255,255,255,0.08)',
    headerColor: '#fff',
    headerBorder: 'rgba(255,255,255,0.1)',
    rowBgEven: 'rgba(255,255,255,0.02)',
    rowBgHover: 'rgba(255,255,255,0.08)',
    cellColor: 'rgba(255,255,255,0.8)',
    cellBorder: 'rgba(255,255,255,0.05)',
    emptyMsg: 'rgba(255,255,255,0.7)'
  };
  
  root.innerHTML='';
  if(!stats.length){
    root.innerHTML=`<div class="small" style="color:${colors.emptyMsg};padding:12px 0;">No stats available</div>`;
    return;
  }
  const cols=Object.keys(stats[0]);
  // Create professional scrollable table wrapper with Google-like styling
  root.innerHTML=`<div class="table-wrapper" style="border-radius:8px;overflow-x:auto;overflow-y:visible;max-width:100%;border:1px solid ${colors.wrapperBorder};background:${colors.wrapperBg};scrollbar-width:thin;scrollbar-color:${colors.scrollbarThumb} transparent;">
    <style>
      #stats-table .table-wrapper::-webkit-scrollbar { height:6px; width:6px; }
      #stats-table .table-wrapper::-webkit-scrollbar-track { background:transparent; border-radius:3px; }
      #stats-table .table-wrapper::-webkit-scrollbar-thumb { background:${colors.scrollbarThumb}; border-radius:3px; border:1px solid transparent; background-clip:padding-box; }
      #stats-table .table-wrapper::-webkit-scrollbar-thumb:hover { background:${colors.scrollbarThumbHover}; }
    </style>
    <table style="width:100%;min-width:max-content;border-collapse:separate;border-spacing:0;font-size:0.875rem;">
      <thead>
        <tr>${cols.map(c=>`<th style="padding:10px 12px;background:${colors.headerBg} !important;color:${colors.headerColor} !important;font-weight:600;text-transform:uppercase;font-size:0.75rem;letter-spacing:0.05em;text-align:left;border-bottom:1px solid ${colors.headerBorder};position:sticky;top:0;z-index:5;">${esc(c)}</th>`).join('')}</tr>
      </thead>
      <tbody style="background:transparent;">
        ${stats.map((r,i)=>`<tr style="transition:background-color 0.15s ease;${i%2===0?`background:${colors.rowBgEven};`:''}">
          ${cols.map(c=>{
            const val=r[c];
            if(val===null||val===undefined||val==='') return `<td style="padding:10px 12px;border-bottom:1px solid ${colors.cellBorder};color:${colors.cellColor};line-height:1.5;">-</td>`;
            if(typeof val==='number'){
              if(isNaN(val)) return `<td class="num" style="padding:10px 12px;border-bottom:1px solid ${colors.cellBorder};color:${colors.cellColor};text-align:right;font-family:'SF Mono',Monaco,Consolas,monospace;font-variant-numeric:tabular-nums;">-</td>`;
              return `<td class="num" style="padding:10px 12px;border-bottom:1px solid ${colors.cellBorder};color:${colors.cellColor};text-align:right;font-family:'SF Mono',Monaco,Consolas,monospace;font-variant-numeric:tabular-nums;">${val.toLocaleString('en-US',{maximumFractionDigits:3})}</td>`;
            }
            return `<td style="padding:10px 12px;border-bottom:1px solid ${colors.cellBorder};color:${colors.cellColor};line-height:1.5;word-wrap:break-word;overflow-wrap:break-word;max-width:200px;white-space:normal;">${esc(String(val))}</td>`;
          }).join('')}
        </tr>`).join('')}
      </tbody>
    </table>
  </div>`;
  
  // Add hover effect via JavaScript for better control
  const rows = root.querySelectorAll('tbody tr');
  rows.forEach(row => {
    row.addEventListener('mouseenter', function() {
      this.style.backgroundColor = colors.rowBgHover;
    });
    row.addEventListener('mouseleave', function() {
      const index = Array.from(this.parentNode.children).indexOf(this);
      this.style.backgroundColor = index % 2 === 0 ? colors.rowBgEven : 'transparent';
    });
  });
}

/* ====================== Report Helpers ====================== */
function setPrimaryTableAndMeta(section,payload){
  const key=PRIMARY_TABLE_KEYS[section];
  let rows=[];
  if(key && payload.tables && payload.tables[key]) rows=payload.tables[key];
  state.lastPrimaryTableData=Array.isArray(rows)?rows:[];
  state.lastPrimaryMeta=payload.meta||{};
  
  // Show/hide CSV download button
  const csvContainer = $('section-download-csv-container');
  if (csvContainer) {
    csvContainer.style.display = state.lastPrimaryTableData.length > 0 ? 'block' : 'none';
  }
}

// CSV download button handler
const downloadSectionCsvBtn = $('btn-download-section-csv');
if (downloadSectionCsvBtn) {
  downloadSectionCsvBtn.onclick = () => {
    if (!state.lastPrimaryTableData.length) {
      toast('No table data to download', {type:'error'});
      return;
    }
    const csvContent = csvFromRows(state.lastPrimaryTableData);
    const blob = new Blob([csvContent], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `report_${state.currentReportSection}_table.csv`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 800);
    toast('CSV downloaded successfully', {type:'success'});
  };
}

function renderReportMetaDiagnostic(section, meta, container){
  if(!meta || !meta.error) return;
  const box=document.createElement('div');
  box.className='status dark';
  box.style.maxHeight='unset';
  box.style.margin='0 0 14px';
  box.textContent= `Error: ${meta.error}`;
  container.prepend(box);
}

// Helper function to clean trace names in Plotly data
function cleanPlotlyTraceNames(plotlyData) {
  if (!plotlyData) return plotlyData;
  const cleaned = { ...plotlyData };
  
  // Clean trace names in data array
  if (cleaned.data && Array.isArray(cleaned.data)) {
    cleaned.data = cleaned.data.map(trace => {
      const cleanedTrace = { ...trace };
      if (cleanedTrace.name) {
        cleanedTrace.name = extractDisplayName(cleanedTrace.name);
      }
      // Also clean any text labels if they contain signal names
      if (cleanedTrace.text && Array.isArray(cleanedTrace.text)) {
        cleanedTrace.text = cleanedTrace.text.map(t => 
          typeof t === 'string' ? extractDisplayName(t) : t
        );
      }
      return cleanedTrace;
    });
  }
  
  // Clean axis titles in layout
  if (cleaned.layout) {
    const layout = { ...cleaned.layout };
    // Clean xaxis title
    if (layout.xaxis && layout.xaxis.title) {
      const title = layout.xaxis.title;
      if (typeof title === 'string') {
        layout.xaxis.title = extractDisplayName(title);
      } else if (title.text) {
        layout.xaxis.title = { ...title, text: extractDisplayName(title.text) };
      }
    }
    // Clean yaxis title
    if (layout.yaxis && layout.yaxis.title) {
      const title = layout.yaxis.title;
      if (typeof title === 'string') {
        layout.yaxis.title = extractDisplayName(title);
      } else if (title.text) {
        layout.yaxis.title = { ...title, text: extractDisplayName(title.text) };
      }
    }
    // Clean secondary axes (yaxis2, yaxis3, etc.)
    Object.keys(layout).forEach(key => {
      if (key.startsWith('yaxis') || key.startsWith('xaxis')) {
        if (layout[key] && layout[key].title) {
          const title = layout[key].title;
          if (typeof title === 'string') {
            layout[key] = { ...layout[key], title: extractDisplayName(title) };
          } else if (title.text) {
            layout[key] = { ...layout[key], title: { ...title, text: extractDisplayName(title.text) } };
          }
        }
      }
    });
    // Clean annotation text
    if (layout.annotations && Array.isArray(layout.annotations)) {
      layout.annotations = layout.annotations.map(ann => {
        if (ann.text && typeof ann.text === 'string') {
          return { ...ann, text: extractDisplayName(ann.text) };
        }
        return ann;
      });
    }
    cleaned.layout = layout;
  }
  
  return cleaned;
}

function renderProfessionalPlot(container,spec){
  try{
    const raw=spec.plotly_json;
    const pj=(typeof raw==='string')?JSON.parse(raw):(raw||{});
    // Clean trace names before rendering
    const cleanedPj = cleanPlotlyTraceNames(pj);
    const data=Array.isArray(cleanedPj.data)?cleanedPj.data.map(t=>({...t})):[];
    let layout=cleanedPj.layout?{...cleanedPj.layout}:{};
    
    const isLight = document.body.classList.contains('light-theme');
    const isDark = !isLight;
    const fg= isLight ? '#2d3748' : '#dce1e6';
    const grid= isLight ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.08)';
    
    layout = {...baseProLayout(), ...layout}; // Merge with base
    layout.autosize = true;
    layout.font = {...layout.font, color:fg, family:"Segoe UI, Roboto, Inter, Arial, sans-serif"};
    
    // Ensure proper theme colors (baseProLayout already sets these, but we override to be explicit)
    if (isLight) {
      layout.paper_bgcolor = 'white';
      layout.plot_bgcolor = 'white';
      layout.font = {...(layout.font || {}), color: '#2d3748'};
      if (layout.xaxis) layout.xaxis.gridcolor = '#e2e8f0';
      if (layout.yaxis) layout.yaxis.gridcolor = '#e2e8f0';
    } else {
      layout.paper_bgcolor = 'black';  // Deep black like IUPR/fuel
      layout.plot_bgcolor = 'black';  // Deep black like IUPR/fuel
      layout.font = {...(layout.font || {}), color: '#dce1e6'};
      if (layout.xaxis) layout.xaxis.gridcolor = '#2d353a';
      if (layout.yaxis) layout.yaxis.gridcolor = '#2d353a';
    }
    
    const fixAxis=(ax,isX)=>{
      ax={...(ax||{})};
      if(typeof ax.title==='string') ax.title={text:ax.title,standoff:12};
      else ax.title={...(ax.title||{}),standoff:12};
      ax.showgrid=true; ax.gridcolor=grid; ax.zeroline=false; ax.automargin=true;
      if(!isX && !ax.tickformat) ax.tickformat=',.3f';
      ax.tickfont={color:fg};
      ax.titlefont={color:fg};
      return ax;
    };
    layout.xaxis=fixAxis(layout.xaxis,true);
    layout.yaxis=fixAxis(layout.yaxis,false);
    
    Plotly.newPlot(container, data, layout, {responsive: true, displaylogo:false, scrollZoom: true}).then(()=>safePlotlyResize(container));
  }catch(e){container.textContent='Plot error: '+e.message;}
}

function renderGenericReport(section, payload, root) {
    const tables = payload.tables || {};
    const plots = payload.plots || {};

    const grid = document.createElement('div');
    grid.className = 'report-grid two-col';
    const left = document.createElement('div');
    left.className = 'report-col';
    const right = document.createElement('div');
    right.className = 'report-col accent-panel';

    // First, add grid to DOM so containers have dimensions
    grid.appendChild(left);
    grid.appendChild(right);
    root.appendChild(grid);

    // Store plot rendering tasks to execute after DOM insertion
    const plotRenderTasks = [];

    if (Object.keys(plots).length) {
        Object.keys(plots).forEach(name => {
            const spec = plots[name];
            // Handle both formats:
            // 1. Old format: {type: 'plotly', plotly_json: '...'}
            // 2. New format: {plotly_json: '...'} (direct from custom_gear.py, custom_misfire.py)
            let plotlyJson = null;
            
            if (spec?.plotly_json) {
                // Direct plotly_json (new format)
                try {
                    plotlyJson = typeof spec.plotly_json === 'string' 
                        ? JSON.parse(spec.plotly_json) 
                        : spec.plotly_json;
                    // Clean trace names before rendering
                    plotlyJson = cleanPlotlyTraceNames(plotlyJson);
                } catch (e) {
                    console.error(`Failed to parse plotly_json for ${name}:`, e);
                    console.error('Plotly JSON (first 500 chars):', typeof spec.plotly_json === 'string' ? spec.plotly_json.substring(0, 500) : spec.plotly_json);
                    return;
                }
            } else if (spec?.type === 'plotly' && spec?.plotly_json) {
                // Old format with type field
                try {
                    plotlyJson = typeof spec.plotly_json === 'string'
                        ? JSON.parse(spec.plotly_json)
                        : spec.plotly_json;
                    // Clean trace names before rendering
                    plotlyJson = cleanPlotlyTraceNames(plotlyJson);
                } catch (e) {
                    console.error(`Failed to parse plotly_json for ${name}:`, e);
                    return;
                }
            } else if (spec?.data && spec?.layout) {
                // Already a plotly object
                plotlyJson = cleanPlotlyTraceNames(spec);
            } else {
                console.warn(`Skipping plot ${name}: no valid plotly_json found`, spec);
                return;
            }
            
            if (!plotlyJson || !plotlyJson.data || !plotlyJson.layout) {
                console.warn(`Skipping plot ${name}: invalid structure`, {hasData: !!plotlyJson?.data, hasLayout: !!plotlyJson?.layout, plotlyJson});
                return;
            }
            
            // Validate data is an array
            if (!Array.isArray(plotlyJson.data)) {
                console.error(`Plot ${name}: data is not an array`, plotlyJson.data);
                return;
            }
            
            // Check if this is a subplot figure (has grid in layout) - gear hunt uses make_subplots
            const isSubplot = plotlyJson.layout && (plotlyJson.layout.grid || 
                plotlyJson.layout.xaxis2 || plotlyJson.layout.yaxis2 ||
                Object.keys(plotlyJson.layout).some(k => k.startsWith('xaxis') && k !== 'xaxis') ||
                Object.keys(plotlyJson.layout).some(k => k.startsWith('yaxis') && k !== 'yaxis'));
            
            // Log for debugging (especially for speed vs fuel plot)
            if (name === 'Speed vs Fuel Consumption') {
                console.log(`[${section}] 🚗 Rendering Speed vs Fuel plot with ${plotlyJson.data.length} traces`);
                console.log(`[${section}] Speed vs Fuel - Data traces:`, plotlyJson.data.map(t => ({name: t.name, points: t.x?.length || 0})));
                console.log(`[${section}] Speed vs Fuel - Layout height:`, plotlyJson.layout?.height);
            }
            console.debug(`[${section}] Rendering plot "${name}" with ${plotlyJson.data.length} traces${isSubplot ? ' (subplot figure)' : ''}`);
            
            const panel = document.createElement('div');
            panel.className = 'plot-panel';
            panel.innerHTML = `<div class="plot-title">${esc(name)}</div><div class="plotly-graph-div" style="width:100%;min-height:420px;border-radius:8px;"></div>`;
            left.appendChild(panel);
            
            // Store render task to execute after DOM is ready
            const plotDiv = panel.querySelector('.plotly-graph-div');
            plotRenderTasks.push({ plotDiv, plotlyJson, name, panel });
        });
        
        // Render all plots after DOM insertion
        setTimeout(() => {
            plotRenderTasks.forEach(({ plotDiv, plotlyJson, name, panel }) => {
                if (typeof Plotly === 'undefined') {
                    console.error('Plotly is not loaded!');
                    plotDiv.innerHTML = '<div style="padding: 20px; color: red;">Error: Plotly library not loaded. Please refresh the page.</div>';
                    return;
                }
                
                try {
                    // Ensure plot div has proper dimensions
                    const containerWidth = plotDiv.offsetWidth || panel.offsetWidth || 800;
                    const plotHeight = Math.max(400, (panel.offsetHeight || 450) - 60);
                    
                    // Prepare layout with proper dimensions
                    // For subplot figures (like gear hunt), preserve the original height if it's reasonable
                    const isSubplot = plotlyJson.layout && (plotlyJson.layout.grid || 
                        plotlyJson.layout.xaxis2 || plotlyJson.layout.yaxis2 ||
                        Object.keys(plotlyJson.layout).some(k => k.startsWith('xaxis') && k !== 'xaxis') ||
                        Object.keys(plotlyJson.layout).some(k => k.startsWith('yaxis') && k !== 'yaxis'));
                    
                    const originalHeight = plotlyJson.layout.height || plotHeight;
                    // Use original height for subplots if it's reasonable (e.g., 1200 for multi-panel plots)
                    const finalHeight = (isSubplot && originalHeight > 600) ? originalHeight : plotHeight;
                    
                    // Store isSubplot for use in the callback
                    const plotIsSubplot = isSubplot;
                    
                    // Ensure proper theme colors for all plots
                    const isLight = document.body.classList.contains('light-theme');
                    const isDark = !isLight;
                    const layout = { 
                        ...plotlyJson.layout,
                        autosize: true,
                        width: containerWidth,
                        height: finalHeight
                    };
                    
                    // Apply theme colors based on current mode
                    if (isLight) {
                        // Light mode - white background with dark text
                        layout.paper_bgcolor = 'white';
                        layout.plot_bgcolor = 'white';
                        if (!layout.font) layout.font = {};
                        layout.font.color = '#2d3748';
                        
                        // Update all axes for light mode
                        const updateAxisForLight = (ax) => {
                            if (!ax) return;
                            ax.gridcolor = ax.gridcolor || '#e2e8f0';
                            ax.linecolor = ax.linecolor || '#cbd5e0';
                            if (!ax.tickfont) ax.tickfont = {};
                            ax.tickfont.color = ax.tickfont.color || '#2d3748';
                            if (typeof ax.title === 'string') {
                                ax.title = { text: ax.title, font: { color: '#2d3748' } };
                            } else if (ax.title && typeof ax.title === 'object') {
                                if (!ax.title.font) ax.title.font = {};
                                ax.title.font.color = '#2d3748';
                            }
                        };
                        
                        updateAxisForLight(layout.xaxis);
                        updateAxisForLight(layout.yaxis);
                        
                        // Handle subplots
                        if (isSubplot) {
                            Object.keys(layout).forEach(key => {
                                if ((key.startsWith('xaxis') || key.startsWith('yaxis')) && 
                                    layout[key] && typeof layout[key] === 'object') {
                                    updateAxisForLight(layout[key]);
                                }
                            });
                        }
                    } else {
                        // Dark mode - black background with light text
                        // Force deep black background for dark mode if template is plotly_dark or if in reports section
                        if (section === 'gear' || section === 'ccsl' || section === 'misfire' || 
                            section === 'iupr' || section === 'fuel' ||
                            plotlyJson.layout?.template === 'plotly_dark' || 
                            plotlyJson.layout?.paper_bgcolor === 'rgba(0,0,0,0)' ||
                            plotlyJson.layout?.paper_bgcolor === 'black') {
                            layout.paper_bgcolor = 'black';  // Deep black like IUPR/fuel
                            layout.plot_bgcolor = 'black';  // Deep black like IUPR/fuel
                            // Ensure font color is light for dark mode
                            if (!layout.font) layout.font = {};
                            layout.font.color = '#dce1e6';
                            
                            // For gear hunt subplots, ensure all yaxes have proper styling
                            if (isSubplot) {
                                Object.keys(layout).forEach(key => {
                                    if (key.startsWith('yaxis') && layout[key] && typeof layout[key] === 'object') {
                                        const yax = layout[key];
                                        yax.gridcolor = yax.gridcolor || 'rgba(255,255,255,0.1)';
                                        yax.linecolor = yax.linecolor || 'rgba(255,255,255,0.3)';
                                        if (!yax.tickfont) yax.tickfont = {};
                                        yax.tickfont.color = yax.tickfont.color || '#dce1e6';
                                        if (!yax.title || typeof yax.title === 'string') {
                                            yax.title = { text: yax.title || '', font: { color: '#dce1e6' } };
                                        } else if (yax.title && typeof yax.title === 'object') {
                                            if (!yax.title.font) yax.title.font = {};
                                            yax.title.font.color = '#dce1e6';
                                        }
                                    }
                                    if (key.startsWith('xaxis') && layout[key] && typeof layout[key] === 'object') {
                                        const xax = layout[key];
                                        xax.gridcolor = xax.gridcolor || 'rgba(255,255,255,0.1)';
                                        xax.linecolor = xax.linecolor || 'rgba(255,255,255,0.3)';
                                        if (!xax.tickfont) xax.tickfont = {};
                                        xax.tickfont.color = xax.tickfont.color || '#dce1e6';
                                        if (!xax.title || typeof xax.title === 'string') {
                                            xax.title = { text: xax.title || '', font: { color: '#dce1e6' } };
                                        } else if (xax.title && typeof xax.title === 'object') {
                                            if (!xax.title.font) xax.title.font = {};
                                            xax.title.font.color = '#dce1e6';
                                        }
                                    }
                                });
                            }
                        }
                    }
                    
                    // Preserve yaxis4 configuration for gear hunt (speed/RPM dual axis)
                    if (section === 'gear' && plotlyJson.layout?.yaxis4) {
                        layout.yaxis4 = { ...plotlyJson.layout.yaxis4, ...(layout.yaxis4 || {}) };
                        // Ensure yaxis4 styling is preserved
                        if (!layout.yaxis4.gridcolor) layout.yaxis4.gridcolor = 'rgba(255,255,255,0.1)';
                        if (!layout.yaxis4.tickfont) layout.yaxis4.tickfont = {};
                        if (!layout.yaxis4.tickfont.color) layout.yaxis4.tickfont.color = '#dce1e6';
                    }
                    
                    // Ensure plot container is visible
                    panel.style.display = 'block';
                    panel.style.visibility = 'visible';
                    plotDiv.style.display = 'block';
                    plotDiv.style.visibility = 'visible';
                    
                    console.debug(`[${section}] Rendering "${name}": ${plotlyJson.data.length} traces, ${containerWidth}x${plotHeight}px`);
                    
                    // Use react instead of newPlot for better handling of subplots and updates
                    const config = {
                        responsive: true,
                        displaylogo: false,
                        scrollZoom: true,
                        modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                        autosize: true,
                        useResizeHandler: true
                    };
                    
                    Plotly.react(plotDiv, plotlyJson.data, layout, config).then(() => {
                        if (name === 'Speed vs Fuel Consumption') {
                            console.log(`[${section}] ✅ Speed vs Fuel plot rendered successfully`);
                            const plotElement = plotDiv.querySelector('.js-plotly-plot');
                            console.log(`[${section}] Speed vs Fuel - Plot element exists:`, !!plotElement);
                            if (plotElement) {
                                console.log(`[${section}] Speed vs Fuel - Plot element dimensions:`, {
                                    width: plotElement.offsetWidth,
                                    height: plotElement.offsetHeight,
                                    visible: plotElement.offsetParent !== null
                                });
                            }
                        }
                        console.debug(`[${section}] ✅ Plot "${name}" rendered successfully`);
                        // Resize after render to ensure proper scaling, especially for subplots
                        setTimeout(() => {
                            if (Plotly && Plotly.Plots && plotDiv.querySelector('.js-plotly-plot')) {
                                Plotly.Plots.resize(plotDiv);
                            }
                        }, plotIsSubplot ? 500 : 300); // Longer delay for subplots
                    }).catch(err => {
                        console.error(`[${section}] ❌ Plotly.react failed for "${name}":`, err);
                        // Try fallback to newPlot
                        try {
                            Plotly.newPlot(plotDiv, plotlyJson.data, layout, config).then(() => {
                                console.debug(`[${section}] ✅ Plot "${name}" rendered with newPlot fallback`);
                                setTimeout(() => {
                                    if (Plotly && Plotly.Plots && plotDiv.querySelector('.js-plotly-plot')) {
                                        Plotly.Plots.resize(plotDiv);
                                    }
                                }, 500);
                            });
                        } catch (fallbackErr) {
                            plotDiv.innerHTML = `<div style="padding: 20px; color: var(--danger);">
                                <strong>Failed to render plot: ${name}</strong><br>
                                <small>${err.message || String(err)}</small><br>
                                <small>Fallback also failed: ${fallbackErr.message}</small>
                            </div>`;
                        }
                    });
                } catch (err) {
                    console.error(`[${section}] ❌ Failed to render plot ${name}:`, err);
                    plotDiv.innerHTML = `<div style="padding: 20px; color: var(--danger);">Failed to render plot: ${err.message}</div>`;
                }
            });
        }, 100); // Small delay to ensure DOM is ready
        
    } else {
        left.innerHTML += '<div class="small">No plots available for this section.</div>';
    }

    if (Object.keys(tables).length) {
        Object.keys(tables).forEach(name => {
            const rows = tables[name] || [];
            const card = document.createElement('div');
            card.className = 'table-card';
            card.innerHTML = `<h4>${esc(name)}</h4>`;
            if (!rows.length) {
                card.innerHTML += '<div class="small">No data.</div>';
            } else {
                const cols = Object.keys(rows[0]);
                // Determine which columns should wrap (long text columns)
                const wrapCols = new Set(['description','details','error','message','channel_name','file','monitor','dfc_name']);
                
                // Create a professional scrollable table
                card.innerHTML += `<div class="table-wrapper"><table><thead><tr>${cols.map(c => {
                    const shouldWrap = wrapCols.has(c.toLowerCase());
                    return `<th class="${shouldWrap ? 'wrap' : ''}">${esc(String(c))}</th>`;
                }).join('')}</tr></thead><tbody>${
                    rows.slice(0, 500).map(r => `<tr>${cols.map(c => {
                        const val = r[c];
                        const shouldWrap = wrapCols.has(c.toLowerCase());
                        // Handle null/undefined values
                        if (val === null || val === undefined || val === '') return `<td class="${shouldWrap ? 'wrap' : ''}">-</td>`;
                        // Format numbers appropriately
                        if (typeof val === 'number') {
                            if (isNaN(val)) return `<td class="num">-</td>`;
                            // Format based on magnitude
                            if (Math.abs(val) < 0.01 && val !== 0) {
                                return `<td class="num">${val.toExponential(2)}</td>`;
                            }
                            return `<td class="num">${val.toLocaleString('en-US', {maximumFractionDigits: 3})}</td>`;
                        }
                        // Handle arrays/lists
                        if (Array.isArray(val)) {
                            return `<td class="${shouldWrap ? 'wrap' : ''}">${esc(String(val.join(', ')))}</td>`;
                        }
                        // Long strings get wrapped
                        const strVal = String(val);
                        return `<td class="${shouldWrap || strVal.length > 30 ? 'wrap' : ''}" title="${esc(strVal)}">${esc(strVal)}</td>`;
                    }).join('')}</tr>`).join('')
                }</tbody></table></div>${rows.length > 500 ? '<div class="small" style="margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.05);">Showing first 500 of ' + rows.length + ' rows.</div>' : ''}`;
            }
            right.appendChild(card);
        });
    } else {
        right.innerHTML += '<div class="small">No tables available for this section.</div>';
    }

    grid.appendChild(left);
    grid.appendChild(right);
    root.appendChild(grid);
}


function renderReportSection(section,payload){
  setPrimaryTableAndMeta(section,payload);
  
  const reportTimestamp = $('report-timestamp');
  if (reportTimestamp) {
    const timeStr = new Date((payload.meta?.generated_at||Date.now()/1000)*1000).toLocaleTimeString();
    reportTimestamp.textContent = section.toUpperCase() + ' generated at ' + timeStr;
  }
  
  const root=$(`report-${section}`); 
  if (!root) return;
  
  root.innerHTML='';
  renderReportMetaDiagnostic(section,payload.meta,root);
  if(payload.meta && payload.meta.error) return;
  
  // The new map UI is self-contained and does not use this generic renderer.
  if (section !== 'map') {
      renderGenericReport(section, payload, root);
      
      // Ensure plots resize when section becomes visible
      setTimeout(() => {
          const plotDivs = root.querySelectorAll('.plotly-graph-div');
          plotDivs.forEach(div => {
              if (Plotly && Plotly.Plots && div.querySelector('.js-plotly-plot')) {
                  Plotly.Plots.resize(div);
              }
          });
      }, 500);
  }
}

/* ====================== Report Fetch & Controls ====================== */
function updateReportControlsState() {
    const hasFiles = state.fileCount > 0;
    $('btn-report').disabled = !hasFiles;
    document.querySelectorAll('.subtabs button').forEach(btn => btn.disabled = !hasFiles);

    const ts = $('report-timestamp');
    if (ts) {
        ts.textContent = hasFiles ? 'Ready to generate reports.' : 'Upload a file to generate reports.';
    }
}


function setReportSpinner(show){
  const reportSpinner = $('report-spinner');
  if (reportSpinner) reportSpinner.style.display=show?'flex':'none';
}

async function loadReportSection(section, opts = {}) {
  const { force = false } = opts;
  if (state.fileCount === 0) {
      updateReportControlsState();
      return;
  }
  state.currentReportSection = section;
  const map = { dfc:'report-dfc', iupr:'report-iupr', gear:'report-gear', misfire:'report-misfire', ccsl:'report-ccsl', fuel:'report-fuel', map: 'report-map' };
  Object.values(map).forEach(id => {
    const el = $(id);
    if (el) el.style.display = 'none';
  });
  if (!map[section]) return;
  const sectionEl = $(map[section]);
  if (sectionEl) {
      sectionEl.style.display = 'block';
      // Trigger resize for plots when section becomes visible
      setTimeout(() => {
          const plotDivs = sectionEl.querySelectorAll('.plotly-graph-div');
          plotDivs.forEach(div => {
              if (Plotly && Plotly.Plots && div.querySelector('.js-plotly-plot')) {
                  Plotly.Plots.resize(div);
              }
          });
      }, 300);
  }

  // If Empirical Map tab, load the file list
  if (section === 'map' && typeof loadUploadedFiles === 'function') {
      loadUploadedFiles();
  }
  
  // The new map UI handles its own data fetching, so we skip the generic fetch for it.
  if (section === 'map') {
      return;
  }
  
  if (!force && state.reportCache[section]) {
    renderReportSection(section, state.reportCache[section]);
    return;
  }
  setReportSpinner(true);
  try {
    const fd = new FormData();
    fd.append('section', section);
    const j = await safeFetch('/api/report_section', { method: 'POST', body: fd });
    if (j.error) {
      const reportTimestamp = $('report-timestamp');
      if (reportTimestamp) reportTimestamp.textContent = 'Error: ' + j.error;
      toast(j.error, { type: 'error' });
    } else {
      state.reportCache[section] = j;
      renderReportSection(section, j);
    }
  } catch (e) {
    const reportTimestamp = $('report-timestamp');
    if (reportTimestamp) reportTimestamp.textContent = 'Fetch exception: ' + e.message;
    console.error('Report section load error:', e);
  }
  setReportSpinner(false);
}
const reportBtn = $('btn-report');
if (reportBtn) {
  reportBtn.onclick=()=>{
    if (state.fileCount === 0) {
        toast('Please upload a file first.', {type:'warn'});
        return;
    }
    state.reportCache={};
    const reportTimestamp = $('report-timestamp');
    if (reportTimestamp) reportTimestamp.textContent='Cache cleared.';
    loadReportSection(state.currentReportSection,{force:true});
    toast('Report cache cleared',{type:'success'});
  };
}


const subtabs = document.querySelectorAll('.subtabs button');
if (subtabs.length) {
  subtabs.forEach(btn=>{
    btn.addEventListener('click',()=>{
      if(btn.classList.contains('active') || btn.disabled) return;
      document.querySelectorAll('.subtabs button').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      loadReportSection(btn.dataset.sub);
    });
  });
}


/* ====================== Tab Switching ====================== */
window.activateTab = function(id) {
  const sectionId = id.startsWith('sec-') ? id : 'sec-' + id;
  const tabId = id.replace('sec-', '');

  ['sec-upload','sec-analyse','sec-report','sec-files','sec-playground'].forEach(s => {
    const el = $(s);
    if (el) el.style.display = 'none';
  });
  
  if (tabId === 'analyse') {
    const uploadEl = $('sec-upload');
    if (uploadEl) uploadEl.style.display = 'block';
  }
  
  if (tabId === 'playground') {
    const uploadEl = $('sec-upload');
    if (uploadEl) uploadEl.style.display = 'none';
  }

  const tabEl = $(sectionId);
  if (tabEl) tabEl.style.display = 'block';
  
  document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
  
  const tabBtn = $(`tabbtn-${tabId}`);
  if (tabBtn) tabBtn.classList.add('active');
  
  if (REPORT_AUTO_REFRESH_ON_TAB && tabId === 'report' && state.fileCount > 0) {
    loadReportSection(state.currentReportSection, {});
  }
  
  if (tabId === 'playground') {
    if (typeof initPlayground === 'function') {
        initPlayground();
    }
  }
  
  if (tabId === 'files') {
    refreshFileList();
  }
  
  // When switching tabs, ensure all plots resize to their containers
  setTimeout(()=>{ safeResizeAllPlots(); }, 140);
}


/* ====================== Custom Map Generation ===================== */
function populateMissingSignalsModal(missing) {
  const container = document.getElementById('missing-signals-list');
  const modal = document.getElementById('missing-signals-modal');
  if (!container || !modal) return;
  
  container.innerHTML = '';
  const channels = (window.state && window.state.channels) ? window.state.channels : [];

  const missingArray = Array.isArray(missing) ? missing : Object.entries(missing).map(([key, tries]) => ({ key, tries: Array.isArray(tries) ? tries : [tries] }));

  missingArray.forEach(m => {
    const wrapper = document.createElement('div');
    wrapper.style.marginBottom = '8px';
    const label = document.createElement('div');
    label.style.fontSize='13px';
    label.style.marginBottom='4px';
    label.textContent = `${m.key} (tried: ${m.tries.join(', ')})`;
    wrapper.appendChild(label);

    const sel = document.createElement('select');
    sel.dataset.role = m.key;
    sel.style.width = '100%';
    sel.innerHTML = '<option value="">-- choose channel --</option>' + channels.map(ch => {
      const val = (typeof ch === 'string') ? ch : (ch.id || ch.name || ch.clean);
      const labelText = (typeof ch === 'string') ? ch : (ch.clean || ch.name || ch.id);
      return `<option value="${esc(val)}">${esc(labelText)}</option>`;
    }).join('');
    wrapper.appendChild(sel);
    container.appendChild(wrapper);
  });

  modal.classList.remove('hidden');

  document.getElementById('missing-cancel').onclick = () => {
    modal.classList.add('hidden');
  };

  document.getElementById('missing-confirm').onclick = async () => {
    const overrides = {};
    container.querySelectorAll('select').forEach(sel => {
      if (sel.value) overrides[sel.dataset.role] = sel.value;
    });
    
    modal.classList.add('hidden');
    
    try {
      const payload = window.__lastMapRequestPayload || {};
      payload.overrides = {...(payload.overrides || {}), ...overrides};
      const res = await safeFetch('/api/compute_map', { method:'POST', body: JSON.stringify(payload), headers: {'Content-Type':'application/json'}});
      handleMapResponse(res);
    } catch (e) {
      toast('Failed to re-run map: '+e.message, {type:'error'});
    }
  };
}

async function fetchUploadedFiles() {
  try {
    const j = await safeFetch('/api/files');
    if (j && !j.error) return j;
  } catch (e) { /* ignore and try old */ }
  try {
    const j2 = await safeFetch('/api/list_uploaded_files');
    return j2 || {};
  } catch (e2) {
    return { files: [] };
  }
}

async function loadUploadedFiles() {
  try {
    console.debug('loadUploadedFiles: fetching files from API');
    const j = await fetchUploadedFiles();
    console.debug('loadUploadedFiles: API response:', j);
    const files = Array.isArray(j.files) ? j.files : [];
    console.debug('loadUploadedFiles: processed files:', files.length, files);
    const container = $('map-file-list');
    if (!container) {
      console.warn('loadUploadedFiles: container not found');
      return;
    }
    container.innerHTML = '';
    if (files.length === 0) {
      container.innerHTML = '<div class="small">No files uploaded.</div>';
      return;
    }
    files.forEach((f, index) => {
      console.debug(`loadUploadedFiles: processing file ${index}:`, f);
      const fileData = (typeof f === 'string') ? { name: f.split(/[\\/]/).pop(), path: f } : f;
      const id = 'file_' + btoa(fileData.path || fileData.name).replace(/=/g, '').slice(0,12);
      const cb = document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.value = fileData.path || fileData.name; cb.checked=true;
      const lbl = document.createElement('label'); lbl.htmlFor=id; lbl.textContent = fileData.name;
      const row = document.createElement('div'); row.appendChild(cb); row.appendChild(lbl);
      container.appendChild(row);
    });
    console.debug('loadUploadedFiles: finished loading files');
  } catch (e) {
    console.error("Failed to load uploaded files list", e);
    toast("Could not load file list for map generation.", {type:'error'});
  }
}

function parseBinsText(txt){
  if(!txt) return null;
  txt = txt.trim();
  if(txt.includes(':')){
    const parts = txt.split(':').map(Number);
    if(parts.length === 3 && !parts.some(isNaN)){
      const [start, stop, step] = parts;
      if (step <= 0) return null;
      const arr = [];
      for (let v = start; v < stop; v += step) arr.push(v);
      return arr;
    }
  }
  return txt.split(',').map(s=>Number(s.trim())).filter(n=>!isNaN(n));
}

function handleMapResponse(res) {
    console.debug('handleMapResponse: received response:', res);

    // Only show missing signals modal for critical signals, not optional ones
    if (res.meta?.missing_signals && Object.keys(res.meta.missing_signals).length > 0) {
        const criticalSignals = ['rpm', 'torque'];
        const missingCritical = Object.keys(res.meta.missing_signals).filter(signal => criticalSignals.includes(signal));
        
        if (missingCritical.length > 0) {
            console.debug('handleMapResponse: missing critical signals detected:', missingCritical);
        populateMissingSignalsModal(res.meta.missing_signals);
            toast('Map generation requires critical signals (RPM, Torque).', { type: 'warn' });
        return;
        } else {
            console.debug('handleMapResponse: only optional signals missing, proceeding with generation');
            // Don't show popup for optional signals - just proceed with generation
            toast('Some optional signals missing, but proceeding with available data.', { type: 'info' });
        }
    }

    // Check for errors - meta.ok can be undefined (treat as success) or explicitly false
    if (res.meta && res.meta.ok === false) {
        const errorMsg = res.meta?.error || res.error || 'Map generation failed on server.';
        console.debug('handleMapResponse: error detected:', errorMsg, 'meta:', res.meta);
        if (errorMsg === 'no_input_data') {
            toast('No data files selected. Please upload files first and select them for map generation.', { type: 'error' });
        } else {
            toast(errorMsg, { type: 'error' });
        }
        return;
    }
    
    // If no meta or meta.ok is true/undefined, proceed with display
    if (!res.meta) {
        res.meta = { ok: true }; // Default to success if no meta
    }

    console.debug('handleMapResponse: success, displaying results');
    window.currentMapResults = res;
    
    // Ensure result container is visible
    const resultsEl = document.getElementById('map-results');
    if (resultsEl) {
        resultsEl.style.display = 'block';
    }
    
    // Small delay to ensure DOM is ready before rendering
    setTimeout(() => {
        displayMapResults(res);
    }, 100);
}

const MAP_PRESETS = {
  "ci_engine_default": { label: "CI Engine — BSFC", x_candidates: ["EngineSpeed","rpm","Ext_nEng","Epm_EngSpeed"], y_candidates: ["EngineTorque","Trq_Ext","Torque","EngineLoad"], z_candidates: ["BSFC","FuelMassFlow","FuelRate","bsfc_gpkwh"], x_bins: "100:6000:100", y_bins: "0:600:5", min_samples_per_bin: 8, interp_method: "rbf", smoothing: 1.0 },
  "si_engine_default": { label:"SI Engine — Efficiency / AFR", x_candidates:["EngineSpeed","rpm","Ext_nEng"], y_candidates:["EngineTorque","Trq_Ext","EngineLoad"], z_candidates:["BrakePower","BSFC","AFR","Lambda"], x_bins:"500:7000:100", y_bins:"0:300:5", min_samples_per_bin:6, interp_method:"cubic", smoothing:0.6 },
  "electric_motor_default": { label:"Electric Motor — Efficiency", x_candidates:["MotorSpeed","emotor_speed","RPM_motor"], y_candidates:["MotorTorque","emotor_trq"], z_candidates:["MotorEfficiency","efficiency","eff"], x_bins:"0:20000:200", y_bins:"-400:400:10", min_samples_per_bin:6, interp_method:"rbf", smoothing:1.0 },
  "afr_wide": { label:"AFR Wide", x_candidates:["EngineSpeed","rpm"], y_candidates:["EngineLoad","Torque","ThrottlePosition"], z_candidates:["AFR","Lambda","O2_Sensor"], x_bins:"500:7000:100", y_bins:"0:1:0.02", min_samples_per_bin:10, interp_method:"cubic", smoothing:0.5 },
  "developer_custom": { label:"Developer custom", x_candidates:["EngineSpeed","rpm"], y_candidates:["EngineTorque","Load"], z_candidates:["Your_Z_Signal"], x_bins:"100:6000:100", y_bins:"0:400:5", min_samples_per_bin:6, interp_method:"linear", smoothing:0.5 }
};

let mapAutoGenerationTimer = null;

function findChannelMatch(candidates){
  const chans = (window.state && window.state.channels) ? window.state.channels : [];
  for (const cand of candidates){
    const lc = String(cand).toLowerCase();
    for (const ch of chans){
      const name = (ch.name||ch.id||ch.clean||'').toString().toLowerCase();
      if (name.includes(lc)) return ch.id || ch.name || ch;
    }
  }
  return '';
}

function applyMapPreset(key){
  if(!key) return;
  const cfg = MAP_PRESETS[key];
  if(!cfg) { console.warn('Preset not found', key); return; }
  const x = findChannelMatch(cfg.x_candidates);
  const y = findChannelMatch(cfg.y_candidates);
  const z = findChannelMatch(cfg.z_candidates);
  if (x) document.getElementById('map-x-axis').value = x;
  if (y) document.getElementById('map-y-axis').value = y;
  if (z) document.getElementById('map-z-axis').value = z;
  if (cfg.x_bins) document.getElementById('map-rpm-bins').value = cfg.x_bins;
  if (cfg.y_bins) document.getElementById('map-tq-bins').value = cfg.y_bins;
  if (cfg.min_samples_per_bin) document.getElementById('map-min-samples').value = cfg.min_samples_per_bin;
  if (cfg.interp_method) document.getElementById('map-interp-method').value = cfg.interp_method;
  if (cfg.smoothing !== undefined) document.getElementById('map-smoothing').value = cfg.smoothing;
  toast('Preset applied: ' + cfg.label, {type:'success'});

  if (mapAutoGenerationTimer) clearTimeout(mapAutoGenerationTimer);
  mapAutoGenerationTimer = setTimeout(() => {
    const autoApply = document.getElementById('auto-apply-preset');
    if (autoApply && autoApply.checked) {
      generateEmpiricalMap().catch(err => console.error('Auto-generate map failed', err));
    }
  }, 250);
}

function collectMapOptions(){
  const mapType = document.getElementById('map-type')?.value || 'heatmap';
  const checkedFiles = Array.from(document.getElementById('map-file-list')?.querySelectorAll('input:checked') || []);
  const files = checkedFiles.map(i => i.value);

  console.debug('collectMapOptions: checked files:', checkedFiles.length, 'files:', files);

  const payload = {
    preset: document.getElementById('map-preset')?.value || null,
    files: files,
    x_axis: document.getElementById('map-x-axis')?.value || null,
    y_axis: document.getElementById('map-y-axis')?.value || null,
    z_axis: document.getElementById('map-z-axis')?.value || null,
    rpm_bins: parseBinsText(document.getElementById('map-rpm-bins')?.value),
    tq_bins: parseBinsText(document.getElementById('map-tq-bins')?.value),
    min_samples_per_bin: Number(document.getElementById('map-min-samples')?.value) || 6,
    interp_method: document.getElementById('map-interp-method')?.value || 'linear',
    smoothing: Number(document.getElementById('map-smoothing')?.value) || 0,
    map_type: mapType,
    enable_surface: mapType !== 'heatmap',
    enable_contours: mapType !== 'surface'
  };

  if (!payload.preset) {
    delete payload.preset;
  }

  console.debug('collectMapOptions: payload files:', payload.files);

  const previousOverrides = window.__lastMapRequestPayload?.overrides;
  if (previousOverrides && Object.keys(previousOverrides).length) {
    payload.overrides = { ...previousOverrides };
  }

  return payload;
}

async function generateEmpiricalMap(evt) {
    if (evt && typeof evt.preventDefault === 'function') evt.preventDefault();
    const statusEl = document.getElementById('map-status');
    const resultsEl = document.getElementById('map-results');
    const generateBtn = document.getElementById('generate-map');
    const progressEl = document.getElementById('map-progress');

    showStatus('Generating map...', 'loading');
    if(generateBtn) generateBtn.classList.add('btn-loading');
    
    // Show progress display
    if(progressEl) {
        progressEl.style.display = 'block';
        displayProgressStages({
            "file_loading": {"progress": 0, "status": "processing", "message": "Loading files..."},
            "signal_mapping": {"progress": 0, "status": "pending", "message": "Waiting..."},
            "data_validation": {"progress": 0, "status": "pending", "message": "Waiting..."},
            "physics_calculations": {"progress": 0, "status": "pending", "message": "Waiting..."},
            "map_generation": {"progress": 0, "status": "pending", "message": "Waiting..."},
            "optimization": {"progress": 0, "status": "pending", "message": "Waiting..."},
            "visualization": {"progress": 0, "status": "pending", "message": "Waiting..."}
        }, 0);
    }

    const payload = collectMapOptions();
  window.__lastMapRequestPayload = payload;

    try {
        console.debug('generateEmpiricalMap: payload:', payload);

        if (!payload.files || payload.files.length === 0) {
            throw new Error('No files selected for map generation');
        }
        // Only require axes if no preset is selected
        if (!payload.preset && (!payload.x_axis || !payload.y_axis || !payload.z_axis)) {
            throw new Error('Please select a preset OR select X, Y, and Z axes');
        }

        console.debug('generateEmpiricalMap: sending request to /api/compute_map');
        console.debug('generateEmpiricalMap: payload:', JSON.stringify(payload, null, 2));
        
        // Update initial progress state
        if(progressEl) {
            displayProgressStages({
                "file_loading": {"progress": 0, "status": "processing", "message": "Sending request..."},
                "signal_mapping": {"progress": 0, "status": "pending", "message": "Waiting..."},
                "data_validation": {"progress": 0, "status": "pending", "message": "Waiting..."},
                "physics_calculations": {"progress": 0, "status": "pending", "message": "Waiting..."},
                "map_generation": {"progress": 0, "status": "pending", "message": "Waiting..."},
                "optimization": {"progress": 0, "status": "pending", "message": "Waiting..."},
                "visualization": {"progress": 0, "status": "pending", "message": "Waiting..."}
            }, 0);
        }
        
        const res = await safeFetch('/api/compute_map', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        
        console.debug('generateEmpiricalMap: received response:', res);
        
        // Update progress immediately when response arrives (before handling)
        if (res.meta?.progress) {
            const progress = res.meta.progress;
            if (progress.stages) {
                displayProgressStages(progress.stages, progress.overall_progress || 100);
            }
        }

        // Handle response - check for errors first
        if (!res || res.error) {
            throw new Error(res.error || 'Unknown error from server');
        }

        handleMapResponse(res);

        if (res.meta?.ok !== false) {
            showStatus('Map Generated', 'success');
            
            // Display final progress (ensure all stages show as complete)
            if (res.meta?.progress) {
                const progress = res.meta.progress;
                if (progress.stages) {
                    // Mark all stages as complete if overall is 100%
                    const finalStages = {...progress.stages};
                    if (progress.overall_progress >= 100) {
                        Object.keys(finalStages).forEach(stage => {
                            if (finalStages[stage].progress < 100) {
                                finalStages[stage] = {
                                    ...finalStages[stage],
                                    progress: 100,
                                    status: 'complete',
                                    message: 'Complete'
                                };
                            }
                        });
                    }
                    displayProgressStages(finalStages, 100);
                }
            }
            
            if(resultsEl) {
                resultsEl.style.display = 'block';
                
                // Show heatmap view by default and ensure it's visible
                const heatmapDiv = document.getElementById('map-heatmap');
                const surfaceDiv = document.getElementById('map-surface');
                const statsDiv = document.getElementById('map-stats');
                
                if (heatmapDiv) heatmapDiv.style.display = 'block';
                if (surfaceDiv) surfaceDiv.style.display = 'none';
                if (statsDiv) statsDiv.style.display = 'none';
                
                // Update button states
                document.querySelectorAll('.map-view-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.view === 'heatmap') {
                        btn.classList.add('active');
                    }
                });
                
                // Ensure plots are rendered after a short delay
                setTimeout(() => {
                    if (window.currentMapResults) {
                        displayMapResults(window.currentMapResults);
                    }
                }, 200);
            }
        } else {
            // Show error in progress display
            const errorMsg = res.meta?.error || res.error || 'Unknown error';
            showStatus('Error: ' + errorMsg, 'error');
            if (progressEl) {
                const errorHtml = `<div style="padding: 10px; background: var(--danger-bg); color: var(--danger); border-radius: var(--radius);">
                    <strong>Error:</strong> ${errorMsg}
                </div>`;
                progressEl.innerHTML = errorHtml;
            }
        }

    } catch (err) {
        console.error(err);
        showStatus('Error: ' + (err.message || String(err)), 'error');
    } finally {
        if(generateBtn) generateBtn.classList.remove('btn-loading');
        setTimeout(() => { if(statusEl) statusEl.style.display = 'none'; }, 4000);
    }
}

async function displayMapResults(res) {
  const heatmapDiv = document.getElementById('map-heatmap');
  const surfaceDiv = document.getElementById('map-surface');
  const statsContent = document.getElementById('map-stats-content');
  const metaContent = document.getElementById('map-meta');

  if (!heatmapDiv || !surfaceDiv || !statsContent || !metaContent) return;

  const { tables, plots, meta } = res || {};

  // Clear previous content but preserve structure
  // Only clear if there's existing plot content to avoid breaking Plotly
  if (heatmapDiv.querySelector('.js-plotly-plot')) {
    Plotly.purge(heatmapDiv);
  }
  if (surfaceDiv.querySelector('.js-plotly-plot')) {
    Plotly.purge(surfaceDiv);
  }
  
  heatmapDiv.innerHTML = '';
  surfaceDiv.innerHTML = '';
  statsContent.innerHTML = '';
  metaContent.innerHTML = '';

  if (!plots || Object.keys(plots).length === 0) {
    console.warn("Map response contains no plottable data.");
    statsContent.innerHTML = '<h4>Statistics</h4><p>No data available for plotting.</p>';
    metaContent.innerHTML = '<h4>Metadata</h4><p>No metadata available.</p>';
    return; // Exit early if no plots
  }

  // Find heatmap and surface plots
  const viewPlots = {
    heatmap: null,
    surface: null
  };
  
  console.debug('Processing plots dictionary:', Object.keys(plots));
  console.debug('Plots structure:', plots);
  
  for (const [key, plotData] of Object.entries(plots)) {
    // Handle both direct plotly_json and nested structure
    let plotlyJson = null;
    if (typeof plotData === 'string') {
      try {
        plotlyJson = JSON.parse(plotData);
      } catch (e) {
        console.warn('Failed to parse plot data as string', key, e);
        continue;
      }
    } else if (plotData && plotData.plotly_json) {
      try {
        const pj = plotData.plotly_json;
        if (typeof pj === 'string') {
          plotlyJson = JSON.parse(pj);
        } else if (pj && (pj.data || pj.layout)) {
      // Already parsed plotly object
          plotlyJson = pj;
        } else {
          console.warn(`Invalid plotly_json format for ${key}:`, typeof pj);
          continue;
        }
      } catch (e) {
        console.error(`Failed to parse plotly_json for ${key}:`, e);
        console.error('Plotly JSON (first 500 chars):', typeof plotData.plotly_json === 'string' ? plotData.plotly_json.substring(0, 500) : plotData.plotly_json);
        continue;
      }
    } else if (plotData && (plotData.data || plotData.layout)) {
      // Already parsed plotly object (direct)
      plotlyJson = plotData;
    } else {
      console.warn(`Invalid plot data structure for ${key}:`, typeof plotData, plotData ? Object.keys(plotData) : 'null');
      continue;
    }
    
    // Clean trace names before processing
    plotlyJson = cleanPlotlyTraceNames(plotlyJson);
    
    // Validate parsed JSON has required structure
    if (!plotlyJson || (!plotlyJson.data && !plotlyJson.layout)) {
      console.warn(`Skipping ${key}: invalid plotly structure (missing data/layout)`);
      continue;
    }
    
    try {
      // Check if this is a heatmap or surface plot
      const keyLower = key.toLowerCase();
      if (keyLower.includes('heatmap')) {
        // If we already have a heatmap, prefer the first one found or keep the first
        if (!viewPlots.heatmap) {
        viewPlots.heatmap = plotlyJson;
          console.debug(`✅ Found heatmap plot: "${key}"`);
        } else {
          console.debug(`Found additional heatmap plot: "${key}" (keeping first)`);
        }
      } else if (keyLower.includes('surface')) {
        // If we already have a surface, prefer the first one found or keep the first
        if (!viewPlots.surface) {
        viewPlots.surface = plotlyJson;
          console.debug(`✅ Found surface plot: "${key}"`);
        } else {
          console.debug(`Found additional surface plot: "${key}" (keeping first)`);
        }
      }
    } catch (err) {
      console.warn('Failed to process plot', key, err);
    }
  }

  // Ensure proper sizing for the plot containers
  const plotConfig = {
    responsive: true,
    displaylogo: false,
    scrollZoom: true,
    modeBarButtonsToRemove: ['lasso2d', 'select2d', 'toggleSpikelines']
  };

  // Render heatmap - Check if Plotly is available
  if (typeof Plotly === 'undefined') {
    console.error('Plotly is not loaded!');
    heatmapDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: red;">Error: Plotly library not loaded. Please refresh the page.</div>';
    surfaceDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: red;">Error: Plotly library not loaded. Please refresh the page.</div>';
    return;
  }

  console.debug('displayMapResults: heatmap data:', viewPlots.heatmap ? 'available' : 'missing');
  console.debug('displayMapResults: surface data:', viewPlots.surface ? 'available' : 'missing');

  // Render heatmap
  if (viewPlots.heatmap && viewPlots.heatmap.data && viewPlots.heatmap.data.length > 0) {
    console.debug('Rendering heatmap plot with', viewPlots.heatmap.data.length, 'traces');
    console.debug('Heatmap trace type:', viewPlots.heatmap.data[0]?.type);
    
    // Ensure the heatmap div is visible before rendering
    const isHeatmapVisible = heatmapDiv.offsetParent !== null || heatmapDiv.style.display !== 'none';
    if (!isHeatmapVisible) {
      console.debug('Heatmap div not visible, making it visible');
      heatmapDiv.style.display = 'block';
    }
    
    // Clean up any existing plot first
    if (heatmapDiv.querySelector('.js-plotly-plot')) {
      Plotly.purge(heatmapDiv);
    }
    
    // Validate heatmap data
    const heatmapTrace = viewPlots.heatmap.data[0];
    if (!heatmapTrace || !heatmapTrace.type) {
      console.error('❌ Invalid heatmap trace - missing type:', heatmapTrace);
      heatmapDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--danger);">Invalid heatmap trace: missing type</div>';
      return;
    }
    
    // Ensure layout exists and apply theme colors
    const layout = viewPlots.heatmap.layout || {title: 'Heatmap'};
    const isLight = document.body.classList.contains('light-theme');
    if (isLight) {
      layout.paper_bgcolor = 'white';
      layout.plot_bgcolor = 'white';
      if (!layout.font) layout.font = {};
      layout.font.color = '#2d3748';
      if (layout.xaxis) layout.xaxis.gridcolor = '#e2e8f0';
      if (layout.yaxis) layout.yaxis.gridcolor = '#e2e8f0';
      if (layout.coloraxis && layout.coloraxis.colorbar) {
        if (!layout.coloraxis.colorbar.tickfont) layout.coloraxis.colorbar.tickfont = {};
        layout.coloraxis.colorbar.tickfont.color = '#2d3748';
        if (!layout.coloraxis.colorbar.title || typeof layout.coloraxis.colorbar.title === 'string') {
          layout.coloraxis.colorbar.title = { text: layout.coloraxis.colorbar.title || '', font: { color: '#2d3748' } };
        } else if (layout.coloraxis.colorbar.title) {
          if (!layout.coloraxis.colorbar.title.font) layout.coloraxis.colorbar.title.font = {};
          layout.coloraxis.colorbar.title.font.color = '#2d3748';
        }
      }
    } else {
      layout.paper_bgcolor = 'black';
      layout.plot_bgcolor = 'black';
      if (!layout.font) layout.font = {};
      layout.font.color = '#dce1e6';
      if (layout.xaxis) layout.xaxis.gridcolor = '#2d353a';
      if (layout.yaxis) layout.yaxis.gridcolor = '#2d353a';
      if (layout.coloraxis && layout.coloraxis.colorbar) {
        if (!layout.coloraxis.colorbar.tickfont) layout.coloraxis.colorbar.tickfont = {};
        layout.coloraxis.colorbar.tickfont.color = '#dce1e6';
        if (!layout.coloraxis.colorbar.title || typeof layout.coloraxis.colorbar.title === 'string') {
          layout.coloraxis.colorbar.title = { text: layout.coloraxis.colorbar.title || '', font: { color: '#dce1e6' } };
        } else if (layout.coloraxis.colorbar.title) {
          if (!layout.coloraxis.colorbar.title.font) layout.coloraxis.colorbar.title.font = {};
          layout.coloraxis.colorbar.title.font.color = '#dce1e6';
        }
      }
    }
    
    try {
      // CRITICAL: Use newPlot instead of react for initial render on empty div
      console.debug('🎨 Rendering heatmap plot:', {
        traceType: heatmapTrace.type,
        hasLayout: !!layout,
        dataLength: viewPlots.heatmap.data.length
      });
      
      Plotly.newPlot(heatmapDiv, viewPlots.heatmap.data, layout, plotConfig).then(() => {
        console.debug('✅ Map heatmap plot rendered successfully');
        // Trigger resize after render
        setTimeout(() => {
          if (typeof Plotly !== 'undefined' && Plotly.Plots && heatmapDiv.querySelector('.js-plotly-plot')) {
            Plotly.Plots.resize(heatmapDiv);
            console.debug('Heatmap plot resized');
          }
        }, 300);
      }).catch(err => {
        console.error('❌ Map heatmap plot failed:', err);
        console.error('Heatmap plot error details:', {
          message: err.message,
          stack: err.stack,
          dataLength: viewPlots.heatmap.data.length,
          traceType: viewPlots.heatmap.data[0]?.type,
          hasLayout: !!layout
        });
        heatmapDiv.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--danger);">
          <strong>Failed to render heatmap plot</strong><br>
          <small>${err.message || String(err)}</small><br>
          <small style="font-size: 10px;">Check console for details</small>
        </div>`;
      });
    } catch (err) {
      console.error('❌ Error rendering heatmap:', err);
      console.error('Heatmap rendering exception:', err.stack);
      heatmapDiv.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--danger);">
        <strong>Error rendering heatmap</strong><br>
        <small>${err.message || String(err)}</small>
      </div>`;
    }
  } else {
    console.warn('⚠️  No heatmap data available. viewPlots.heatmap:', viewPlots.heatmap);
    if (viewPlots.heatmap) {
      console.warn('Heatmap data structure:', {
        hasData: !!viewPlots.heatmap.data,
        dataLength: viewPlots.heatmap.data ? viewPlots.heatmap.data.length : 0,
        hasLayout: !!viewPlots.heatmap.layout,
        dataType: typeof viewPlots.heatmap.data
      });
    }
    heatmapDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--ink-soft);">No heatmap data available. Check console for details.</div>';
  }

  // Render surface plot (always render even if hidden, so it's ready when switching views)
  if (viewPlots.surface && viewPlots.surface.data && viewPlots.surface.data.length > 0) {
    console.debug('Rendering surface plot with', viewPlots.surface.data.length, 'traces');
    console.debug('Surface trace type:', viewPlots.surface.data[0]?.type);
    
    // Validate surface trace data
    const surfaceTrace = viewPlots.surface.data[0];
    if (!surfaceTrace || !surfaceTrace.type) {
      console.error('❌ Invalid surface trace - missing type:', surfaceTrace);
      surfaceDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--danger);">Invalid surface trace: missing type</div>';
      return;
    }
    
    if (surfaceTrace.type !== 'surface') {
      console.warn(`⚠️ Unexpected surface trace type: ${surfaceTrace.type}, expected 'surface'`);
      // Still try to render if it's a valid 3D plot type
    }
    
    // Validate x, y, z arrays - Plotly Surface can handle various formats
    const x = surfaceTrace.x;
    const y = surfaceTrace.y;
    const z = surfaceTrace.z;
    
    if (!x || !y || !z) {
      console.error('❌ Missing x, y, or z data in surface trace:', {hasX: !!x, hasY: !!y, hasZ: !!z});
      surfaceDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--danger);">Missing x, y, or z data in surface plot</div>';
      return;
    }
    
    // Check if arrays are valid - Plotly is more flexible, so be lenient
    const xIsValid = (Array.isArray(x) || (Array.isArray(x) && Array.isArray(x[0]))) && (Array.isArray(x) ? x.length : x[0]?.length) > 0;
    const yIsValid = (Array.isArray(y) || (Array.isArray(y) && Array.isArray(y[0]))) && (Array.isArray(y) ? y.length : y[0]?.length) > 0;
    const zIsValid = Array.isArray(z) && z.length > 0 && (Array.isArray(z[0]) ? z[0].length > 0 : true);
    
    if (!xIsValid || !yIsValid || !zIsValid) {
      console.error('❌ Invalid array structure:', {
        xIsValid, xType: typeof x, xLength: Array.isArray(x) ? x.length : (Array.isArray(x[0]) ? x[0].length : 'N/A'),
        yIsValid, yType: typeof y, yLength: Array.isArray(y) ? y.length : (Array.isArray(y[0]) ? y[0].length : 'N/A'),
        zIsValid, zType: typeof z, zLength: Array.isArray(z) ? z.length : 0,
        z0Length: Array.isArray(z) && z[0] ? (Array.isArray(z[0]) ? z[0].length : 'scalar') : 0
      });
      // Don't return - let Plotly try to render it, it might handle edge cases
      console.warn('⚠️ Proceeding with rendering despite validation warnings - Plotly may handle it');
    }
    
    // Temporarily make div visible for rendering (Plotly needs visible container)
    const wasHidden = surfaceDiv.style.display === 'none';
    const originalDisplay = surfaceDiv.style.display;
    const originalVisibility = surfaceDiv.style.visibility;
    
    if (wasHidden) {
      // Make temporarily visible for rendering, but keep it off-screen
      surfaceDiv.style.display = 'block';
      surfaceDiv.style.visibility = 'hidden';
      surfaceDiv.style.position = 'absolute';
      surfaceDiv.style.left = '-9999px';
      surfaceDiv.style.width = '100%';
      surfaceDiv.style.height = '500px';
    }
    
    // Clean up any existing plot first
    if (surfaceDiv.querySelector('.js-plotly-plot')) {
      Plotly.purge(surfaceDiv);
    }
    
    // Ensure layout exists with proper scene configuration for 3D plots
    const surfaceLayout = viewPlots.surface.layout || {};
    if (!surfaceLayout.scene) {
      surfaceLayout.scene = {
        xaxis_title: "RPM",
        yaxis_title: "Torque (N·m)",
        zaxis_title: surfaceLayout.zaxis_title || "Value",
        camera: {eye: {x: 1.5, y: 1.5, z: 1.2}}
      };
    }
    
    // Apply theme colors to surface plot
    const isLightMap = document.body.classList.contains('light-theme');
    if (isLightMap) {
      surfaceLayout.paper_bgcolor = 'white';
      surfaceLayout.plot_bgcolor = 'white';
      if (!surfaceLayout.font) surfaceLayout.font = {};
      surfaceLayout.font.color = '#2d3748';
      if (surfaceLayout.scene) {
        surfaceLayout.scene.bgcolor = 'white';
        if (surfaceLayout.scene.xaxis) surfaceLayout.scene.xaxis.gridcolor = '#e2e8f0';
        if (surfaceLayout.scene.yaxis) surfaceLayout.scene.yaxis.gridcolor = '#e2e8f0';
        if (surfaceLayout.scene.zaxis) surfaceLayout.scene.zaxis.gridcolor = '#e2e8f0';
      }
    } else {
      surfaceLayout.paper_bgcolor = 'black';
      surfaceLayout.plot_bgcolor = 'black';
      if (!surfaceLayout.font) surfaceLayout.font = {};
      surfaceLayout.font.color = '#dce1e6';
      if (surfaceLayout.scene) {
        surfaceLayout.scene.bgcolor = 'black';
        if (surfaceLayout.scene.xaxis) surfaceLayout.scene.xaxis.gridcolor = '#2d353a';
        if (surfaceLayout.scene.yaxis) surfaceLayout.scene.yaxis.gridcolor = '#2d353a';
        if (surfaceLayout.scene.zaxis) surfaceLayout.scene.zaxis.gridcolor = '#2d353a';
      }
    }
    
    try {
      // Use newPlot for initial render to avoid "Cannot set properties of null" error
      console.debug('🎨 Rendering surface plot with data shape:', {
        dataLength: viewPlots.surface.data.length,
        xShape: Array.isArray(surfaceTrace.x) ? `${surfaceTrace.x.length}x${Array.isArray(surfaceTrace.x[0]) ? surfaceTrace.x[0].length : '1'}` : 'unknown',
        yShape: Array.isArray(surfaceTrace.y) ? `${surfaceTrace.y.length}x${Array.isArray(surfaceTrace.y[0]) ? surfaceTrace.y[0].length : '1'}` : 'unknown',
        zShape: Array.isArray(surfaceTrace.z) ? `${surfaceTrace.z.length}x${Array.isArray(surfaceTrace.z[0]) ? surfaceTrace.z[0].length : '1'}` : 'unknown'
      });
      
      Plotly.newPlot(surfaceDiv, viewPlots.surface.data, surfaceLayout, plotConfig).then(() => {
        console.debug('✅ Map surface plot rendered successfully');
        
        // Restore original visibility state if it was hidden
        if (wasHidden) {
          surfaceDiv.style.display = originalDisplay || 'none';
          surfaceDiv.style.visibility = originalVisibility || '';
          surfaceDiv.style.position = '';
          surfaceDiv.style.left = '';
        }
        
        // Trigger resize after render (will work when div becomes visible)
        setTimeout(() => {
          if (typeof Plotly !== 'undefined' && Plotly.Plots && surfaceDiv.querySelector('.js-plotly-plot')) {
            // Only resize if visible
            if (surfaceDiv.offsetParent !== null || surfaceDiv.style.display !== 'none') {
            Plotly.Plots.resize(surfaceDiv);
            console.debug('Surface plot resized');
            }
          }
        }, 200);
      }).catch(err => {
        console.error('❌ Map surface plot failed:', err);
        console.error('Surface plot error details:', {
          message: err.message,
          stack: err.stack,
          dataLength: viewPlots.surface.data.length,
          traceType: viewPlots.surface.data[0]?.type,
          hasLayout: !!viewPlots.surface.layout
        });
        
        // Check for WebGL-specific errors
        const isWebGLError = err.message && (
          err.message.includes('WebGL') || 
          err.message.includes('uniformMatrix4fv') ||
          err.message.includes('cannot be converted to a sequence') ||
          err.message.includes('rendering context')
        );
        
        if (isWebGLError) {
          console.warn('⚠️ WebGL error detected - falling back to heatmap view');
          // Switch to heatmap view automatically
          const heatmapBtn = document.querySelector('.map-view-btn[data-view="heatmap"]');
          if (heatmapBtn) {
            heatmapBtn.click();
          }
          toast('3D surface plot unavailable (WebGL error). Showing heatmap instead.', {type:'warn', timeout:5000});
        }
        
        if (wasHidden) {
          surfaceDiv.style.display = originalDisplay || 'none';
          surfaceDiv.style.visibility = originalVisibility || '';
          surfaceDiv.style.position = '';
          surfaceDiv.style.left = '';
        }
        surfaceDiv.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--danger);">
          <strong>Failed to render surface plot</strong><br>
          <small>${err.message || String(err)}</small>${isWebGLError ? '<br><small style="opacity:0.7;">Try using the heatmap view instead.</small>' : ''}
        </div>`;
      });
    } catch (err) {
      console.error('❌ Error rendering surface:', err);
      console.error('Surface rendering exception:', err.stack);
      
      // Check for WebGL-specific errors
      const isWebGLError = err.message && (
        err.message.includes('WebGL') || 
        err.message.includes('uniformMatrix4fv') ||
        err.message.includes('cannot be converted to a sequence') ||
        err.message.includes('rendering context')
      );
      
      if (isWebGLError) {
        console.warn('⚠️ WebGL error detected - falling back to heatmap view');
        const heatmapBtn = document.querySelector('.map-view-btn[data-view="heatmap"]');
        if (heatmapBtn) {
          heatmapBtn.click();
        }
        toast('3D surface plot unavailable (WebGL error). Showing heatmap instead.', {type:'warn', timeout:5000});
      }
      
      if (wasHidden) {
        surfaceDiv.style.display = originalDisplay || 'none';
        surfaceDiv.style.visibility = originalVisibility || '';
        surfaceDiv.style.position = '';
        surfaceDiv.style.left = '';
      }
      surfaceDiv.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--danger);">
        <strong>Error rendering surface plot</strong><br>
        <small>${err.message || String(err)}</small>${isWebGLError ? '<br><small style="opacity:0.7;">Try using the heatmap view instead.</small>' : ''}
      </div>`;
    }
  } else {
    console.warn('⚠️  No surface data available. viewPlots.surface:', viewPlots.surface);
    if (viewPlots.surface) {
      console.warn('Surface data structure:', {
        hasData: !!viewPlots.surface.data,
        dataLength: viewPlots.surface.data ? viewPlots.surface.data.length : 0,
        hasLayout: !!viewPlots.surface.layout,
        dataType: typeof viewPlots.surface.data
      });
    }
    surfaceDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--ink-soft);">No surface data available. Check console for details.</div>';
  }

  // Display statistics and metadata
  const mapSummary = tables && tables['Map Summary'] ? tables['Map Summary'] : [];
  const signalMapping = tables && tables['Signal Mapping'] ? tables['Signal Mapping'] : [];
  
  let statsHtml = '<h4>Map Statistics</h4>';
  if (mapSummary.length > 0) {
    statsHtml += '<table style="width: 100%; border-collapse: collapse;">';
    statsHtml += '<tr><th style="border: 1px solid #ccc; padding: 8px;">Map</th><th style="border: 1px solid #ccc; padding: 8px;">Coverage %</th><th style="border: 1px solid #ccc; padding: 8px;">Mean</th><th style="border: 1px solid #ccc; padding: 8px;">Min</th><th style="border: 1px solid #ccc; padding: 8px;">Max</th></tr>';
    mapSummary.forEach(map => {
      statsHtml += `<tr>
        <td style="border: 1px solid #ccc; padding: 8px;">${map.map}</td>
        <td style="border: 1px solid #ccc; padding: 8px;">${map.coverage_pct?.toFixed(2) || 'N/A'}</td>
        <td style="border: 1px solid #ccc; padding: 8px;">${map.mean?.toFixed(2) || 'N/A'}</td>
        <td style="border: 1px solid #ccc; padding: 8px;">${map.min?.toFixed(2) || 'N/A'}</td>
        <td style="border: 1px solid #ccc; padding: 8px;">${map.max?.toFixed(2) || 'N/A'}</td>
      </tr>`;
    });
    statsHtml += '</table>';
  } else {
    statsHtml += '<p>No statistics available.</p>';
  }
  
  statsContent.innerHTML = statsHtml;

  let metaHtml = '<h4>Metadata</h4>';
  if (meta) {
    metaHtml += '<div style="max-height: 300px; overflow-y: auto;">';
    metaHtml += '<pre style="font-size: 12px; white-space: pre-wrap;">';
    metaHtml += JSON.stringify(meta, null, 2);
    metaHtml += '</pre>';
    metaHtml += '</div>';
  } else {
    metaHtml += '<p>No metadata available.</p>';
  }
  
  metaContent.innerHTML = metaHtml;
}

function showStatus(message, type = 'info') {
    const statusEl = document.getElementById('map-status');
    if (!statusEl) return;
    statusEl.textContent = message;
    statusEl.className = 'pg-status ' + type;
    statusEl.style.display = 'block';
}

// Advanced Frontend Integration Functions
async function validateFiles() {
    const checkedFiles = Array.from(document.getElementById('map-file-list')?.querySelectorAll('input:checked') || []);
    const files = checkedFiles.map(i => i.value);
    
    if (files.length === 0) {
        toast('No files selected for validation', {type: 'warn'});
        return;
    }
    
    try {
        showStatus('Validating files...', 'loading');
        const res = await safeFetch('/api/validate_files', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ files: files })
        });
        
        if (res.ok) {
            displayValidationResults(res.validation);
            showStatus('Validation complete', 'success');
        } else {
            showStatus('Validation failed: ' + (res.error || 'Unknown error'), 'error');
        }
    } catch (err) {
        console.error('Validation error:', err);
        showStatus('Validation failed: ' + err.message, 'error');
    }
}

function displayValidationResults(validation) {
    const resultsEl = document.getElementById('validation-results');
    if (!resultsEl) return;
    
    const { files, overall_score, warnings, errors } = validation;
    
    let html = `<div class="validation-score ${overall_score >= 80 ? 'good' : overall_score >= 60 ? 'warning' : 'poor'}">
        Overall Score: ${overall_score}/100
    </div>`;
    
    if (errors.length > 0) {
        html += `<div style="color: var(--danger); margin: 8px 0;"><strong>Errors:</strong><ul>`;
        errors.forEach(error => html += `<li>${error}</li>`);
        html += `</ul></div>`;
    }
    
    if (warnings.length > 0) {
        html += `<div style="color: var(--warn); margin: 8px 0;"><strong>Warnings:</strong><ul>`;
        warnings.forEach(warning => html += `<li>${warning}</li>`);
        html += `</ul></div>`;
    }
    
    html += '<div style="margin-top: 12px;"><strong>File Details:</strong></div>';
    
    Object.entries(files).forEach(([filePath, fileInfo]) => {
        const fileName = fileInfo.name || filePath.split('/').pop();
        html += `<div class="validation-file-item ${fileInfo.status}">
            <div>
                <strong>${fileName}</strong>
                <div style="font-size: 0.9rem; color: var(--ink-soft);">
                    ${fileInfo.size_mb.toFixed(1)} MB • ${fileInfo.format}
                </div>
                ${fileInfo.issues.length > 0 ? `<div style="font-size: 0.8rem; color: var(--ink-soft);">
                    ${fileInfo.issues.join(', ')}
                </div>` : ''}
            </div>
            <div style="font-weight: bold; text-transform: uppercase;">
                ${fileInfo.status}
            </div>
        </div>`;
    });
    
    resultsEl.innerHTML = html;
    
    // Show validation dashboard
    const dashboard = document.getElementById('validation-dashboard');
    if (dashboard) dashboard.style.display = 'block';
}

async function getSignalSuggestions() {
    const channels = (window.state && window.state.channels) ? window.state.channels : [];
    if (channels.length === 0) {
        toast('No channels available for suggestions', {type: 'warn'});
        return;
    }
    
    const columnNames = channels.map(ch => ch.id || ch.name || ch.clean).slice(0, 50); // Limit to first 50
    
    try {
        showStatus('Getting signal suggestions...', 'loading');
        const res = await safeFetch('/api/signal_suggestions', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ columns: columnNames })
        });
        
        if (res.ok) {
            displaySignalSuggestions(res.suggestions, res.unmapped_columns);
            showStatus('Signal suggestions ready', 'success');
        } else {
            showStatus('Signal suggestions failed: ' + (res.error || 'Unknown error'), 'error');
        }
    } catch (err) {
        console.error('Signal suggestions error:', err);
        showStatus('Signal suggestions failed: ' + err.message, 'error');
    }
}

function displaySignalSuggestions(suggestions, unmappedColumns) {
    const resultsEl = document.getElementById('validation-results');
    if (!resultsEl) return;
    
    let html = '<div class="signal-suggestions">';
    html += '<h4>Intelligent Signal Mapping</h4>';
    
    if (Object.keys(suggestions).length > 0) {
        html += '<div style="margin-bottom: 12px;"><strong>Mapped Signals:</strong></div>';
        
        Object.entries(suggestions).forEach(([column, suggestion]) => {
            const confidence = suggestion.confidence;
            const confidenceClass = confidence >= 0.8 ? 'high' : confidence >= 0.5 ? 'medium' : 'low';
            
            html += `<div class="signal-suggestion-item">
                <div>
                    <strong>${column}</strong> → ${suggestion.suggested_signal}
                    <div style="font-size: 0.8rem; color: var(--ink-soft);">
                        ${suggestion.category} • ${suggestion.units} • ${suggestion.method}
                    </div>
                </div>
                <span class="confidence-badge ${confidenceClass}">
                    ${Math.round(confidence * 100)}%
                </span>
            </div>`;
        });
    }
    
    if (unmappedColumns.length > 0) {
        html += '<div style="margin-top: 12px;"><strong>Unmapped Signals:</strong></div>';
        html += '<div style="font-size: 0.9rem; color: var(--ink-soft);">';
        html += unmappedColumns.slice(0, 10).join(', ');
        if (unmappedColumns.length > 10) {
            html += ` and ${unmappedColumns.length - 10} more...`;
        }
        html += '</div>';
    }
    
    html += '</div>';
    
    // Append to existing validation results
    resultsEl.innerHTML += html;
}

function displayProgressStages(stages, overallProgress = 0) {
    const stagesEl = document.getElementById('progress-stages');
    const summaryEl = document.getElementById('progress-summary');
    
    if (!stagesEl) return;
    
    const stageNames = {
        'file_loading': 'File Loading',
        'signal_mapping': 'Signal Mapping', 
        'data_validation': 'Data Validation',
        'physics_calculations': 'Physics Calculations',
        'map_generation': 'Map Generation',
        'optimization': 'Optimization',
        'visualization': 'Visualization'
    };
    
    let html = '<div class="progress-bar"><div class="progress-bar-fill" style="width: ' + overallProgress + '%"></div></div>';
    
    Object.entries(stages).forEach(([stageKey, stageInfo]) => {
        const stageName = stageNames[stageKey] || stageKey;
        const statusClass = stageInfo.status === 'completed' ? 'completed' : 
                          stageInfo.status === 'processing' ? 'processing' : 'pending';
        
        html += `<div class="progress-stage ${statusClass}">
            <div>
                <strong>${stageName}</strong>
                <div style="font-size: 0.8rem; color: var(--ink-soft);">${stageInfo.message}</div>
            </div>
            <div style="font-weight: bold;">
                ${stageInfo.progress}%
            </div>
        </div>`;
    });
    
    stagesEl.innerHTML = html;
    
    if (summaryEl) {
        const processingTime = stages.visualization?.processing_time || 0;
        summaryEl.innerHTML = `
            <strong>Overall Progress: ${overallProgress}%</strong> | 
            Processing Time: ${processingTime}s | 
            Current Stage: ${stages.visualization?.current_stage || 'Complete'}
        `;
    }
}

function initEmpiricalMap() {
    const channels = (window.state && window.state.channels) ? window.state.channels : [];
    const options = channels.map(ch => {
        const val = typeof ch === 'string' ? ch : (ch.id || ch.name || ch.clean);
        return `<option value="${val}">${val}</option>`;
    }).join('');

    const selects = ['map-x-axis', 'map-y-axis', 'map-z-axis'];
    selects.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.innerHTML = '<option value="">-- Select --</option>' + options;
    });

  const presetSelect = document.getElementById('map-preset');
  if (presetSelect && presetSelect.options.length <= 1) {
        Object.keys(MAP_PRESETS).forEach(key => {
            const opt = document.createElement('option');
            opt.value = key;
            opt.textContent = MAP_PRESETS[key].label;
            presetSelect.appendChild(opt);
        });
    }

  if (presetSelect) presetSelect.addEventListener('change', (e) => applyMapPreset(e.target.value));

  const previewBtn = document.getElementById('preset-apply-now');
  if (previewBtn) {
    previewBtn.addEventListener('click', (e) => {
      e.preventDefault();
      const key = presetSelect?.value;
      if (!key) {
        toast('Select a preset before previewing.', {type:'warn'});
        return;
      }
      applyMapPreset(key);
      generateEmpiricalMap().catch(err => console.error('Preset preview failed', err));
    });
  }
    
  const generateBtn = document.getElementById('generate-map');
  if (generateBtn) {
    generateBtn.addEventListener('click', (e) => {
      if (mapAutoGenerationTimer) {
        clearTimeout(mapAutoGenerationTimer);
        mapAutoGenerationTimer = null;
      }
      generateEmpiricalMap(e).catch(err => console.error('Generate map failed', err));
    });
  }

  // Add event listeners for validation and signal suggestions
  const validateBtn = document.getElementById('btn-validate-files');
  if (validateBtn) {
    validateBtn.addEventListener('click', validateFiles);
  }

  const suggestionsBtn = document.getElementById('btn-get-signal-suggestions');
  if (suggestionsBtn) {
    suggestionsBtn.addEventListener('click', getSignalSuggestions);
  }
    document.getElementById('clear-map')?.addEventListener('click', () => {
        const resultsEl = document.getElementById('map-results');
        if (resultsEl) {
            resultsEl.style.display = 'none';
        }
        const heatmapDiv = document.getElementById('map-heatmap');
        const surfaceDiv = document.getElementById('map-surface');
        if (heatmapDiv) {
            Plotly.purge(heatmapDiv);
        }
        if (surfaceDiv) {
            Plotly.purge(surfaceDiv);
        }
        const statsContent = document.getElementById('map-stats-content');
        const metaContent = document.getElementById('map-meta');
        if (statsContent) {
            statsContent.innerHTML = '';
        }
        if (metaContent) {
            metaContent.innerHTML = '';
        }
        window.currentMapResults = null;
    });

    document.querySelectorAll('.map-view-btn').forEach(btn => {
        btn.addEventListener('click', e => {
            const view = e.target.dataset.view;
            console.debug('Switching to view:', view);
            
            // Update button states
            document.querySelectorAll('.map-view-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            
            // Show/hide panels
            ['heatmap', 'surface', 'stats'].forEach(v => {
                const element = document.getElementById('map-' + v);
                if (element) {
                    const shouldShow = (v === view);
                    element.style.display = shouldShow ? 'block' : 'none';
                    console.debug(`View ${v}: ${shouldShow ? 'shown' : 'hidden'}`);
                    
                    // If switching to a plot view and plot hasn't been rendered, render it now
                    if (shouldShow && (v === 'heatmap' || v === 'surface')) {
                        if (window.currentMapResults) {
                            // Check if plot div is empty or has error message
                            const plotDiv = element;
                            const isEmpty = !plotDiv.querySelector('.js-plotly-plot') || 
                                         plotDiv.innerHTML.includes('No ') ||
                                         plotDiv.innerHTML.includes('Error:') ||
                                         plotDiv.innerHTML.trim() === '';
                            
                            if (isEmpty && window.currentMapResults.plots) {
                                console.debug(`Re-rendering ${v} plot`);
                                setTimeout(() => {
                                    displayMapResults(window.currentMapResults);
                                }, 50);
                            }
                        }
                    }
                }
            });
            
            // Trigger plot resize when switching views
            setTimeout(() => {
                if(view === 'heatmap' || view === 'surface') {
                    const plotElement = document.getElementById('map-' + view);
                    if (plotElement && typeof Plotly !== 'undefined' && Plotly.Plots) {
                        // Check if plot exists, if not, re-render
                        const hasPlot = plotElement.querySelector('.js-plotly-plot');
                        if (!hasPlot && window.currentMapResults && window.currentMapResults.plots) {
                            console.debug(`Plot for ${view} not found, re-rendering...`);
                            displayMapResults(window.currentMapResults);
                        } else if (hasPlot) {
                        console.debug('Resizing plot for view:', view);
                        Plotly.Plots.resize(plotElement);
                        }
                    }
                }
            }, 150);
        });
    });
    
    document.getElementById('map-export-csv')?.addEventListener('click', () => exportMapData('csv'));
    document.getElementById('map-export-xlsx')?.addEventListener('click', () => exportMapData('xlsx'));
    document.getElementById('map-download-plot')?.addEventListener('click', downloadMapPlot);
}

function exportMapData(format) {
  if (!window.currentMapResults || !window.currentMapResults.samples) {
        toast('No map data to export.', {type:'error'});
        return;
    }
    const { samples, tables } = window.currentMapResults;
    if (!samples || !samples.columns || !samples.samples) {
        toast('No map data to export.', {type:'error'});
        return;
    }
    const payload = {
        format,
        tables: tables,
        samples,
    };
    fetch('/api/export_map', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    })
    .then(res => {
        if (!res.ok) throw new Error('Export failed on server');
        return res.blob();
    })
    .then(blob => {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `empirical_map.${format}`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
        toast(`Map exported as ${format.toUpperCase()}`, {type:'success'});
    })
    .catch(err => {
        console.error("Map export failed:", err);
        toast('Map export failed: ' + err.message, {type:'error'});
    });
}

function downloadMapPlot() {
    const activeView = document.querySelector('.map-view-btn.active')?.dataset.view || 'heatmap';
    const plotDivId = 'map-' + activeView;
    const plotDiv = document.getElementById(plotDivId);
    if (!plotDiv || !plotDiv.data) {
        toast('No plot to download.', {type:'error'});
        return;
    }
    const title = window.currentMapResults?.meta?.title || 'empirical_map';
    Plotly.downloadImage(plotDiv, {format: 'png', width: 1200, height: 800, filename: title.replace(/\s/g, '_')});
}

/* ====================== Initialization ====================== */
document.addEventListener('DOMContentLoaded', () => {
    initThemeToggle();
    refreshFileList(); // Initial file list check
    updateReportControlsState(); // Set initial state of report controls

    document.querySelectorAll('.tabs button').forEach(btn => {
        btn.onclick = () => activateTab(btn.id.replace('tabbtn-', ''));
    });

    // Load channels from localStorage if available
    try {
        const storedChannels = localStorage.getItem('mdf_channels');
        if (storedChannels) {
            state.channels = JSON.parse(storedChannels);
            if (state.channels.length > 0) {
                renderChannelTable();
                if (typeof syncStateToPlayground === 'function') {
                  syncStateToPlayground();
                }
                setStatus('disc-status', `Loaded ${state.channels.length} channels from cache.`);
            }
        }
    } catch (e) {
        console.warn('Could not load channels from localStorage:', e);
    }
    
    if (typeof initPlayground === 'function') initPlayground();
    initEmpiricalMap();
    loadUploadedFiles();
    activateTab('analyse');

    // Section toggling for playground
    document.querySelectorAll('.toggle-section').forEach(button => {
        button.addEventListener('click', () => {
            const section = button.closest('.control-section');
            section.classList.toggle('collapsed');
            button.textContent = section.classList.contains('collapsed') ? '+' : '−';
        });
    });


    log('Portal ready.');
});
</script>
</body>
</html>